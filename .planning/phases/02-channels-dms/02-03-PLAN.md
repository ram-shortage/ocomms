---
phase: 02-channels-dms
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/conversation.ts
  - src/db/schema/index.ts
  - src/components/dm/start-dm-dialog.tsx
  - src/components/dm/dm-list.tsx
  - src/components/dm/add-participants-dialog.tsx
  - src/lib/actions/conversation.ts
  - src/app/(workspace)/[workspaceSlug]/dm/[conversationId]/page.tsx
  - src/app/(workspace)/[workspaceSlug]/page.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Member can start 1:1 DM with another workspace member"
    - "Member can start group DM with 3+ members"
    - "Member can add participants to existing group DM"
    - "DMs appear in sidebar separate from channels"
  artifacts:
    - path: "src/db/schema/conversation.ts"
      provides: "Conversation and participants tables"
      contains: "pgTable.*conversations"
    - path: "src/components/dm/start-dm-dialog.tsx"
      provides: "Start DM UI"
      exports: ["StartDMDialog"]
    - path: "src/components/dm/dm-list.tsx"
      provides: "DM list in sidebar"
      exports: ["DMList"]
    - path: "src/components/dm/add-participants-dialog.tsx"
      provides: "Add members to group DM"
      exports: ["AddParticipantsDialog"]
  key_links:
    - from: "src/components/dm/start-dm-dialog.tsx"
      to: "src/lib/actions/conversation.ts"
      via: "createConversation action"
      pattern: "createConversation"
    - from: "src/components/dm/add-participants-dialog.tsx"
      to: "src/lib/actions/conversation.ts"
      via: "addParticipant action"
      pattern: "addParticipant"
---

<objective>
Create direct message schema and implement 1:1 DMs, group DMs, and participant management.

Purpose: Enable private conversations between workspace members. DMs complement channels for 1:1 and small group discussions.

Output: Members can start DMs with individuals or groups, view DM list in sidebar, and add participants to group conversations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/db/schema/auth.ts (users, organizations, members tables)
@src/db/schema/channel.ts (pattern reference for table structure)
@src/app/(workspace)/[workspaceSlug]/page.tsx (workspace layout)
</context>

<tasks>

<task type="auto">
  <name>Task 1: DM Schema and 1:1/Group Creation</name>
  <files>
    src/db/schema/conversation.ts
    src/db/schema/index.ts
    src/lib/actions/conversation.ts
    src/components/dm/start-dm-dialog.tsx
    src/components/dm/dm-list.tsx
  </files>
  <action>
Create DM schema and core functionality.

**1. Conversation Schema (src/db/schema/conversation.ts):**
```typescript
import { pgTable, text, timestamp, boolean, uuid, uniqueIndex } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { organizations, users } from "./auth";

export const conversations = pgTable("conversations", {
  id: uuid("id").primaryKey().defaultRandom(),
  organizationId: uuid("organization_id")
    .notNull()
    .references(() => organizations.id, { onDelete: "cascade" }),
  isGroup: boolean("is_group").notNull().default(false),
  name: text("name"), // null for 1:1, optional name for group DMs
  createdBy: uuid("created_by")
    .notNull()
    .references(() => users.id, { onDelete: "set null" }),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const conversationParticipants = pgTable("conversation_participants", {
  id: uuid("id").primaryKey().defaultRandom(),
  conversationId: uuid("conversation_id")
    .notNull()
    .references(() => conversations.id, { onDelete: "cascade" }),
  userId: uuid("user_id")
    .notNull()
    .references(() => users.id, { onDelete: "cascade" }),
  joinedAt: timestamp("joined_at").notNull().defaultNow(),
}, (table) => [
  uniqueIndex("conversation_participants_unique_idx").on(table.conversationId, table.userId),
]);

export const conversationsRelations = relations(conversations, ({ one, many }) => ({
  organization: one(organizations, {
    fields: [conversations.organizationId],
    references: [organizations.id],
  }),
  creator: one(users, {
    fields: [conversations.createdBy],
    references: [users.id],
  }),
  participants: many(conversationParticipants),
}));

export const conversationParticipantsRelations = relations(conversationParticipants, ({ one }) => ({
  conversation: one(conversations, {
    fields: [conversationParticipants.conversationId],
    references: [conversations.id],
  }),
  user: one(users, {
    fields: [conversationParticipants.userId],
    references: [users.id],
  }),
}));
```

Key design decisions:
- isGroup false = 1:1 DM, isGroup true = group DM
- 1:1 DMs have no name (display other person's name)
- Group DMs can have optional name, otherwise show participant names
- No duplicate 1:1 conversations between same two users (check in application logic)

**2. Update src/db/schema/index.ts:**
```typescript
export * from "./auth";
export * from "./profile";
export * from "./channel";
export * from "./conversation";
```

Run `npm run db:push` to apply schema.

**3. Conversation Actions (src/lib/actions/conversation.ts):**
```typescript
"use server";

import { db } from "@/db";
import { conversations, conversationParticipants } from "@/db/schema";
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { eq, and, inArray } from "drizzle-orm";
import { revalidatePath } from "next/cache";

export async function createConversation(formData: {
  organizationId: string;
  participantIds: string[];
  name?: string;
}) {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) throw new Error("Unauthorized");

  const allParticipantIds = [...new Set([session.user.id, ...formData.participantIds])];
  const isGroup = allParticipantIds.length > 2;

  // For 1:1, check if conversation already exists
  if (!isGroup) {
    const existingConversations = await db.query.conversations.findMany({
      where: and(
        eq(conversations.organizationId, formData.organizationId),
        eq(conversations.isGroup, false)
      ),
      with: {
        participants: true,
      },
    });

    const existing = existingConversations.find((conv) => {
      const participantUserIds = conv.participants.map((p) => p.userId).sort();
      const targetIds = allParticipantIds.sort();
      return (
        participantUserIds.length === targetIds.length &&
        participantUserIds.every((id, i) => id === targetIds[i])
      );
    });

    if (existing) {
      return existing;
    }
  }

  // Create conversation and add participants
  const [conversation] = await db.transaction(async (tx) => {
    const [newConv] = await tx.insert(conversations).values({
      organizationId: formData.organizationId,
      isGroup,
      name: isGroup ? formData.name || null : null,
      createdBy: session.user.id,
    }).returning();

    await tx.insert(conversationParticipants).values(
      allParticipantIds.map((userId) => ({
        conversationId: newConv.id,
        userId,
      }))
    );

    return [newConv];
  });

  revalidatePath(`/`);
  return conversation;
}

export async function getUserConversations(organizationId: string) {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) throw new Error("Unauthorized");

  const participations = await db.query.conversationParticipants.findMany({
    where: eq(conversationParticipants.userId, session.user.id),
    with: {
      conversation: {
        with: {
          participants: {
            with: {
              user: true,
            },
          },
        },
      },
    },
  });

  return participations
    .filter((p) => p.conversation.organizationId === organizationId)
    .map((p) => p.conversation);
}

export async function getConversation(conversationId: string) {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) throw new Error("Unauthorized");

  const conversation = await db.query.conversations.findFirst({
    where: eq(conversations.id, conversationId),
    with: {
      participants: {
        with: {
          user: true,
        },
      },
    },
  });

  if (!conversation) return null;

  // Check user is participant
  const isParticipant = conversation.participants.some(
    (p) => p.userId === session.user.id
  );

  if (!isParticipant) return null;

  return conversation;
}
```

**4. Start DM Dialog (src/components/dm/start-dm-dialog.tsx):**
Client component with:
- Receives organizationId prop
- Fetches workspace members (reuse getWorkspaceMembers from channel actions or create shared)
- Checkbox list to select 1+ members
- Optional group name field (appears when 2+ members selected)
- "Start Conversation" button calls createConversation
- Redirects to /dm/{conversationId} on success

**5. DM List (src/components/dm/dm-list.tsx):**
Server component for sidebar:
- Receives organizationId prop
- Fetches user's conversations via getUserConversations
- For 1:1: shows other person's name/avatar
- For group: shows name or "Name1, Name2, ..." truncated
- Links to /{workspaceSlug}/dm/{conversationId}
- Empty state: "No direct messages yet"
  </action>
  <verify>
1. `npm run db:push` succeeds
2. Start 1:1 DM with another member
3. Verify DM appears in sidebar
4. Start group DM with 2+ other members
5. Verify group DM appears in sidebar with participant names
  </verify>
  <done>
- DM-01: Members can start 1:1 DM
- DM-02: Members can start group DM (3+ members)
- DM list shows user's conversations in sidebar
  </done>
</task>

<task type="auto">
  <name>Task 2: DM View and Add Participants</name>
  <files>
    src/app/(workspace)/[workspaceSlug]/dm/[conversationId]/page.tsx
    src/components/dm/dm-header.tsx
    src/components/dm/add-participants-dialog.tsx
    src/lib/actions/conversation.ts
    src/app/(workspace)/[workspaceSlug]/page.tsx
  </files>
  <action>
Create DM view page and participant management.

**1. Add to src/lib/actions/conversation.ts:**

```typescript
export async function addParticipant(conversationId: string, userId: string) {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) throw new Error("Unauthorized");

  // Verify requester is participant
  const conversation = await db.query.conversations.findFirst({
    where: eq(conversations.id, conversationId),
    with: {
      participants: true,
    },
  });

  if (!conversation) throw new Error("Conversation not found");

  const isParticipant = conversation.participants.some(
    (p) => p.userId === session.user.id
  );
  if (!isParticipant) throw new Error("Not a participant");

  // Adding to 1:1 converts it to group DM
  if (!conversation.isGroup) {
    await db.update(conversations)
      .set({ isGroup: true, updatedAt: new Date() })
      .where(eq(conversations.id, conversationId));
  }

  // Add participant
  await db.insert(conversationParticipants).values({
    conversationId,
    userId,
  }).onConflictDoNothing();

  revalidatePath(`/`);
  return { success: true };
}

export async function setConversationName(conversationId: string, name: string) {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) throw new Error("Unauthorized");

  // Verify requester is participant
  const conversation = await db.query.conversations.findFirst({
    where: eq(conversations.id, conversationId),
    with: {
      participants: true,
    },
  });

  if (!conversation) throw new Error("Conversation not found");
  if (!conversation.isGroup) throw new Error("Cannot name 1:1 conversations");

  const isParticipant = conversation.participants.some(
    (p) => p.userId === session.user.id
  );
  if (!isParticipant) throw new Error("Not a participant");

  await db.update(conversations)
    .set({ name: name || null, updatedAt: new Date() })
    .where(eq(conversations.id, conversationId));

  revalidatePath(`/`);
  return { success: true };
}
```

**2. DM Page (src/app/(workspace)/[workspaceSlug]/dm/[conversationId]/page.tsx):**
Server component:
- Fetches conversation by ID using getConversation
- Shows 404 if not found or user not participant
- Renders DM header with participant names
- Shows placeholder for messages ("Messages coming in Phase 3")

**3. DM Header (src/components/dm/dm-header.tsx):**
Client component with:
- For 1:1: Other person's name and avatar
- For group: Group name (editable) or participant list
- Participant avatars in row
- "Add people" button for group DMs (any participant can add)
- Opens AddParticipantsDialog

**4. Add Participants Dialog (src/components/dm/add-participants-dialog.tsx):**
Client component with:
- Receives conversationId and organizationId props
- Fetches workspace members not already in conversation
- Checkbox list to select members
- "Add" button calls addParticipant for each selected
- Shows success toast

**5. Update Workspace Page Layout:**
Update src/app/(workspace)/[workspaceSlug]/page.tsx to show DM list in sidebar:
- "Direct Messages" section header
- DMList component
- "New Message" button opening StartDMDialog

The sidebar should now have:
- Channels section (from 02-01)
- Direct Messages section (new)
  </action>
  <verify>
1. Navigate to DM page: /{workspace}/dm/{id}
2. See participant names/avatars in header
3. Add a new participant to group DM
4. Verify participant appears in header
5. Adding participant to 1:1 converts it to group DM
  </verify>
  <done>
- DM-03: Members can add participants to group DM
- DM view page shows participant info
- Adding to 1:1 DM converts it to group DM
- Group DMs can be named
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Schema verification:**
   - conversations and conversation_participants tables exist

2. **1:1 DM flow:**
   - Start DM with member from dialog
   - Conversation appears in sidebar
   - Navigate to DM page, see other person's name

3. **Group DM flow:**
   - Start DM with 2+ members
   - Group DM appears in sidebar
   - Can set/edit group name

4. **Add participants:**
   - Add member to group DM
   - Adding to 1:1 converts to group
   - New participant can access conversation

5. **Build verification:**
   - `npm run build` completes without errors
</verification>

<success_criteria>
- DM-01 (1:1 DM): Member can start direct message with another member
- DM-02 (group DM): Member can start group DM with 3+ members
- DM-03 (add participants): Member can add participants to group DM
- DM list shows conversations in sidebar
- DM page displays participant information
</success_criteria>

<output>
After completion, create `.planning/phases/02-channels-dms/02-03-SUMMARY.md`
</output>
