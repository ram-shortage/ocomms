---
phase: 22-file-uploads
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/file-attachment.ts
  - src/db/schema/index.ts
  - src/lib/file-validation.ts
  - src/app/api/upload/attachment/route.ts
autonomous: true

must_haves:
  truths:
    - "File uploads are validated via magic bytes before storage"
    - "Uploaded files are stored with UUID filenames"
    - "Attachment metadata is persisted in database"
    - "Files over 25MB are rejected with clear error"
  artifacts:
    - path: "src/db/schema/file-attachment.ts"
      provides: "Drizzle schema for file_attachments table"
      exports: ["fileAttachments", "fileAttachmentsRelations"]
    - path: "src/lib/file-validation.ts"
      provides: "Magic bytes validation for all supported file types"
      exports: ["validateFileSignature", "ValidatedFile", "MAX_FILE_SIZE"]
    - path: "src/app/api/upload/attachment/route.ts"
      provides: "POST endpoint for file uploads"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/upload/attachment/route.ts"
      to: "src/lib/file-validation.ts"
      via: "import validateFileSignature"
      pattern: "validateFileSignature"
    - from: "src/app/api/upload/attachment/route.ts"
      to: "src/db/schema/file-attachment.ts"
      via: "db.insert(fileAttachments)"
      pattern: "fileAttachments"
---

<objective>
Create backend infrastructure for file uploads: database schema for file attachments, shared file validation library (magic bytes), and upload API route.

Purpose: Enable secure file upload with proper validation and persistence. This mirrors the proven avatar upload pattern but extends it for general attachments with support for more file types and larger sizes (25MB).

Output: Working /api/upload/attachment endpoint that validates files via magic bytes, stores to disk with UUID names, and persists metadata to database.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-file-uploads/22-RESEARCH.md

# Reference existing avatar upload pattern
@src/app/api/upload/avatar/route.ts
@src/db/schema/message.ts
@src/db/schema/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file attachments database schema</name>
  <files>src/db/schema/file-attachment.ts, src/db/schema/index.ts</files>
  <action>
Create new file `src/db/schema/file-attachment.ts` with Drizzle schema for file_attachments table:

```typescript
// Fields needed:
// - id: uuid primary key (defaultRandom)
// - messageId: uuid nullable (attachment uploaded before message sent)
// - filename: varchar(255) - UUID-based name on disk
// - originalName: varchar(255) - user's original filename
// - mimeType: varchar(100) - validated mime type
// - sizeBytes: integer - file size
// - path: varchar(500) - URL path to file (/uploads/attachments/...)
// - isImage: boolean - for display logic
// - uploadedBy: text - references users.id with cascade delete
// - createdAt: timestamp with default now
```

Add relations:
- message: one-to-many (message can have multiple attachments)
- uploader: one-to-one with users

Update `src/db/schema/index.ts` to export the new schema.

Follow existing schema conventions from message.ts for imports and structure.
  </action>
  <verify>
Run `npx drizzle-kit generate` to verify schema is valid.
Check generated SQL shows file_attachments table with all columns.
  </verify>
  <done>
file_attachments schema exists with all required fields, exported from schema index, and generates valid migration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create shared file validation library</name>
  <files>src/lib/file-validation.ts</files>
  <action>
Create `src/lib/file-validation.ts` that extracts and extends the magic bytes validation from avatar route:

```typescript
export const MAX_FILE_SIZE = 25 * 1024 * 1024; // 25MB

export interface ValidatedFile {
  extension: string;
  mimeType: string;
  isImage: boolean;
}

export function validateFileSignature(bytes: Uint8Array): ValidatedFile | null
```

Support these file types via magic bytes (FILE-07):
- JPEG: FF D8 FF
- PNG: 89 50 4E 47 0D 0A 1A 0A
- GIF: 47 49 46 38 (37|39) 61
- WebP: RIFF....WEBP
- PDF: 25 50 44 46 (%PDF)

Return `{ extension, mimeType, isImage: true/false }` or null if invalid.

Export constants and types for use by upload routes and future components.
  </action>
  <verify>
Create a quick test:
```bash
npx tsx -e "
const { validateFileSignature } = require('./src/lib/file-validation');
// JPEG magic bytes
const jpeg = new Uint8Array([0xff, 0xd8, 0xff, 0xe0]);
const result = validateFileSignature(jpeg);
console.log('JPEG:', result);
// Should output: { extension: 'jpg', mimeType: 'image/jpeg', isImage: true }
"
```
  </verify>
  <done>
File validation library exports validateFileSignature, ValidatedFile type, and MAX_FILE_SIZE constant. Correctly identifies JPEG, PNG, GIF, WebP as images and PDF as non-image.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create attachment upload API route</name>
  <files>src/app/api/upload/attachment/route.ts</files>
  <action>
Create `src/app/api/upload/attachment/route.ts` following the avatar upload pattern but extended:

1. Auth check (same pattern as avatar)
2. Parse FormData, get file
3. Read file into ArrayBuffer for validation
4. Import and use validateFileSignature from lib/file-validation.ts
5. Check size against MAX_FILE_SIZE (25MB) - return 400 with clear error if exceeded (FILE-06)
6. Generate UUID filename with validated extension
7. Create upload directory: public/uploads/attachments
8. Write file to disk
9. Insert metadata into fileAttachments table
10. Return attachment object { id, path, originalName, mimeType, sizeBytes, isImage }

Error responses:
- 401: Unauthorized
- 400: No file provided
- 400: Invalid file type (magic bytes don't match)
- 400: File too large (include "Maximum size: 25MB" in message)
- 500: Upload failed

Use Next.js App Router patterns (NextRequest, NextResponse).
  </action>
  <verify>
Start dev server and test:
```bash
# Create a test image (1x1 PNG)
echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==" | base64 -d > /tmp/test.png

# Test upload (requires auth cookie - manual test via browser)
curl -X POST http://localhost:3000/api/upload/attachment \
  -F "file=@/tmp/test.png" \
  -v
```

Verify:
- Returns 401 without auth
- Returns 200 with valid file and auth
- Returns attachment metadata with path starting /uploads/attachments/
- File exists on disk with UUID name
  </verify>
  <done>
Upload endpoint accepts files up to 25MB, validates via magic bytes, stores with UUID filename, returns attachment metadata with id, path, originalName, mimeType, sizeBytes, isImage.
  </done>
</task>

</tasks>

<verification>
1. Schema generates valid SQL: `npx drizzle-kit generate`
2. Run migration: `npx drizzle-kit push`
3. File validation works for all supported types
4. Upload endpoint returns proper responses:
   - 401 for unauthenticated
   - 400 for invalid file type
   - 400 for oversized file (with "25MB" in message)
   - 200 with attachment metadata for valid upload
5. Files stored in public/uploads/attachments/ with UUID names
6. Database record created with correct metadata
</verification>

<success_criteria>
- FILE-06: Files over 25MB rejected with clear error message
- FILE-07: File content validated via magic bytes (not just extension)
- Attachment metadata persisted with all required fields
- Upload route follows avatar upload security patterns (auth, UUID names, magic bytes)
</success_criteria>

<output>
After completion, create `.planning/phases/22-file-uploads/22-01-SUMMARY.md`
</output>
