---
phase: 13-audit-logging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/audit-logger.ts
  - src/lib/auth.ts
autonomous: true

must_haves:
  truths:
    - "Login success events logged with timestamp, IP, userId"
    - "Login failure events logged with timestamp, IP, email, reason"
    - "Logout events logged with timestamp, userId"
    - "Log files created as JSON lines in /logs directory"
  artifacts:
    - path: "src/lib/audit-logger.ts"
      provides: "Centralized audit logging module"
      exports: ["auditLog", "AuditEventType"]
    - path: "logs/"
      provides: "Audit log directory"
  key_links:
    - from: "src/lib/auth.ts"
      to: "src/lib/audit-logger.ts"
      via: "auditLog calls in auth hooks"
      pattern: "auditLog\\("
---

<objective>
Create audit logger module and integrate with authentication events

Purpose: Establish centralized security event logging infrastructure and capture all login/logout events
Output: Working audit logger writing JSON lines to /logs, auth events being logged
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-audit-logging/13-CONTEXT.md

# Existing auth hook implementation
@src/lib/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit logger module</name>
  <files>src/lib/audit-logger.ts, logs/.gitkeep</files>
  <action>
Create `src/lib/audit-logger.ts` with:

1. Define AuditEventType enum:
   - AUTH_LOGIN_SUCCESS
   - AUTH_LOGIN_FAILURE
   - AUTH_LOGOUT
   - AUTH_PASSWORD_RESET
   - ADMIN_UNLOCK_USER
   - ADMIN_EXPORT_DATA
   - AUTHZ_FAILURE (authorization denial)

2. Define AuditEvent interface:
   ```typescript
   interface AuditEvent {
     timestamp: string;      // ISO 8601
     eventType: AuditEventType;
     userId?: string;        // User performing action (null for failed logins)
     targetId?: string;      // Target of action (e.g., unlocked user)
     organizationId?: string;
     ip?: string;
     userAgent?: string;
     details?: Record<string, unknown>;  // Event-specific context
   }
   ```

3. Create auditLog function:
   - Takes event type + data
   - Constructs AuditEvent with timestamp
   - Gets current date for filename (YYYY-MM-DD.jsonl)
   - Appends JSON line to /logs/{date}.jsonl
   - Uses fs.appendFileSync for atomic writes (single-line JSON)
   - Creates /logs directory if missing
   - Fire-and-forget pattern (don't await, catch and console.error on failure)

4. Create helper functions:
   - `getClientIP(request: Request | Headers): string | undefined` - Extract IP from x-forwarded-for or x-real-ip headers
   - `getUserAgent(request: Request | Headers): string | undefined` - Extract user-agent header

Create `logs/.gitkeep` to track empty directory.

Add `/logs/*.jsonl` to .gitignore if not already present.
  </action>
  <verify>
Run `ls src/lib/audit-logger.ts` to confirm file exists.
Check file exports AuditEventType and auditLog.
  </verify>
  <done>
Audit logger module exists with auditLog function and event types defined.
logs/ directory created with .gitkeep.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add auth event logging to better-auth hooks</name>
  <files>src/lib/auth.ts</files>
  <action>
Modify `src/lib/auth.ts` to log authentication events:

1. Import auditLog and types from audit-logger

2. In the `after` hook for `/sign-in/email`:
   - Extract IP and user-agent from ctx.headers (use helper functions)
   - On successful login: auditLog AUTH_LOGIN_SUCCESS with userId, ip, userAgent
   - On failed login: auditLog AUTH_LOGIN_FAILURE with email (in details), ip, userAgent, reason (from error message if available)

3. Add handler for logout path if not exists:
   - In after hook, check for `/sign-out` path
   - On logout: auditLog AUTH_LOGOUT with userId, ip

4. In the after hook for `/reset-password`:
   - On successful reset: auditLog AUTH_PASSWORD_RESET with userId

Note: Keep existing lockout logic unchanged. Logging is additive.
Note: ctx.headers contains request headers for IP extraction.
  </action>
  <verify>
1. Start dev server: `npm run dev`
2. Attempt login (will fail if no user, but should create log)
3. Check `logs/` directory for today's .jsonl file
4. Verify JSON line contains expected fields
  </verify>
  <done>
Login success/failure events logged to /logs/{date}.jsonl.
Logout events logged.
Password reset events logged.
  </done>
</task>

</tasks>

<verification>
1. Log file created: `ls logs/*.jsonl` shows file for today
2. Log format valid: `cat logs/*.jsonl | jq .` parses without error
3. Auth events present: `grep AUTH logs/*.jsonl` returns matches
4. Required fields: Each line has timestamp, eventType, at least one of userId/details.email
</verification>

<success_criteria>
- Audit logger module exports auditLog function
- Authentication events (login success, login failure, logout) written to JSON lines files
- Log files located in /logs directory with daily naming
- Each log entry contains timestamp, eventType, and relevant context
</success_criteria>

<output>
After completion, create `.planning/phases/13-audit-logging/13-01-SUMMARY.md`
</output>
