---
phase: 13-audit-logging
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/app/api/admin/audit-logs/route.ts
autonomous: true

must_haves:
  truths:
    - "Audit logs queryable via API endpoint"
    - "API supports time range filters (from, to)"
    - "API supports event type filter"
    - "Only org admins/owners can query logs"
    - "Results scoped to requesting user's organization"
  artifacts:
    - path: "src/app/api/admin/audit-logs/route.ts"
      provides: "Read-only audit log query API"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/admin/audit-logs/route.ts"
      to: "logs/*.jsonl"
      via: "file system read"
      pattern: "readFileSync|createReadStream"
---

<objective>
Create read-only API for querying audit logs

Purpose: Enable security investigation by querying audit logs via API
Output: GET /api/admin/audit-logs endpoint with filtering
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-audit-logging/13-CONTEXT.md
@.planning/phases/13-audit-logging/13-01-SUMMARY.md

# Existing admin API pattern
@src/app/api/admin/export/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit log query API</name>
  <files>src/app/api/admin/audit-logs/route.ts</files>
  <action>
Create `src/app/api/admin/audit-logs/route.ts`:

1. GET handler with query parameters:
   - `from`: ISO date string (default: 7 days ago)
   - `to`: ISO date string (default: now)
   - `eventType`: Optional filter for specific event type
   - `limit`: Max results (default: 100, max: 1000)
   - `offset`: Pagination offset (default: 0)

2. Authentication and authorization:
   - Require valid session (same pattern as export route)
   - Require admin or owner role in at least one organization
   - Get user's organization memberships (admin/owner roles)

3. Query logic:
   - Determine date range for file names (YYYY-MM-DD.jsonl)
   - Read relevant log files from /logs directory
   - Parse each JSON line
   - Filter by:
     - organizationId IN user's admin orgs (or userId matches for personal events)
     - timestamp within from/to range
     - eventType matches filter (if provided)
   - Apply limit/offset for pagination
   - Return array of matching events

4. Response format:
   ```typescript
   {
     events: AuditEvent[],
     pagination: {
       total: number,
       limit: number,
       offset: number,
       hasMore: boolean,
     }
   }
   ```

5. Error handling:
   - 401 if not authenticated
   - 403 if not admin/owner in any organization
   - 400 if invalid date format
   - Return empty array if no logs exist (not error)

Note: Scoping rules per CONTEXT.md - "Org admins see their org's events only"
For events without organizationId (like auth failures), show if userId matches current user or targetId is in their org.
  </action>
  <verify>
1. File exists: `ls src/app/api/admin/audit-logs/route.ts`
2. Build passes: `npm run build`
3. Manual test (requires running server with logs):
   - `curl -X GET "http://localhost:3000/api/admin/audit-logs?from=2024-01-01" -H "Cookie: ..."` returns JSON
  </verify>
  <done>
Audit log query API accessible at GET /api/admin/audit-logs with filtering and pagination.
Only admins can access, results scoped to their organizations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add log cleanup utility</name>
  <files>src/lib/audit-logger.ts</files>
  <action>
Add cleanup function to `src/lib/audit-logger.ts`:

1. Create `cleanupOldLogs(retentionDays: number = 90)` function:
   - List all .jsonl files in /logs directory
   - Parse date from filename (YYYY-MM-DD.jsonl)
   - Delete files older than retentionDays
   - Return count of deleted files
   - Log cleanup activity to console (not to audit log to avoid recursion)

2. Export the function for use in cron jobs or manual cleanup

Note: Actual scheduling (cron, etc.) is left to deployment configuration.
The function just performs the cleanup when called.

Usage example in deployment:
- Could be called from a health check endpoint with admin auth
- Could be triggered by external cron hitting an endpoint
- Could be run as a separate script
  </action>
  <verify>
Run `grep -n "cleanupOldLogs" src/lib/audit-logger.ts`
Confirm function is exported.
  </verify>
  <done>
Log cleanup utility function available for 90-day retention enforcement.
  </done>
</task>

</tasks>

<verification>
1. API endpoint exists: `ls src/app/api/admin/audit-logs/route.ts` succeeds
2. Cleanup function exported: `grep "export.*cleanupOldLogs" src/lib/audit-logger.ts` returns match
3. Build passes: `npm run build` completes without errors
4. TypeScript valid: No type errors in new files
</verification>

<success_criteria>
- GET /api/admin/audit-logs returns filtered audit events
- Only admin/owner users can access the endpoint
- Results scoped to user's organization(s)
- Time range and event type filtering works
- Pagination supported with limit/offset
- Cleanup function available for retention enforcement
</success_criteria>

<output>
After completion, create `.planning/phases/13-audit-logging/13-03-SUMMARY.md`
</output>
