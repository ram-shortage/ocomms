---
phase: 10-transport-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/generate-db-certs.sh
  - src/db/index.ts
  - src/app/api/health/route.ts
autonomous: true

must_haves:
  truths:
    - "PostgreSQL accepts SSL connections"
    - "Application connects to database using SSL in production mode"
    - "Health endpoint reports database SSL status"
  artifacts:
    - path: "scripts/generate-db-certs.sh"
      provides: "Self-signed certificate generation for PostgreSQL"
      min_lines: 15
    - path: "src/db/index.ts"
      provides: "Database connection with conditional SSL"
      contains: "ssl:"
    - path: "src/app/api/health/route.ts"
      provides: "Health check with SSL status"
      contains: "ssl_is_used"
  key_links:
    - from: "src/db/index.ts"
      to: "postgres connection"
      via: "ssl: 'require' option"
      pattern: "ssl.*require"
    - from: "src/app/api/health/route.ts"
      to: "src/db/index.ts"
      via: "db.execute with ssl_is_used()"
      pattern: "ssl_is_used"
---

<objective>
Set up PostgreSQL SSL encryption for database connections.

Purpose: Encrypt database traffic to prevent eavesdropping on sensitive data (requirement SEC-05)
Output: Certificate generation script, SSL-enabled database connection, health endpoint reporting SSL status
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-transport-security/10-RESEARCH.md

# Existing files to modify
@src/db/index.ts
@src/app/api/health/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostgreSQL certificate generation script</name>
  <files>scripts/generate-db-certs.sh</files>
  <action>
Create a bash script that generates self-signed certificates for PostgreSQL:

1. Create `scripts/generate-db-certs.sh` with:
   - Accept optional cert directory argument (default: ./certs/postgres)
   - Create directory if it doesn't exist
   - Generate self-signed cert using openssl with:
     - Subject CN=postgres
     - 365 day validity
     - No password (-nodes)
   - Set permissions: 600 for key, 644 for cert
   - If running as root, chown to postgres user (uid 70 in alpine)
   - Echo success message

2. Make the script executable

Reference the research document Pattern 3 and Code Examples section for the exact openssl command.
  </action>
  <verify>
Run: `bash scripts/generate-db-certs.sh ./certs/postgres`
Check: `ls -la ./certs/postgres/` shows server.crt and server.key with correct permissions
  </verify>
  <done>
Script exists, is executable, and successfully generates valid SSL certificates in the target directory
  </done>
</task>

<task type="auto">
  <name>Task 2: Update database connection for SSL</name>
  <files>src/db/index.ts</files>
  <action>
Modify the postgres.js client configuration to use SSL in production:

1. Determine SSL mode based on:
   - If DATABASE_URL contains 'sslmode=' parameter, use that
   - Otherwise, if NODE_ENV === 'production', require SSL
   - In development, no SSL (false)

2. Update postgres() client initialization to pass ssl option:
   - ssl: 'require' for production (accepts self-signed certs within Docker network)
   - ssl: false for development

Do NOT use `rejectUnauthorized: false` - that's for node-postgres, not postgres.js.
postgres.js accepts: false, true, 'require', 'prefer', or tls.connect options.

Keep existing drizzle configuration unchanged.
  </action>
  <verify>
Run: `npm run build` - no TypeScript errors
Code review: SSL configuration is conditional on environment
  </verify>
  <done>
Database connection uses SSL in production mode, continues working without SSL in development
  </done>
</task>

<task type="auto">
  <name>Task 3: Update health endpoint to report SSL status</name>
  <files>src/app/api/health/route.ts</files>
  <action>
Enhance the health endpoint to report database SSL connection status:

1. Replace the simple `SELECT 1` query with `SELECT ssl_is_used() as ssl_enabled`
   - This PostgreSQL function returns true if current connection uses SSL

2. Update response structure to include database object with:
   - connected: true (if query succeeded)
   - ssl: boolean (value from ssl_is_used())

3. Keep existing error handling but update error response to match new structure

The endpoint should return:
```json
{
  "status": "healthy",
  "timestamp": "...",
  "database": {
    "connected": true,
    "ssl": true/false
  }
}
```
  </action>
  <verify>
Run: `curl http://localhost:3000/api/health` (in dev, ssl should be false)
After production deploy with SSL, ssl should be true
  </verify>
  <done>
Health endpoint returns database SSL status, allowing verification of SEC-05 compliance
  </done>
</task>

</tasks>

<verification>
1. Certificate script creates valid certs: `bash scripts/generate-db-certs.sh && openssl x509 -in certs/postgres/server.crt -text -noout | grep Subject`
2. Build succeeds: `npm run build`
3. Health endpoint works in dev: `npm run dev` then `curl localhost:3000/api/health`
</verification>

<success_criteria>
- scripts/generate-db-certs.sh exists, is executable, generates valid certs
- src/db/index.ts conditionally enables SSL based on environment
- src/app/api/health/route.ts reports database SSL status
- All existing functionality continues to work in development
</success_criteria>

<output>
After completion, create `.planning/phases/10-transport-security/10-01-SUMMARY.md`
</output>
