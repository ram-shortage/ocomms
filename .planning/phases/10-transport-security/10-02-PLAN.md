---
phase: 10-transport-security
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - nginx/conf.d/default.conf
  - .env.example
autonomous: true

must_haves:
  truths:
    - "HTTP requests on port 80 redirect to HTTPS on port 443"
    - "Let's Encrypt certificates are automatically obtained and renewed"
    - "HSTS header is present on HTTPS responses"
  artifacts:
    - path: "docker-compose.yml"
      provides: "SSL-enabled container orchestration"
      contains: "jonasal/nginx-certbot"
    - path: "nginx/conf.d/default.conf"
      provides: "HTTPS server block with security headers"
      contains: "ssl_certificate"
    - path: ".env.example"
      provides: "SSL configuration documentation"
      contains: "CERTBOT_EMAIL"
  key_links:
    - from: "docker-compose.yml"
      to: "nginx/conf.d/default.conf"
      via: "volume mount to /etc/nginx/user_conf.d"
      pattern: "user_conf.d"
    - from: "docker-compose.yml"
      to: "certs/postgres"
      via: "volume mount for database SSL"
      pattern: "certs/postgres"
---

<objective>
Configure HTTPS with Let's Encrypt automatic certificate management.

Purpose: Encrypt all HTTP traffic with automatic SSL certificate renewal (requirements SEC-01, SEC-05)
Output: Updated docker-compose with SSL support, nginx HTTPS configuration, environment variable documentation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-transport-security/10-RESEARCH.md

# Existing files to modify
@docker-compose.yml
@nginx/conf.d/default.conf
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update docker-compose.yml for SSL infrastructure</name>
  <files>docker-compose.yml</files>
  <action>
Update docker-compose.yml with SSL support for nginx and PostgreSQL:

**nginx service changes:**
1. Change image from `nginx:1.25-alpine` to `jonasal/nginx-certbot:5-alpine`
2. Add port 443 mapping: `- "443:443"`
3. Add environment variables:
   - CERTBOT_EMAIL=${CERTBOT_EMAIL}
   - STAGING=${CERTBOT_STAGING:-0}
4. Update volume mount path from `/etc/nginx/conf.d` to `/etc/nginx/user_conf.d` (required by docker-nginx-certbot)
5. Add letsencrypt volume: `- letsencrypt:/etc/letsencrypt`

**db service changes:**
1. Add cert volume mount: `- ./certs/postgres:/var/lib/postgresql/certs:ro`
2. Add command to enable SSL:
   ```yaml
   command: >
     -c ssl=on
     -c ssl_cert_file=/var/lib/postgresql/certs/server.crt
     -c ssl_key_file=/var/lib/postgresql/certs/server.key
   ```
3. Remove the `ports: - "5432:5432"` mapping (database should only be accessible within Docker network for security)

**app service changes:**
1. Update DATABASE_URL to include sslmode=require:
   `DATABASE_URL=postgresql://postgres:${DB_PASSWORD}@db:5432/ocomms?sslmode=require`

**volumes section:**
1. Add: `letsencrypt:`

Keep all other configuration (redis, healthchecks, restart policies) unchanged.
  </action>
  <verify>
Run: `docker compose config` - validates compose file syntax
Check: nginx image is jonasal/nginx-certbot, ports include 443, letsencrypt volume exists
  </verify>
  <done>
docker-compose.yml uses docker-nginx-certbot image, exposes port 443, mounts SSL volumes for both nginx and PostgreSQL
  </done>
</task>

<task type="auto">
  <name>Task 2: Update nginx configuration for HTTPS</name>
  <files>nginx/conf.d/default.conf</files>
  <action>
Replace the nginx configuration with HTTPS-enabled version:

**HTTP server block (port 80):**
1. Keep upstream app definition
2. Add ACME challenge location for Let's Encrypt:
   ```nginx
   location /.well-known/acme-challenge/ {
       root /var/www/certbot;
   }
   ```
3. Redirect all other traffic to HTTPS:
   ```nginx
   location / {
       return 301 https://$host$request_uri;
   }
   ```

**HTTPS server block (port 443):**
1. Listen on 443 with ssl
2. Use generic server_name `_` (Let's Encrypt will use CERTBOT_EMAIL domain)
3. SSL certificate paths (managed by certbot):
   - ssl_certificate /etc/letsencrypt/live/${domain}/fullchain.pem;
   - ssl_certificate_key /etc/letsencrypt/live/${domain}/privkey.pem;
   Note: Use nginx variable interpolation or a placeholder that docker-nginx-certbot handles

4. Actually, docker-nginx-certbot handles this differently. Use this pattern instead:
   - ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
   - ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
   The user will need to replace example.com with their domain.

5. Add security headers:
   - Strict-Transport-Security: max-age=3600 initially (1 hour - can increase later)
   - X-Frame-Options: SAMEORIGIN
   - X-Content-Type-Options: nosniff

6. Modern TLS configuration:
   - ssl_protocols TLSv1.2 TLSv1.3;
   - ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
   - ssl_prefer_server_ciphers off;

7. Copy existing proxy_pass and WebSocket locations from HTTP block

Add a comment at the top noting user must replace example.com with their domain.
  </action>
  <verify>
Run: `nginx -t -c /path/to/conf` (or docker-based syntax check)
Manual review: HTTPS block includes security headers, ACME challenge location exists
  </verify>
  <done>
nginx config redirects HTTP to HTTPS, serves HTTPS with Let's Encrypt certs, includes HSTS and security headers
  </done>
</task>

<task type="auto">
  <name>Task 3: Update .env.example with SSL variables</name>
  <files>.env.example</files>
  <action>
Add SSL-related environment variables to .env.example:

1. Add section header comment: `# SSL/TLS (production)`

2. Add Let's Encrypt variables:
   - CERTBOT_EMAIL=admin@your-domain.com
   - CERTBOT_STAGING=1 (comment: Set to 0 for production after testing)

3. Update DATABASE_URL to show sslmode option:
   - Change to: `DATABASE_URL=postgresql://postgres:changeme@db:5432/ocomms?sslmode=require`
   - Add comment: sslmode=require for production SSL

4. Update APP_URL examples to show HTTPS:
   - APP_URL=https://your-domain.com
   - NEXT_PUBLIC_APP_URL=https://your-domain.com
   - BETTER_AUTH_URL=https://your-domain.com

5. Add comment noting localhost dev vs production:
   - Keep localhost values for development
   - Comment shows production values with HTTPS

Keep existing sections (SMTP, Redis) unchanged.
  </action>
  <verify>
Read .env.example and verify:
- CERTBOT_EMAIL variable exists
- DATABASE_URL shows sslmode=require option
- APP_URL examples use HTTPS
  </verify>
  <done>
.env.example documents all SSL-related configuration needed for production deployment
  </done>
</task>

</tasks>

<verification>
1. Docker compose validates: `docker compose config > /dev/null && echo "Valid"`
2. Nginx config structure: Contains `listen 443 ssl`, `ssl_certificate`, `Strict-Transport-Security`
3. Environment documented: .env.example contains CERTBOT_EMAIL and sslmode guidance
</verification>

<success_criteria>
- docker-compose.yml uses docker-nginx-certbot:5-alpine image
- nginx listens on both 80 and 443, redirects HTTP to HTTPS
- PostgreSQL configured to accept SSL connections
- .env.example documents CERTBOT_EMAIL, CERTBOT_STAGING, and production URLs
- HSTS header configured (1 hour initial max-age)
</success_criteria>

<output>
After completion, create `.planning/phases/10-transport-security/10-02-SUMMARY.md`
</output>
