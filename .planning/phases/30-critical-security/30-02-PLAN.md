---
phase: 30-critical-security
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/security/session-store.ts
  - src/middleware.ts
  - src/app/api/sessions/route.ts
  - src/app/api/sessions/revoke/route.ts
  - src/lib/auth.ts
autonomous: true

must_haves:
  truths:
    - "Session revocation takes effect on next API request"
    - "User can view list of active sessions with device details"
    - "User can revoke individual sessions or all sessions"
    - "Password change triggers revocation of all other sessions"
  artifacts:
    - path: "src/lib/security/session-store.ts"
      provides: "Redis-backed session validation with user indexing"
      exports: ["validateSession", "addUserSession", "removeUserSession", "revokeAllUserSessions", "getUserSessions"]
    - path: "src/app/api/sessions/route.ts"
      provides: "GET endpoint for listing user sessions"
      exports: ["GET"]
    - path: "src/app/api/sessions/revoke/route.ts"
      provides: "POST endpoint for session revocation"
      exports: ["POST"]
  key_links:
    - from: "src/middleware.ts"
      to: "src/lib/security/session-store.ts"
      via: "validateSession call"
      pattern: "validateSession"
    - from: "src/lib/auth.ts"
      to: "src/lib/security/session-store.ts"
      via: "session indexing on login/logout"
      pattern: "addUserSession|removeUserSession"
---

<objective>
Implement server-side session validation with Redis to enable immediate session revocation.

Purpose: Moves session validation from browser cookie cache to Redis, enabling instant "logout all devices" and session revocation on password change. This is critical for security incident response.

Output: Redis session store with user-to-session indexing, session management APIs, and middleware integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/30-critical-security/30-RESEARCH.md
@.planning/phases/30-critical-security/30-CONTEXT.md
@src/server/redis.ts
@src/middleware.ts
@src/lib/auth.ts
@src/db/schema/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Redis session store with user indexing</name>
  <files>src/lib/security/session-store.ts</files>
  <action>
1. Create `src/lib/security/session-store.ts`:
   - Import createRedisClient from '@/server/redis'
   - Create singleton Redis client (lazy initialized)

2. Implement session-to-user index using Redis SETs:
   ```typescript
   // Key patterns:
   // sess:valid:{sessionId} -> "1" with TTL (marks session as valid)
   // user:{userId}:sessions -> SET of sessionIds
   ```

3. Export functions:

   `addUserSession(userId: string, sessionId: string, ttlSeconds: number)`:
   - SETEX sess:valid:{sessionId} ttlSeconds "1"
   - SADD user:{userId}:sessions sessionId

   `removeUserSession(userId: string, sessionId: string)`:
   - DEL sess:valid:{sessionId}
   - SREM user:{userId}:sessions sessionId

   `revokeAllUserSessions(userId: string, exceptSessionId?: string)`:
   - SMEMBERS user:{userId}:sessions
   - For each sessionId (except exceptSessionId): DEL sess:valid:{sessionId}
   - DEL user:{userId}:sessions (clear the set)
   - If exceptSessionId: SADD back to set

   `validateSession(sessionId: string)`:
   - EXISTS sess:valid:{sessionId}
   - Returns boolean

   `getUserSessions(userId: string)`:
   - SMEMBERS user:{userId}:sessions
   - Returns array of sessionIds

4. Use pipeline/multi for atomic operations where multiple commands needed.

Important: TTL should match better-auth session expiry (7 days = 604800 seconds).
  </action>
  <verify>
    - Unit test or manual verification of Redis operations
    - `npm run build` compiles without errors
  </verify>
  <done>
    - Session store functions exported and working
    - User-to-session index maintained in Redis SETs
    - TTL applied to session validity keys
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate session store with auth hooks and middleware</name>
  <files>
    src/lib/auth.ts
    src/middleware.ts
  </files>
  <action>
1. Update `src/lib/auth.ts`:
   - Import { addUserSession, removeUserSession, revokeAllUserSessions } from '@/lib/security/session-store'

   In the 'after' hook for successful login (where loginFailed is false):
   - Get sessionId from better-auth response (check ctx.context.session or response body)
   - Call addUserSession(userId, sessionId, 7 * 24 * 60 * 60) // 7 days

   In the 'after' hook for logout ('/sign-out'):
   - Get userId and sessionId from ctx.context.session
   - Call removeUserSession(userId, sessionId)

   In the 'after' hook for password reset ('/reset-password'):
   - After successful reset, call revokeAllUserSessions(userId)
   - This invalidates all sessions when password changes

   Add new hook for '/change-password' path:
   - On success, call revokeAllUserSessions(userId, currentSessionId)
   - Keep current session active, revoke others

2. Update `src/middleware.ts`:
   - Import { validateSession } from '@/lib/security/session-store'
   - REMOVE the _session_validated cookie caching logic (lines 32-42)
   - After getting session from /api/auth/get-session, also check:
     ```typescript
     const isValid = await validateSession(session.session.id)
     if (!isValid) {
       // Session revoked - redirect to login
       const response = NextResponse.redirect(new URL('/login', request.url))
       response.cookies.delete('better-auth.session_token')
       return response
     }
     ```
   - This double-check ensures revoked sessions fail immediately

Note: The session.session.id comes from better-auth's session response structure.
  </action>
  <verify>
    - `npm run build` completes
    - Login creates Redis session entry
    - Logout removes Redis session entry
    - After revoking, next request redirects to login
  </verify>
  <done>
    - Login adds session to Redis index
    - Logout removes session from Redis index
    - Password change/reset revokes all other sessions
    - Middleware validates against Redis on each request
  </done>
</task>

<task type="auto">
  <name>Task 3: Add session management API endpoints</name>
  <files>
    src/app/api/sessions/route.ts
    src/app/api/sessions/revoke/route.ts
  </files>
  <action>
1. Create `src/app/api/sessions/route.ts` (GET - list sessions):
   - Authenticate user via auth.api.getSession
   - Get sessionIds from getUserSessions(userId)
   - For each sessionId, query database for session details:
     ```typescript
     // Query sessions table for metadata
     const sessionData = await db.query.session.findFirst({
       where: eq(session.id, sessionId),
       columns: {
         id: true,
         ipAddress: true,
         userAgent: true,
         createdAt: true,
         updatedAt: true,
       }
     })
     ```
   - Parse userAgent to extract device/browser info (basic parsing, not a full library)
   - Mark current session with isCurrent: true
   - Return array of sessions with: id, ipAddress, device (parsed), browser (parsed), lastActive (updatedAt), isCurrent

   User-agent parsing (simple):
   ```typescript
   function parseUserAgent(ua: string | null) {
     if (!ua) return { device: 'Unknown', browser: 'Unknown' }
     const browser = ua.includes('Chrome') ? 'Chrome' :
                     ua.includes('Firefox') ? 'Firefox' :
                     ua.includes('Safari') ? 'Safari' :
                     ua.includes('Edge') ? 'Edge' : 'Unknown'
     const device = ua.includes('Mobile') ? 'Mobile' :
                    ua.includes('Tablet') ? 'Tablet' : 'Desktop'
     return { device, browser }
   }
   ```

2. Create `src/app/api/sessions/revoke/route.ts` (POST - revoke sessions):
   - Authenticate user
   - Accept body: { sessionId?: string, all?: boolean }
   - If all: true, call revokeAllUserSessions(userId, currentSessionId)
   - If sessionId provided:
     - Verify session belongs to user (check user:userId:sessions SET)
     - Prevent revoking current session (return 400)
     - Call removeUserSession(userId, sessionId)
   - Return { success: true, message: '...' }

Note: Per CONTEXT.md, show brief toast after revocation. The API returns success, client shows toast.
  </action>
  <verify>
    - GET /api/sessions returns list of active sessions
    - POST /api/sessions/revoke with { sessionId } revokes specific session
    - POST /api/sessions/revoke with { all: true } revokes all except current
    - Cannot revoke current session (returns 400)
  </verify>
  <done>
    - Session list endpoint returns device details
    - Single session revocation works
    - "Logout all devices" revokes all except current
    - Proper error handling and validation
  </done>
</task>

</tasks>

<verification>
1. Login to app
2. GET /api/sessions - should show current session
3. Login from different browser/incognito
4. GET /api/sessions - should show 2 sessions
5. POST /api/sessions/revoke with { sessionId } for other session
6. In other browser, next action should redirect to login
7. Test "logout all" - should keep current session only
8. Test password change - all other sessions should be revoked
</verification>

<success_criteria>
- Session validation happens via Redis, not cookie cache
- Revoked sessions fail on next API request
- Session list shows device/browser details
- Single session revocation works
- "Logout all devices" works (keeps current)
- Password change revokes all other sessions
</success_criteria>

<output>
After completion, create `.planning/phases/30-critical-security/30-02-SUMMARY.md`
</output>
