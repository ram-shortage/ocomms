---
phase: 18-push-notifications
plan: 04
type: execute
wave: 3
depends_on: ["18-02"]
files_modified:
  - src/lib/push/use-push-subscription.ts
  - src/lib/push/index.ts
  - src/components/push/PushPermissionPrompt.tsx
  - src/components/push/PushSettingsPanel.tsx
  - src/components/push/index.ts
autonomous: true

must_haves:
  truths:
    - "User sees in-app prompt before browser permission request (double-permission)"
    - "User can enable push notifications from the prompt"
    - "User can see their current push subscription status"
    - "User can access per-channel notification settings"
  artifacts:
    - path: "src/lib/push/use-push-subscription.ts"
      provides: "Push subscription management hook"
      exports: ["usePushSubscription"]
    - path: "src/components/push/PushPermissionPrompt.tsx"
      provides: "Double-permission UI prompt"
      exports: ["PushPermissionPrompt"]
    - path: "src/components/push/PushSettingsPanel.tsx"
      provides: "Push settings management"
      exports: ["PushSettingsPanel"]
  key_links:
    - from: "src/lib/push/use-push-subscription.ts"
      to: "PushManager.subscribe"
      via: "navigator.serviceWorker.ready"
      pattern: "pushManager\\.subscribe"
    - from: "src/components/push/PushPermissionPrompt.tsx"
      to: "src/lib/push/use-push-subscription.ts"
      via: "usePushSubscription hook"
      pattern: "usePushSubscription"
---

<objective>
Create UI components for push notification permission and settings.

Purpose: Enable users to opt-in to push notifications using the double-permission pattern (in-app prompt first, then browser permission), and manage their notification preferences.

Output: Push subscription hook, permission prompt component, and settings panel.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-push-notifications/18-RESEARCH.md
@.planning/phases/18-push-notifications/18-02-SUMMARY.md
@src/components/pwa/InstallPrompt.tsx
@src/lib/pwa/use-install-prompt.ts
@src/db/schema/channel-notification-settings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Push subscription hook</name>
  <files>
    - src/lib/push/use-push-subscription.ts
    - src/lib/push/index.ts
  </files>
  <action>
Create client-side hook for push subscription management:

1. Create `src/lib/push/use-push-subscription.ts`:
```typescript
"use client";

import { useState, useEffect, useCallback } from "react";

type PushPermissionState = "prompt" | "granted" | "denied" | "unsupported";

interface UsePushSubscriptionReturn {
  /** Current permission state */
  permissionState: PushPermissionState;
  /** Whether user is currently subscribed */
  isSubscribed: boolean;
  /** Whether a subscription operation is in progress */
  isLoading: boolean;
  /** Request permission and subscribe */
  subscribe: () => Promise<boolean>;
  /** Unsubscribe from push */
  unsubscribe: () => Promise<boolean>;
  /** Whether push is supported on this device */
  isSupported: boolean;
  /** Whether this is iOS (requires PWA installation) */
  isIOS: boolean;
  /** Whether running as installed PWA */
  isStandalone: boolean;
}

/**
 * Convert VAPID public key from URL-safe base64 to Uint8Array.
 */
function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, "+")
    .replace(/_/g, "/");
  const rawData = atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

export function usePushSubscription(): UsePushSubscriptionReturn {
  const [permissionState, setPermissionState] = useState<PushPermissionState>("prompt");
  const [isSubscribed, setIsSubscribed] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  // Detect environment
  const isSupported = typeof window !== "undefined" &&
    "serviceWorker" in navigator &&
    "PushManager" in window &&
    "Notification" in window;

  const isIOS = typeof navigator !== "undefined" &&
    /iphone|ipad|ipod/i.test(navigator.userAgent);

  const isStandalone = typeof window !== "undefined" && (
    window.matchMedia("(display-mode: standalone)").matches ||
    ("standalone" in navigator && (navigator as Navigator & { standalone?: boolean }).standalone === true)
  );

  // Check current state on mount
  useEffect(() => {
    if (!isSupported) {
      setPermissionState("unsupported");
      return;
    }

    // Check notification permission
    const permission = Notification.permission;
    if (permission === "denied") {
      setPermissionState("denied");
      return;
    }
    if (permission === "granted") {
      setPermissionState("granted");
    }

    // Check if already subscribed
    navigator.serviceWorker.ready.then((registration) => {
      registration.pushManager.getSubscription().then((subscription) => {
        setIsSubscribed(!!subscription);
      });
    }).catch(() => {
      // Service worker not ready yet
    });
  }, [isSupported]);

  const subscribe = useCallback(async (): Promise<boolean> => {
    if (!isSupported) return false;

    setIsLoading(true);
    try {
      // Request notification permission
      const permission = await Notification.requestPermission();
      setPermissionState(permission as PushPermissionState);

      if (permission !== "granted") {
        return false;
      }

      // Get VAPID public key from server
      const vapidResponse = await fetch("/api/push/vapid-public");
      if (!vapidResponse.ok) {
        console.error("[Push] Failed to get VAPID key");
        return false;
      }
      const { publicKey } = await vapidResponse.json();

      // Get service worker registration
      const registration = await navigator.serviceWorker.ready;

      // Subscribe to push
      const subscription = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: urlBase64ToUint8Array(publicKey),
      });

      // Send subscription to server
      const response = await fetch("/api/push/subscribe", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(subscription.toJSON()),
      });

      if (!response.ok) {
        // Unsubscribe if server storage failed
        await subscription.unsubscribe();
        console.error("[Push] Failed to save subscription to server");
        return false;
      }

      setIsSubscribed(true);
      return true;
    } catch (error) {
      console.error("[Push] Subscribe error:", error);
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [isSupported]);

  const unsubscribe = useCallback(async (): Promise<boolean> => {
    if (!isSupported) return false;

    setIsLoading(true);
    try {
      const registration = await navigator.serviceWorker.ready;
      const subscription = await registration.pushManager.getSubscription();

      if (!subscription) {
        setIsSubscribed(false);
        return true;
      }

      // Remove from server first
      await fetch("/api/push/unsubscribe", {
        method: "DELETE",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ endpoint: subscription.endpoint }),
      });

      // Then unsubscribe locally
      await subscription.unsubscribe();

      setIsSubscribed(false);
      return true;
    } catch (error) {
      console.error("[Push] Unsubscribe error:", error);
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [isSupported]);

  return {
    permissionState,
    isSubscribed,
    isLoading,
    subscribe,
    unsubscribe,
    isSupported,
    isIOS,
    isStandalone,
  };
}
```

2. Update `src/lib/push/index.ts` to export the hook (client-side only):
```typescript
export * from "./vapid";
export * from "./send";
// Note: use-push-subscription.ts is client-only, import directly where needed
```

Key behaviors:
- Detects iOS standalone mode requirement
- Tracks subscription state
- Handles full subscribe/unsubscribe flow
- Exposes loading state for UI
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`.
  </verify>
  <done>
usePushSubscription hook provides complete push management interface.
  </done>
</task>

<task type="auto">
  <name>Task 2: Push permission prompt component</name>
  <files>
    - src/components/push/PushPermissionPrompt.tsx
    - src/components/push/index.ts
  </files>
  <action>
Create double-permission prompt component:

1. Create `src/components/push/PushPermissionPrompt.tsx`:
```typescript
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Bell, BellOff, X } from "lucide-react";
import { usePushSubscription } from "@/lib/push/use-push-subscription";

interface PushPermissionPromptProps {
  /** Called when user dismisses the prompt */
  onDismiss?: () => void;
  /** Called after successful subscription */
  onSubscribed?: () => void;
}

export function PushPermissionPrompt({ onDismiss, onSubscribed }: PushPermissionPromptProps) {
  const {
    permissionState,
    isSubscribed,
    isLoading,
    subscribe,
    isSupported,
    isIOS,
    isStandalone,
  } = usePushSubscription();

  const [dismissed, setDismissed] = useState(false);

  // Don't show if already subscribed, dismissed, or not supported
  if (dismissed || isSubscribed || !isSupported) {
    return null;
  }

  // iOS requires PWA installation first
  if (isIOS && !isStandalone) {
    return null; // IOSInstallGuide handles this case
  }

  // Don't show if permission already denied
  if (permissionState === "denied") {
    return null;
  }

  const handleDismiss = () => {
    setDismissed(true);
    onDismiss?.();
  };

  const handleEnable = async () => {
    const success = await subscribe();
    if (success) {
      onSubscribed?.();
    }
  };

  return (
    <Card className="relative">
      <Button
        variant="ghost"
        size="icon"
        className="absolute right-2 top-2 h-6 w-6"
        onClick={handleDismiss}
        aria-label="Dismiss"
      >
        <X className="h-4 w-4" />
      </Button>
      <CardHeader className="pb-2">
        <div className="flex items-center gap-2">
          <Bell className="h-5 w-5 text-primary" />
          <CardTitle className="text-lg">Enable Notifications?</CardTitle>
        </div>
        <CardDescription>
          Get notified when you receive a direct message or someone mentions you.
        </CardDescription>
      </CardHeader>
      <CardContent className="flex gap-2">
        <Button onClick={handleEnable} disabled={isLoading}>
          {isLoading ? "Enabling..." : "Enable Notifications"}
        </Button>
        <Button variant="ghost" onClick={handleDismiss}>
          Not Now
        </Button>
      </CardContent>
    </Card>
  );
}
```

2. Create `src/components/push/index.ts`:
```typescript
export { PushPermissionPrompt } from "./PushPermissionPrompt";
export { PushSettingsPanel } from "./PushSettingsPanel";
```

This implements the "double-permission pattern" - show a friendly in-app prompt first, only trigger browser permission request when user clicks Enable.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`.
  </verify>
  <done>
PushPermissionPrompt component implements double-permission pattern.
  </done>
</task>

<task type="auto">
  <name>Task 3: Push settings panel</name>
  <files>
    - src/components/push/PushSettingsPanel.tsx
    - src/components/push/index.ts
  </files>
  <action>
Create settings panel for push notification management:

1. Create `src/components/push/PushSettingsPanel.tsx`:
```typescript
"use client";

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Bell, BellOff, AlertTriangle, Smartphone } from "lucide-react";
import { usePushSubscription } from "@/lib/push/use-push-subscription";

interface PushSettingsPanelProps {
  /** Show compact version */
  compact?: boolean;
}

export function PushSettingsPanel({ compact = false }: PushSettingsPanelProps) {
  const {
    permissionState,
    isSubscribed,
    isLoading,
    subscribe,
    unsubscribe,
    isSupported,
    isIOS,
    isStandalone,
  } = usePushSubscription();

  // Not supported at all
  if (!isSupported) {
    return (
      <Card>
        <CardHeader className={compact ? "pb-2" : undefined}>
          <div className="flex items-center gap-2">
            <BellOff className="h-5 w-5 text-muted-foreground" />
            <CardTitle className={compact ? "text-base" : "text-lg"}>
              Push Notifications
            </CardTitle>
          </div>
          <CardDescription>
            Push notifications are not supported in this browser.
          </CardDescription>
        </CardHeader>
      </Card>
    );
  }

  // iOS but not installed as PWA
  if (isIOS && !isStandalone) {
    return (
      <Card>
        <CardHeader className={compact ? "pb-2" : undefined}>
          <div className="flex items-center gap-2">
            <Smartphone className="h-5 w-5 text-muted-foreground" />
            <CardTitle className={compact ? "text-base" : "text-lg"}>
              Push Notifications
            </CardTitle>
          </div>
          <CardDescription>
            To receive push notifications on iOS, first add this app to your Home Screen.
          </CardDescription>
        </CardHeader>
      </Card>
    );
  }

  // Permission denied
  if (permissionState === "denied") {
    return (
      <Card>
        <CardHeader className={compact ? "pb-2" : undefined}>
          <div className="flex items-center gap-2">
            <AlertTriangle className="h-5 w-5 text-destructive" />
            <CardTitle className={compact ? "text-base" : "text-lg"}>
              Push Notifications Blocked
            </CardTitle>
          </div>
          <CardDescription>
            Notifications are blocked. To enable them, click the lock icon in your browser&apos;s address bar and allow notifications.
          </CardDescription>
        </CardHeader>
      </Card>
    );
  }

  const handleToggle = async () => {
    if (isSubscribed) {
      await unsubscribe();
    } else {
      await subscribe();
    }
  };

  return (
    <Card>
      <CardHeader className={compact ? "pb-2" : undefined}>
        <div className="flex items-center gap-2">
          {isSubscribed ? (
            <Bell className="h-5 w-5 text-primary" />
          ) : (
            <BellOff className="h-5 w-5 text-muted-foreground" />
          )}
          <CardTitle className={compact ? "text-base" : "text-lg"}>
            Push Notifications
          </CardTitle>
        </div>
        <CardDescription>
          {isSubscribed
            ? "You will receive notifications for DMs and mentions."
            : "Enable to receive notifications for DMs and mentions."}
        </CardDescription>
      </CardHeader>
      <CardContent>
        <Button
          variant={isSubscribed ? "outline" : "default"}
          onClick={handleToggle}
          disabled={isLoading}
        >
          {isLoading
            ? "..."
            : isSubscribed
              ? "Disable Notifications"
              : "Enable Notifications"}
        </Button>
      </CardContent>
    </Card>
  );
}
```

2. Ensure `src/components/push/index.ts` exports both components (already done in Task 2).

The settings panel handles all edge cases:
- Browser doesn't support push
- iOS without PWA installation
- Permission previously denied
- Currently subscribed / not subscribed
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`.
  </verify>
  <done>
PushSettingsPanel component shows current status and allows toggle.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. PushPermissionPrompt shows only when appropriate (not denied, not subscribed)
3. PushSettingsPanel handles all edge cases (iOS, denied, unsupported)
4. Subscribe/unsubscribe flow works end-to-end
</verification>

<success_criteria>
- Double-permission pattern implemented (PUSH-02)
- Hook provides subscription state and controls
- Components handle iOS requirements
- Components handle denied permission state
- User can enable/disable notifications from settings
</success_criteria>

<output>
After completion, create `.planning/phases/18-push-notifications/18-04-SUMMARY.md`
</output>
