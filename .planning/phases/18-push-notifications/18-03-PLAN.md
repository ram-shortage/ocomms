---
phase: 18-push-notifications
plan: 03
type: execute
wave: 3
depends_on: ["18-01", "18-02"]
files_modified:
  - src/lib/push/send.ts
  - src/lib/push/index.ts
  - src/server/socket/handlers/notification.ts
  - src/server/socket/handlers/message.ts
autonomous: true

must_haves:
  truths:
    - "Server can send push notifications to a user's devices"
    - "User receives push when mentioned in a channel"
    - "User receives push when they receive a DM"
    - "Users do not receive push for their own messages"
    - "Expired subscriptions are automatically cleaned up"
  artifacts:
    - path: "src/lib/push/send.ts"
      provides: "Push notification delivery"
      exports: ["sendPushToUser", "PushPayload"]
    - path: "src/server/socket/handlers/notification.ts"
      provides: "Push trigger for mentions"
      contains: "sendPushToUser"
    - path: "src/server/socket/handlers/message.ts"
      provides: "Push trigger for DMs"
      contains: "sendPushToUser"
  key_links:
    - from: "src/lib/push/send.ts"
      to: "web-push"
      via: "webpush.sendNotification"
      pattern: "webpush\\.sendNotification"
    - from: "src/server/socket/handlers/notification.ts"
      to: "src/lib/push/send.ts"
      via: "import sendPushToUser"
      pattern: "sendPushToUser"
    - from: "src/server/socket/handlers/message.ts"
      to: "src/lib/push/send.ts"
      via: "import sendPushToUser"
      pattern: "sendPushToUser"
---

<objective>
Implement push notification delivery for mentions and direct messages.

Purpose: Users should receive push notifications when someone mentions them or sends them a DM, enabling real-time awareness even when the app tab is not active.

Output: Push sending utility and integration with notification and message handlers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-push-notifications/18-RESEARCH.md
@.planning/phases/18-push-notifications/18-01-SUMMARY.md
@.planning/phases/18-push-notifications/18-02-SUMMARY.md
@src/server/socket/handlers/notification.ts
@src/server/socket/handlers/message.ts
@src/lib/push/vapid.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Push notification sending utility</name>
  <files>
    - src/lib/push/send.ts
    - src/lib/push/index.ts
  </files>
  <action>
Create push notification delivery module:

1. Create `src/lib/push/send.ts`:
```typescript
import webpush from "web-push";
import { db } from "@/db";
import { pushSubscriptions } from "@/db/schema";
import { eq } from "drizzle-orm";
import { isVapidConfigured } from "./vapid";

export interface PushPayload {
  title: string;
  body: string;
  icon?: string;
  data: {
    url: string;
    tag: string;
    type: "dm" | "mention" | "channel" | "here";
    messageId?: string;
  };
}

/**
 * Send push notification to all of a user's subscribed devices.
 * Handles expired subscriptions by removing them automatically.
 *
 * @returns Object with sent count and failed count
 */
export async function sendPushToUser(
  userId: string,
  payload: PushPayload
): Promise<{ sent: number; failed: number; removed: number }> {
  // Check if push is configured
  if (!isVapidConfigured()) {
    return { sent: 0, failed: 0, removed: 0 };
  }

  // Get all subscriptions for user
  const subscriptions = await db.query.pushSubscriptions.findMany({
    where: eq(pushSubscriptions.userId, userId),
  });

  if (subscriptions.length === 0) {
    return { sent: 0, failed: 0, removed: 0 };
  }

  let sent = 0;
  let failed = 0;
  let removed = 0;

  // Send to all devices
  await Promise.all(
    subscriptions.map(async (sub) => {
      try {
        await webpush.sendNotification(
          {
            endpoint: sub.endpoint,
            keys: { p256dh: sub.p256dh, auth: sub.auth },
          },
          JSON.stringify(payload),
          { TTL: 60 * 60 * 24 } // 24 hours
        );
        sent++;
      } catch (error: unknown) {
        const pushError = error as { statusCode?: number };

        // 410 Gone or 404 = subscription expired, remove it
        if (pushError.statusCode === 410 || pushError.statusCode === 404) {
          await db.delete(pushSubscriptions)
            .where(eq(pushSubscriptions.id, sub.id));
          removed++;
          console.log(`[Push] Removed expired subscription ${sub.id} for user ${userId}`);
        } else {
          failed++;
          console.error(`[Push] Failed to send to ${sub.endpoint}:`, error);
        }
      }
    })
  );

  if (sent > 0) {
    console.log(`[Push] Sent ${sent} notification(s) to user ${userId}`);
  }

  return { sent, failed, removed };
}
```

2. Update `src/lib/push/index.ts` to export:
```typescript
export * from "./vapid";
export * from "./send";
```

Key behaviors:
- Gracefully no-op if VAPID not configured
- Sends to ALL of user's devices (multi-device support)
- Auto-removes expired subscriptions (410/404 responses)
- Returns statistics for logging
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`.
  </verify>
  <done>
sendPushToUser function exists, handles errors gracefully, removes expired subscriptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate push with mention notifications</name>
  <files>
    - src/server/socket/handlers/notification.ts
  </files>
  <action>
Extend notification handler to send push for mentions:

1. Add import at top:
```typescript
import { sendPushToUser, type PushPayload } from "@/lib/push";
```

2. After the socket emit loop in `createNotifications`, add push delivery:

```typescript
// After: io.to(getRoomName.user(notification.userId)).emit("notification:new", notificationPayload);

// Inside the for loop, after emitting to socket, send push notification
// Only send push if user is not currently connected (push is for background)
// For now, always send push - user's device will deduplicate if app is open

// Build push payload
const pushPayload: PushPayload = {
  title: actor?.name
    ? `${actor.name} mentioned you`
    : "New mention",
  body: notification.content,
  data: {
    url: notification.channelId && channelSlug
      ? `/workspace/${workspaceId}/channels/${channelSlug}`
      : notification.conversationId
        ? `/workspace/${workspaceId}/dm/${notification.conversationId}`
        : "/",
    tag: notification.channelId
      ? `channel:${notification.channelId}`
      : `dm:${notification.conversationId}`,
    type: notification.type as "mention" | "channel" | "here",
    messageId: notification.messageId ?? undefined,
  },
};

// Send push (fire and forget - don't block socket emit)
sendPushToUser(notification.userId, pushPayload).catch((err) => {
  console.error("[Notification] Error sending push:", err);
});
```

Note: The workspaceId is already available in the function params. For DM conversations, we need to build the URL differently. The channelSlug is already fetched earlier in the function.

Move the push sending inside the for loop that iterates over insertedNotifications, right after the socket emit.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`. Create a mention in a channel with a second user who has push subscription - they should receive a push notification.
  </verify>
  <done>
Mention notifications trigger push delivery to mentioned users.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add push for direct messages</name>
  <files>
    - src/server/socket/handlers/message.ts
  </files>
  <action>
Extend message handler to send push for DMs:

1. Add imports at top:
```typescript
import { sendPushToUser, type PushPayload } from "@/lib/push";
import { conversationParticipants, conversations } from "@/db/schema";
```

2. In `handleSendMessage`, after the existing notification logic (after line ~180), add DM push handling:

```typescript
// Send push notification for DMs (after the unread notification block)
if (targetType === "dm") {
  // Get all conversation participants except sender
  const participants = await db
    .select({ userId: conversationParticipants.userId })
    .from(conversationParticipants)
    .where(eq(conversationParticipants.conversationId, targetId));

  // Get conversation's workspace for URL building
  const [convData] = await db
    .select({ organizationId: conversations.organizationId })
    .from(conversations)
    .where(eq(conversations.id, targetId))
    .limit(1);

  const workspaceId = convData?.organizationId;

  for (const participant of participants) {
    // Don't notify sender of their own message
    if (participant.userId === userId) continue;

    const pushPayload: PushPayload = {
      title: author?.name
        ? `Message from ${author.name}`
        : "New direct message",
      body: newMessage.content.slice(0, 100),
      data: {
        url: workspaceId
          ? `/workspace/${workspaceId}/dm/${targetId}`
          : `/`,
        tag: `dm:${targetId}`,
        type: "dm",
        messageId: newMessage.id,
      },
    };

    // Fire and forget - don't block message handling
    sendPushToUser(participant.userId, pushPayload).catch((err) => {
      console.error("[Message] Error sending DM push:", err);
    });
  }
}
```

This sends push to all DM participants except the sender. The tag `dm:${conversationId}` ensures notifications for the same conversation replace each other (no spam).
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`. Send a DM to a user who has push subscription - they should receive a push notification with the message preview.
  </verify>
  <done>
DM messages trigger push delivery to recipients (not sender).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Mention in channel triggers push to mentioned user
3. DM message triggers push to recipient
4. Sender does not receive push for their own messages
5. Expired subscriptions are removed automatically
</verification>

<success_criteria>
- Push notifications sent for @mentions (PUSH-04)
- Push notifications sent for DMs (PUSH-03)
- Notification includes URL for deep linking (PUSH-05 prep)
- Expired subscriptions cleaned up automatically
- Push delivery is non-blocking (fire and forget)
</success_criteria>

<output>
After completion, create `.planning/phases/18-push-notifications/18-03-SUMMARY.md`
</output>
