---
phase: 18-push-notifications
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/app/api/push/vapid-public/route.ts
  - src/app/api/push/subscribe/route.ts
  - src/app/api/push/unsubscribe/route.ts
autonomous: true

must_haves:
  truths:
    - "Client can retrieve VAPID public key from API"
    - "Authenticated user can save push subscription"
    - "Authenticated user can remove push subscription"
    - "Invalid/duplicate subscriptions handled gracefully"
  artifacts:
    - path: "src/app/api/push/vapid-public/route.ts"
      provides: "Public VAPID key endpoint"
      exports: ["GET"]
    - path: "src/app/api/push/subscribe/route.ts"
      provides: "Push subscription storage"
      exports: ["POST"]
    - path: "src/app/api/push/unsubscribe/route.ts"
      provides: "Push subscription removal"
      exports: ["DELETE"]
  key_links:
    - from: "src/app/api/push/subscribe/route.ts"
      to: "pushSubscriptions table"
      via: "db.insert"
      pattern: "db\\.insert\\(pushSubscriptions\\)"
    - from: "src/app/api/push/unsubscribe/route.ts"
      to: "pushSubscriptions table"
      via: "db.delete"
      pattern: "db\\.delete\\(pushSubscriptions\\)"
---

<objective>
Create API routes for push notification subscription management.

Purpose: Enable clients to retrieve the VAPID public key for subscription and to save/remove their push subscriptions. These endpoints are the bridge between browser Push API and server storage.

Output: Three API routes for VAPID key retrieval, subscription creation, and subscription deletion.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-push-notifications/18-RESEARCH.md
@.planning/phases/18-push-notifications/18-01-SUMMARY.md
@src/lib/push/vapid.ts
@src/db/schema/push-subscription.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: VAPID public key endpoint</name>
  <files>
    - src/app/api/push/vapid-public/route.ts
  </files>
  <action>
Create GET endpoint to expose VAPID public key:

```typescript
import { NextResponse } from "next/server";
import { getVapidPublicKey, isVapidConfigured } from "@/lib/push";

export async function GET() {
  if (!isVapidConfigured()) {
    return NextResponse.json(
      { error: "Push notifications not configured" },
      { status: 503 }
    );
  }

  const publicKey = getVapidPublicKey();

  if (!publicKey) {
    return NextResponse.json(
      { error: "VAPID public key not available" },
      { status: 503 }
    );
  }

  return NextResponse.json({ publicKey });
}
```

This endpoint is public (no auth required) since the public key is, well, public. The client needs this key to create a PushSubscription. Returns 503 if push is not configured (missing VAPID keys).
  </action>
  <verify>
Start dev server and test: `curl http://localhost:3000/api/push/vapid-public` returns JSON with publicKey or 503 if not configured.
  </verify>
  <done>
GET /api/push/vapid-public returns VAPID public key or 503 if not configured.
  </done>
</task>

<task type="auto">
  <name>Task 2: Subscribe and unsubscribe endpoints</name>
  <files>
    - src/app/api/push/subscribe/route.ts
    - src/app/api/push/unsubscribe/route.ts
  </files>
  <action>
Create subscription management endpoints:

1. Create `src/app/api/push/subscribe/route.ts`:
```typescript
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { db } from "@/db";
import { pushSubscriptions } from "@/db/schema";
import { eq } from "drizzle-orm";
import { isVapidConfigured } from "@/lib/push";

interface PushSubscriptionJSON {
  endpoint: string;
  keys: {
    p256dh: string;
    auth: string;
  };
}

export async function POST(request: NextRequest) {
  // Verify push is configured
  if (!isVapidConfigured()) {
    return NextResponse.json(
      { error: "Push notifications not configured" },
      { status: 503 }
    );
  }

  // Verify authentication
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const subscription: PushSubscriptionJSON = await request.json();

    // Validate required fields
    if (!subscription.endpoint || !subscription.keys?.p256dh || !subscription.keys?.auth) {
      return NextResponse.json(
        { error: "Invalid subscription format" },
        { status: 400 }
      );
    }

    // Check if subscription already exists (same endpoint)
    const existing = await db.query.pushSubscriptions.findFirst({
      where: eq(pushSubscriptions.endpoint, subscription.endpoint),
    });

    if (existing) {
      // Update if same user, reject if different user
      if (existing.userId !== session.user.id) {
        // Endpoint registered to different user - remove old and add new
        await db.delete(pushSubscriptions)
          .where(eq(pushSubscriptions.endpoint, subscription.endpoint));
      } else {
        // Already registered to this user
        return NextResponse.json({ success: true, message: "Already subscribed" });
      }
    }

    // Get user agent for device identification
    const userAgent = request.headers.get("user-agent") || undefined;

    // Insert subscription
    await db.insert(pushSubscriptions).values({
      userId: session.user.id,
      endpoint: subscription.endpoint,
      p256dh: subscription.keys.p256dh,
      auth: subscription.keys.auth,
      userAgent,
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[Push Subscribe] Error:", error);
    return NextResponse.json(
      { error: "Failed to save subscription" },
      { status: 500 }
    );
  }
}
```

2. Create `src/app/api/push/unsubscribe/route.ts`:
```typescript
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { db } from "@/db";
import { pushSubscriptions } from "@/db/schema";
import { eq, and } from "drizzle-orm";

export async function DELETE(request: NextRequest) {
  // Verify authentication
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const { endpoint } = await request.json();

    if (!endpoint) {
      return NextResponse.json(
        { error: "Endpoint required" },
        { status: 400 }
      );
    }

    // Delete subscription (only if owned by this user)
    const result = await db.delete(pushSubscriptions)
      .where(
        and(
          eq(pushSubscriptions.endpoint, endpoint),
          eq(pushSubscriptions.userId, session.user.id)
        )
      )
      .returning();

    if (result.length === 0) {
      return NextResponse.json(
        { success: true, message: "Subscription not found or already removed" }
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[Push Unsubscribe] Error:", error);
    return NextResponse.json(
      { error: "Failed to remove subscription" },
      { status: 500 }
    );
  }
}
```

Key behaviors:
- Subscribe handles endpoint reuse (same device switching users)
- Unsubscribe only removes user's own subscriptions
- Both return success for idempotent operations
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`. Test with curl (requires auth cookie from browser dev tools):
- POST /api/push/subscribe with subscription JSON returns 200
- DELETE /api/push/unsubscribe with endpoint returns 200
  </verify>
  <done>
Subscribe and unsubscribe endpoints work for authenticated users, handle edge cases gracefully.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. GET /api/push/vapid-public returns public key (or 503 if not configured)
3. POST /api/push/subscribe requires auth and stores subscription
4. DELETE /api/push/unsubscribe requires auth and removes subscription
</verification>

<success_criteria>
- VAPID public key retrievable from API
- Authenticated users can subscribe their browser
- Authenticated users can unsubscribe
- Duplicate subscriptions handled (upsert behavior)
- Unauthorized requests return 401
</success_criteria>

<output>
After completion, create `.planning/phases/18-push-notifications/18-02-SUMMARY.md`
</output>
