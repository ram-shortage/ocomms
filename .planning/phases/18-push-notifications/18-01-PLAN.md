---
phase: 18-push-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/push/vapid.ts
  - src/lib/push/index.ts
  - src/db/schema/push-subscription.ts
  - src/db/schema/index.ts
  - src/app/sw.ts
  - .env.example
autonomous: true

must_haves:
  truths:
    - "VAPID keys can be configured via environment variables"
    - "Push subscriptions can be stored in database"
    - "Service worker handles push events and shows notifications"
    - "Clicking notification navigates to correct URL"
  artifacts:
    - path: "src/lib/push/vapid.ts"
      provides: "VAPID configuration and validation"
      exports: ["configureVapid", "isVapidConfigured", "getVapidPublicKey"]
    - path: "src/db/schema/push-subscription.ts"
      provides: "Push subscription storage"
      exports: ["pushSubscriptions", "pushSubscriptionsRelations"]
    - path: "src/app/sw.ts"
      provides: "Push and notificationclick event handlers"
      contains: "addEventListener.*push"
  key_links:
    - from: "src/app/sw.ts"
      to: "Notification API"
      via: "showNotification in push handler"
      pattern: "showNotification"
    - from: "src/app/sw.ts"
      to: "clients.openWindow"
      via: "notificationclick handler"
      pattern: "clients\\.openWindow"
---

<objective>
Set up the foundational infrastructure for Web Push notifications.

Purpose: Enable the server to send push notifications and the service worker to receive and display them. This is the foundation for all push notification features.

Output: VAPID configuration library, push subscription database schema, and service worker push handlers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-push-notifications/18-RESEARCH.md
@src/app/sw.ts
@src/db/schema/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: VAPID key management library</name>
  <files>
    - src/lib/push/vapid.ts
    - src/lib/push/index.ts
    - .env.example
  </files>
  <action>
Create VAPID key management module:

1. Create `src/lib/push/vapid.ts`:
   - Import `web-push` library
   - Export `configureVapid()`: Reads VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY, VAPID_SUBJECT from env, calls `webpush.setVapidDetails()`. Returns true if configured, false if missing keys (log warning but don't throw).
   - Export `isVapidConfigured()`: Returns boolean indicating if VAPID is set up.
   - Export `getVapidPublicKey()`: Returns NEXT_PUBLIC_VAPID_PUBLIC_KEY for client use.

2. Create `src/lib/push/index.ts` barrel export.

3. Update `.env.example` with VAPID placeholders:
   ```
   # Web Push VAPID keys (generate with: npx web-push generate-vapid-keys)
   VAPID_PUBLIC_KEY=
   VAPID_PRIVATE_KEY=
   VAPID_SUBJECT=mailto:admin@yourdomain.com
   NEXT_PUBLIC_VAPID_PUBLIC_KEY=
   ```

Use `mailto:` format for VAPID_SUBJECT (Safari requires this). Handle gracefully when keys are not configured - push features will be disabled but app continues to work.
  </action>
  <verify>
Run `npm install web-push` if not installed. TypeScript compiles without errors: `npx tsc --noEmit`.
  </verify>
  <done>
VAPID library exists, env example updated, web-push is installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Push subscription database schema</name>
  <files>
    - src/db/schema/push-subscription.ts
    - src/db/schema/index.ts
  </files>
  <action>
Create push subscription schema:

1. Create `src/db/schema/push-subscription.ts`:
   ```typescript
   import { pgTable, text, timestamp, uuid, uniqueIndex } from "drizzle-orm/pg-core";
   import { relations } from "drizzle-orm";
   import { users } from "./auth";

   export const pushSubscriptions = pgTable("push_subscriptions", {
     id: uuid("id").primaryKey().defaultRandom(),
     userId: text("user_id")
       .notNull()
       .references(() => users.id, { onDelete: "cascade" }),
     endpoint: text("endpoint").notNull(),
     p256dh: text("p256dh").notNull(),
     auth: text("auth").notNull(),
     userAgent: text("user_agent"),
     createdAt: timestamp("created_at").notNull().defaultNow(),
   }, (table) => [
     uniqueIndex("push_subscriptions_endpoint_idx").on(table.endpoint),
   ]);

   export const pushSubscriptionsRelations = relations(pushSubscriptions, ({ one }) => ({
     user: one(users, {
       fields: [pushSubscriptions.userId],
       references: [users.id],
     }),
   }));
   ```

2. Add `export * from "./push-subscription";` to `src/db/schema/index.ts`.

The endpoint is the unique identifier (user may have multiple devices). p256dh (~88 chars base64) and auth (~24 chars base64) are the encryption keys from PushSubscription.toJSON().
  </action>
  <verify>
Run `npx drizzle-kit push` to apply schema. Check table exists with `npx drizzle-kit studio`.
  </verify>
  <done>
push_subscriptions table exists in database with proper indexes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Service worker push event handlers</name>
  <files>
    - src/app/sw.ts
  </files>
  <action>
Extend existing service worker with push notification handlers:

Add after `serwist.addEventListeners();`:

```typescript
// Push notification handler
self.addEventListener("push", (event) => {
  if (!event.data) {
    console.log("[SW] Push received but no data");
    return;
  }

  try {
    const data = event.data.json();
    const { title, body, icon, data: notificationData } = data;

    const options: NotificationOptions = {
      body,
      icon: icon || "/icons/icon-192x192.png",
      badge: "/icons/badge-96x96.png",
      data: notificationData,
      tag: notificationData?.tag,
      renotify: true,
    };

    event.waitUntil(
      self.registration.showNotification(title, options)
    );
  } catch (error) {
    console.error("[SW] Error handling push:", error);
  }
});

// Notification click handler - opens specific conversation/channel
self.addEventListener("notificationclick", (event) => {
  event.notification.close();

  const url = event.notification.data?.url || "/";

  event.waitUntil(
    clients.matchAll({ type: "window", includeUncontrolled: true })
      .then((windowClients) => {
        // Check if URL already open in a tab
        for (const client of windowClients) {
          if (client.url.includes(url) && "focus" in client) {
            return client.focus();
          }
        }
        // Open new window if no matching tab
        return clients.openWindow(url);
      })
  );
});
```

The tag option enables notification deduplication (same tag = replace existing). The notificationclick handler checks for existing tabs before opening a new one to avoid tab proliferation.
  </action>
  <verify>
Build the service worker: `npm run build` (with --webpack flag per Phase 15 decisions). Check sw.js in .next/static contains the push event listeners.
  </verify>
  <done>
Service worker handles push events and shows notifications, clicking opens the correct URL.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds (webpack mode for Serwist)
2. `npx tsc --noEmit` passes
3. push_subscriptions table exists in database
4. Service worker includes push and notificationclick handlers
</verification>

<success_criteria>
- web-push library installed
- VAPID configuration module works (logs warning if keys missing, doesn't crash)
- Push subscription schema applied to database
- Service worker handles push events
</success_criteria>

<output>
After completion, create `.planning/phases/18-push-notifications/18-01-SUMMARY.md`
</output>
