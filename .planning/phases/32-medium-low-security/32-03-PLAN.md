---
phase: 32-medium-low-security
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/auth.ts
  - src/lib/logger.ts
  - src/middleware.ts
  - src/app/api/error-handling.ts
autonomous: true

must_haves:
  truths:
    - "Production cookies use __Secure- prefix"
    - "Production logs are JSON structured without stack traces"
    - "Development errors show sanitized messages"
    - "API routes set security headers directly"
  artifacts:
    - path: "src/lib/logger.ts"
      provides: "Pino structured logger"
      exports: ["logger"]
    - path: "src/lib/auth.ts"
      provides: "better-auth with useSecureCookies"
      contains: "useSecureCookies"
  key_links:
    - from: "src/middleware.ts"
      to: "src/lib/logger.ts"
      via: "import for request logging"
      pattern: "logger"
---

<objective>
Configure secure cookie prefixes, structured logging with Pino, and security headers on API routes.

Purpose: Harden cookies (SEC2-11), improve logging (SEC2-12), add direct security headers (SEC2-18), sanitize dev errors (SEC2-19)
Output: Pino logger, better-auth cookie config, error sanitization, security headers middleware
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/32-medium-low-security/32-CONTEXT.md
@.planning/phases/32-medium-low-security/32-RESEARCH.md

@src/lib/auth.ts
@src/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Pino logger and secure cookie prefix</name>
  <files>
    src/lib/logger.ts
    src/lib/auth.ts
  </files>
  <action>
1. Install Pino:
   `npm install pino`
   `npm install -D pino-pretty`

2. Create `src/lib/logger.ts`:
   ```typescript
   import pino from "pino";

   const isDev = process.env.NODE_ENV !== "production";

   export const logger = pino({
     level: process.env.LOG_LEVEL || (isDev ? "debug" : "info"),

     // Use pino-pretty in development for readability
     transport: isDev
       ? {
           target: "pino-pretty",
           options: {
             colorize: true,
             translateTime: "SYS:standard",
             ignore: "pid,hostname",
           },
         }
       : undefined,

     // Production: JSON format, no stack traces
     formatters: {
       level: (label) => ({ level: label }),
     },

     // Redact sensitive data
     redact: {
       paths: ["password", "token", "secret", "authorization", "cookie"],
       censor: "[REDACTED]",
     },

     // In production, don't serialize error stacks
     ...(isDev
       ? {}
       : {
           serializers: {
             err: (err) => ({
               type: err.constructor.name,
               message: err.message,
               // No stack in production
             }),
           },
         }),
   });

   // Create child loggers for different modules
   export const authLogger = logger.child({ module: "auth" });
   export const socketLogger = logger.child({ module: "socket" });
   export const queueLogger = logger.child({ module: "queue" });
   export const apiLogger = logger.child({ module: "api" });
   ```

3. Update `src/lib/auth.ts`:
   a. Add import: `import { authLogger } from "./logger";`

   b. Add `advanced` configuration to betterAuth:
      ```typescript
      export const auth = betterAuth({
        // ... existing config ...
        advanced: {
          useSecureCookies: process.env.NODE_ENV === "production",
          // This forces __Secure- prefix in production
        },
        // ... rest of config ...
      });
      ```

   c. Replace console.log/error with authLogger in hooks:
      - Replace `console.log` with `authLogger.info`
      - Replace `console.error` with `authLogger.error`
      - Add structured context: `authLogger.info({ userId, event: "login_success" }, "User logged in")`

4. Update a few existing console.log statements in auth.ts to use authLogger for demonstration:
   - Login success: `authLogger.info({ userId: existingUser.id }, "User login successful")`
   - Login failure: `authLogger.warn({ email }, "Login attempt failed")`
   - Lockout: `authLogger.warn({ userId: existingUser.id, until: lockedUntil }, "Account locked")`
  </action>
  <verify>
    - In dev: logs are colorized and readable
    - Build succeeds: `npm run build`
    - In production mode (NODE_ENV=production): logs are JSON, no stack traces
    - Check that cookies have __Secure- prefix in production (inspect network tab)
  </verify>
  <done>
    - Pino logger configured with dev/prod modes
    - Sensitive data redacted in logs
    - No stack traces in production logs
    - better-auth uses __Secure- cookie prefix in production
  </done>
</task>

<task type="auto">
  <name>Task 2: Add security headers and error sanitization</name>
  <files>
    src/middleware.ts
    src/app/api/error-handling.ts
  </files>
  <action>
1. Update `src/middleware.ts` to add security headers:
   a. Add import: `import { apiLogger } from "./lib/logger";`

   b. Create a function to add security headers to API responses:
      ```typescript
      function addSecurityHeaders(response: NextResponse): NextResponse {
        // These supplement nginx headers, ensuring they're set even for direct API access
        response.headers.set("X-Content-Type-Options", "nosniff");
        response.headers.set("X-Frame-Options", "DENY");
        response.headers.set("X-XSS-Protection", "1; mode=block");
        response.headers.set("Referrer-Policy", "strict-origin-when-cross-origin");

        // Cache control for API routes
        if (!response.headers.has("Cache-Control")) {
          response.headers.set("Cache-Control", "no-store, max-age=0");
        }

        return response;
      }
      ```

   c. In the middleware function, wrap response returns for /api/* routes:
      ```typescript
      // At the end of middleware, before returning response
      const response = NextResponse.next();
      if (request.nextUrl.pathname.startsWith("/api/")) {
        return addSecurityHeaders(response);
      }
      return response;
      ```

2. Create `src/app/api/error-handling.ts` for centralized error handling:
   ```typescript
   import { NextResponse } from "next/server";
   import { apiLogger } from "@/lib/logger";

   const isDev = process.env.NODE_ENV !== "production";

   /**
    * Sanitize error messages for client response.
    * In development: show detailed errors for debugging
    * In production: show generic messages to prevent info leakage
    */
   export function sanitizeError(error: unknown): {
     message: string;
     status: number;
   } {
     if (error instanceof Error) {
       // Log full error server-side
       apiLogger.error({ err: error }, "API error occurred");

       // Known safe errors that can be shown to users
       const safeErrors = [
         "Unauthorized",
         "Not found",
         "Invalid request",
         "Validation failed",
         "Rate limit exceeded",
       ];

       const isSafeError = safeErrors.some((safe) =>
         error.message.toLowerCase().includes(safe.toLowerCase())
       );

       if (isDev || isSafeError) {
         return { message: error.message, status: 400 };
       }

       // Generic message for production
       return { message: "An error occurred", status: 500 };
     }

     return { message: "An unexpected error occurred", status: 500 };
   }

   /**
    * Create error response with proper headers.
    */
   export function errorResponse(error: unknown): NextResponse {
     const { message, status } = sanitizeError(error);
     return NextResponse.json({ error: message }, { status });
   }
   ```

3. Update 2-3 existing API routes to use errorResponse:
   - Find routes that currently do `catch (error) { return NextResponse.json({ error: ... }) }`
   - Replace with: `catch (error) { return errorResponse(error); }`
   - Example routes: upload, user settings, etc.

4. Add request logging to middleware for API routes:
   ```typescript
   // Log API requests (sampling in production to reduce volume)
   if (request.nextUrl.pathname.startsWith("/api/")) {
     const shouldLog = isDev || Math.random() < 0.1; // 10% sample in prod
     if (shouldLog) {
       apiLogger.info({
         method: request.method,
         path: request.nextUrl.pathname,
         // Don't log query params as they may contain sensitive data
       }, "API request");
     }
   }
   ```
  </action>
  <verify>
    - API response headers include X-Content-Type-Options, X-Frame-Options
    - In dev: error responses show detailed messages
    - In prod (NODE_ENV=production): error responses show "An error occurred"
    - `npm run build` succeeds
    - `npm run lint` passes
  </verify>
  <done>
    - Security headers set directly on API routes
    - Error messages sanitized in production
    - API requests logged with sampling
    - Sensitive data not leaked in error responses
  </done>
</task>

</tasks>

<verification>
1. Check API response headers: `curl -I http://localhost:3000/api/user/storage`
2. Verify X-Content-Type-Options, X-Frame-Options present
3. Trigger API error in dev -> detailed error shown
4. Build with NODE_ENV=production, trigger error -> generic message
5. Check log output format in dev (pretty) vs prod (JSON)
6. `npm run lint` passes
7. `npm run build` succeeds
</verification>

<success_criteria>
- Session cookies use __Secure- prefix in production
- Production logs are JSON structured without stack traces
- Development error messages are sanitized, no implementation details leaked
- API routes set security headers directly (X-Content-Type-Options, X-Frame-Options, etc.)
</success_criteria>

<output>
After completion, create `.planning/phases/32-medium-low-security/32-03-SUMMARY.md`
</output>
