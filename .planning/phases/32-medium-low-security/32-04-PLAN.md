---
phase: 32-medium-low-security
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/index.ts
  - src/server/socket/index.ts
  - src/server/socket/handlers/guest.ts
autonomous: true

must_haves:
  truths:
    - "Socket.IO rejects connections from non-whitelisted origins"
    - "CORS violations are logged with origin details"
    - "Soft-locked guests are disconnected from Socket.IO"
    - "Disconnected guests receive notification before disconnect"
  artifacts:
    - path: "src/server/index.ts"
      provides: "Socket.IO CORS whitelist configuration"
      contains: "ALLOWED_ORIGINS"
    - path: "src/server/socket/handlers/guest.ts"
      provides: "Guest disconnect handler"
      exports: ["disconnectSoftLockedGuest"]
  key_links:
    - from: "src/server/index.ts"
      to: "ALLOWED_ORIGINS env var"
      via: "origin validation function"
      pattern: "origin.*callback"
---

<objective>
Configure Socket.IO CORS origin whitelist with violation logging and implement soft-locked guest disconnection.

Purpose: Validate Socket.IO origins (SEC2-13) and disconnect soft-locked guests (SEC2-16)
Output: CORS whitelist config, violation logging, guest disconnect handler
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/32-medium-low-security/32-CONTEXT.md
@.planning/phases/32-medium-low-security/32-RESEARCH.md

@src/server/index.ts
@src/server/socket/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Socket.IO CORS whitelist with logging</name>
  <files>
    src/server/index.ts
  </files>
  <action>
1. Add import at top of file:
   ```typescript
   import { socketLogger } from "@/lib/logger";
   ```
   (If logger doesn't exist yet, use console.warn for now)

2. Replace the static CORS origin with a validation function:
   ```typescript
   // Parse allowed origins from environment variable
   const getAllowedOrigins = (): string[] => {
     const envOrigins = process.env.ALLOWED_ORIGINS;
     if (envOrigins) {
       return envOrigins.split(",").map(o => o.trim()).filter(Boolean);
     }
     // Fallback: use NEXT_PUBLIC_APP_URL or default
     return [process.env.NEXT_PUBLIC_APP_URL || `http://${hostname}:${port}`];
   };

   const allowedOrigins = getAllowedOrigins();
   console.log(`[Socket.IO] Allowed origins: ${allowedOrigins.join(", ")}`);
   ```

3. Update Socket.IO server creation with origin validation function:
   ```typescript
   const io = new SocketServer<ClientToServerEvents, ServerToClientEvents, Record<string, never>, SocketData>(httpServer, {
     cors: {
       origin: (origin, callback) => {
         // Allow requests with no origin (e.g., same-origin, mobile apps)
         if (!origin) {
           callback(null, true);
           return;
         }

         if (allowedOrigins.includes(origin)) {
           callback(null, true);
         } else {
           // Log CORS violation
           console.warn(`[Socket.IO] CORS violation: origin "${origin}" not in whitelist [${allowedOrigins.join(", ")}]`);
           callback(new Error("Origin not allowed"), false);
         }
       },
       credentials: true,
     },
     connectionStateRecovery: {
       maxDisconnectionDuration: 2 * 60 * 1000,
       skipMiddlewares: true,
     },
   });
   ```

4. Add documentation comment explaining ALLOWED_ORIGINS env var:
   ```typescript
   /**
    * Socket.IO CORS Configuration
    *
    * Set ALLOWED_ORIGINS env var as comma-separated list of allowed origins:
    * ALLOWED_ORIGINS=https://app.example.com,https://admin.example.com
    *
    * Falls back to NEXT_PUBLIC_APP_URL if ALLOWED_ORIGINS not set.
    */
   ```
  </action>
  <verify>
    - Start server and connect from allowed origin -> succeeds
    - Connect from unauthorized origin (different port/domain) -> rejected
    - Check server logs for CORS violation message
    - `npm run build` succeeds
  </verify>
  <done>
    - Socket.IO validates origin against whitelist
    - CORS violations logged with origin details
    - ALLOWED_ORIGINS env var documented
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement soft-locked guest disconnection</name>
  <files>
    src/server/socket/handlers/guest.ts
    src/server/socket/index.ts
  </files>
  <action>
1. Create `src/server/socket/handlers/guest.ts`:
   ```typescript
   import type { Server } from "socket.io";
   import type { ClientToServerEvents, ServerToClientEvents, SocketData } from "@/lib/socket-events";

   type SocketIOServer = Server<ClientToServerEvents, ServerToClientEvents, Record<string, never>, SocketData>;

   /**
    * Disconnect a soft-locked guest from all Socket.IO connections.
    * Sends a notification to the guest before disconnecting.
    *
    * @param io - Socket.IO server instance
    * @param userId - The guest user ID to disconnect
    * @param reason - Reason for disconnection (shown to user)
    */
   export async function disconnectSoftLockedGuest(
     io: SocketIOServer,
     userId: string,
     reason: string = "Your guest access has been revoked"
   ): Promise<void> {
     // Find all sockets for this user
     const sockets = await io.fetchSockets();
     const userSockets = sockets.filter(socket => socket.data.userId === userId);

     if (userSockets.length === 0) {
       console.log(`[Socket.IO] Guest ${userId} has no active connections`);
       return;
     }

     console.log(`[Socket.IO] Disconnecting soft-locked guest ${userId} (${userSockets.length} connections)`);

     // Send notification to each socket before disconnecting
     for (const socket of userSockets) {
       // Emit notification so client can show message
       socket.emit("guest:locked", {
         reason,
         message: "You have been disconnected. Please contact a workspace admin.",
       });

       // Small delay to ensure message is sent before disconnect
       await new Promise(resolve => setTimeout(resolve, 100));

       // Disconnect the socket
       socket.disconnect(true);
     }

     console.log(`[Socket.IO] Guest ${userId} disconnected successfully`);
   }

   /**
    * Get module-level IO reference for use in API routes.
    * Set during setupSocketHandlers.
    */
   let ioInstance: SocketIOServer | null = null;

   export function setIOInstance(io: SocketIOServer): void {
     ioInstance = io;
   }

   export function getIOInstance(): SocketIOServer | null {
     return ioInstance;
   }
   ```

2. Update `src/server/socket/index.ts`:
   a. Add import:
      ```typescript
      import { setIOInstance } from "./handlers/guest";
      ```

   b. In setupSocketHandlers, after io is available:
      ```typescript
      export function setupSocketHandlers(io: SocketIOServer, redis?: Redis | null) {
        // Store IO instance for guest disconnect
        setIOInstance(io);

        // ... rest of existing code ...
      }
      ```

3. Add socket event type for guest:locked in `src/lib/socket-events.ts`:
   ```typescript
   // In ServerToClientEvents interface:
   "guest:locked": (data: { reason: string; message: string }) => void;
   ```

4. Create API endpoint to trigger guest disconnect (for use by admin actions):
   Create `src/app/api/admin/guest/[guestId]/disconnect/route.ts`:
   ```typescript
   import { NextResponse } from "next/server";
   import { auth } from "@/lib/auth";
   import { headers } from "next/headers";
   import { db } from "@/db";
   import { member, guest } from "@/db/schema";
   import { eq, and } from "drizzle-orm";
   import { getIOInstance, disconnectSoftLockedGuest } from "@/server/socket/handlers/guest";

   export async function POST(
     request: Request,
     { params }: { params: Promise<{ guestId: string }> }
   ) {
     const { guestId } = await params;
     const session = await auth.api.getSession({ headers: await headers() });

     if (!session?.user) {
       return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
     }

     // Verify caller is admin of guest's workspace
     const guestRecord = await db.query.guest.findFirst({
       where: eq(guest.id, guestId),
     });

     if (!guestRecord) {
       return NextResponse.json({ error: "Guest not found" }, { status: 404 });
     }

     // Check if caller is admin in this org
     const callerMember = await db.query.member.findFirst({
       where: and(
         eq(member.userId, session.user.id),
         eq(member.organizationId, guestRecord.organizationId)
       ),
     });

     if (!callerMember || callerMember.role !== "admin") {
       return NextResponse.json({ error: "Not authorized" }, { status: 403 });
     }

     // Disconnect the guest
     const io = getIOInstance();
     if (io) {
       await disconnectSoftLockedGuest(io, guestRecord.userId, "Your guest access has been revoked by an admin");
     }

     return NextResponse.json({ success: true });
   }
   ```

5. Handle guest:locked event in client socket:
   Update the Socket.IO client listener (likely in a context or hook):
   ```typescript
   socket.on("guest:locked", (data) => {
     // Show notification to user
     toast.error(data.message);
     // Redirect to login or home
     router.push("/");
   });
   ```
  </action>
  <verify>
    - Soft-lock a guest via admin UI/API
    - Guest receives notification before disconnect
    - Guest's Socket.IO connection is terminated
    - Guest sees "access revoked" message
    - `npm run build` succeeds
  </verify>
  <done>
    - Soft-locked guests disconnected from Socket.IO
    - Guests receive notification before disconnect
    - Admin API endpoint available for triggering disconnect
    - Client handles guest:locked event
  </done>
</task>

</tasks>

<verification>
1. Test CORS: connect from allowed origin -> success
2. Test CORS: connect from random origin -> rejected, logged
3. Check server logs for CORS violation messages
4. Test guest disconnect: soft-lock guest, verify disconnect + notification
5. `npm run lint` passes
6. `npm run build` succeeds
</verification>

<success_criteria>
- Socket.IO rejects connections from non-whitelisted origins
- CORS violations logged with origin details
- Soft-locked guests disconnected from Socket.IO
- Disconnected guests receive notification before disconnect
</success_criteria>

<output>
After completion, create `.planning/phases/32-medium-low-security/32-04-SUMMARY.md`
</output>
