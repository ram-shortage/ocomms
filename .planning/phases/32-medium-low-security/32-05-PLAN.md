---
phase: 32-medium-low-security
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ssrf-protection.ts
  - src/lib/redirect-validation.ts
  - src/workers/link-preview.worker.ts
  - src/app/api/auth/[...all]/route.ts
autonomous: true

must_haves:
  truths:
    - "Redirect URLs validated against allowed domains on startup"
    - "Link preview SSRF protection includes DNS rebinding checks"
    - "Invalid redirect URLs blocked with clear error"
    - "Private IP redirects blocked after DNS resolution"
  artifacts:
    - path: "src/lib/redirect-validation.ts"
      provides: "Redirect URL validation utilities"
      exports: ["validateRedirectUrl", "initAllowedRedirectDomains"]
    - path: "src/lib/ssrf-protection.ts"
      provides: "SSRF protection with DNS rebinding checks"
      exports: ["isUrlSafe", "validateDnsRebinding"]
  key_links:
    - from: "src/app/api/auth/[...all]/route.ts"
      to: "src/lib/redirect-validation.ts"
      via: "validateRedirectUrl call"
      pattern: "validateRedirectUrl"
---

<objective>
Validate redirect URLs against allowed domains and enhance SSRF protection with DNS rebinding checks.

Purpose: Prevent open redirect vulnerabilities (SEC2-14) and DNS rebinding attacks (SEC2-15)
Output: Redirect validation utility, enhanced SSRF protection, integration with auth and link preview
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/32-medium-low-security/32-CONTEXT.md
@.planning/phases/32-medium-low-security/32-RESEARCH.md

@src/lib/ssrf-protection.ts
@src/workers/link-preview.worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create redirect URL validation</name>
  <files>
    src/lib/redirect-validation.ts
    src/app/api/auth/[...all]/route.ts
  </files>
  <action>
1. Create `src/lib/redirect-validation.ts`:
   ```typescript
   /**
    * Redirect URL validation to prevent open redirect vulnerabilities.
    *
    * Validates that redirect URLs point to allowed domains only.
    * Domains are configured via ALLOWED_REDIRECT_DOMAINS env var
    * or default to NEXT_PUBLIC_APP_URL domain.
    */

   let allowedDomains: string[] = [];
   let initialized = false;

   /**
    * Initialize allowed redirect domains from environment.
    * Call once at startup (in server.ts or middleware).
    */
   export function initAllowedRedirectDomains(): void {
     const envDomains = process.env.ALLOWED_REDIRECT_DOMAINS;

     if (envDomains) {
       allowedDomains = envDomains.split(",").map(d => d.trim().toLowerCase()).filter(Boolean);
     } else if (process.env.NEXT_PUBLIC_APP_URL) {
       // Extract domain from APP_URL
       try {
         const url = new URL(process.env.NEXT_PUBLIC_APP_URL);
         allowedDomains = [url.hostname];
       } catch {
         console.error("[Redirect] Invalid NEXT_PUBLIC_APP_URL, no redirect domains configured");
         allowedDomains = [];
       }
     }

     if (allowedDomains.length === 0) {
       console.warn("[Redirect] No allowed redirect domains configured - all external redirects will be blocked");
     } else {
       console.log(`[Redirect] Allowed redirect domains: ${allowedDomains.join(", ")}`);
     }

     initialized = true;
   }

   /**
    * Validate a redirect URL against allowed domains.
    *
    * @param url - The URL to validate
    * @returns true if URL is safe to redirect to
    */
   export function validateRedirectUrl(url: string): boolean {
     if (!initialized) {
       initAllowedRedirectDomains();
     }

     // Allow relative URLs (same origin)
     if (url.startsWith("/") && !url.startsWith("//")) {
       return true;
     }

     // Parse absolute URL
     try {
       const parsed = new URL(url);

       // Only allow http(s)
       if (!["http:", "https:"].includes(parsed.protocol)) {
         return false;
       }

       // Check hostname against allowed domains
       const hostname = parsed.hostname.toLowerCase();

       // Exact match
       if (allowedDomains.includes(hostname)) {
         return true;
       }

       // Subdomain match (if domain starts with .)
       for (const domain of allowedDomains) {
         if (domain.startsWith(".") && hostname.endsWith(domain)) {
           return true;
         }
       }

       return false;
     } catch {
       // Invalid URL
       return false;
     }
   }

   /**
    * Get safe redirect URL or fallback.
    *
    * @param url - The requested redirect URL
    * @param fallback - Fallback URL if invalid (default: "/")
    * @returns Safe URL to redirect to
    */
   export function getSafeRedirectUrl(url: string | null | undefined, fallback = "/"): string {
     if (!url) {
       return fallback;
     }

     if (validateRedirectUrl(url)) {
       return url;
     }

     console.warn(`[Redirect] Blocked invalid redirect URL: ${url}`);
     return fallback;
   }
   ```

2. Initialize redirect domains in server startup - update `src/server/index.ts`:
   ```typescript
   import { initAllowedRedirectDomains } from "@/lib/redirect-validation";

   // At the start of the async IIFE, before app.prepare():
   initAllowedRedirectDomains();
   ```

3. Update auth route to validate redirects - check `src/app/api/auth/[...all]/route.ts`:
   - If the route handles redirect URLs (callbackURL, redirectTo, etc.):
   ```typescript
   import { getSafeRedirectUrl } from "@/lib/redirect-validation";

   // When processing callback/redirect URLs:
   const safeRedirect = getSafeRedirectUrl(requestedRedirect, "/dashboard");
   ```

4. Add documentation for ALLOWED_REDIRECT_DOMAINS:
   - Update .env.example:
   ```
   # Allowed redirect domains (comma-separated)
   # Supports exact match and subdomain match (prefix with .)
   # ALLOWED_REDIRECT_DOMAINS=app.example.com,.example.com
   ```
  </action>
  <verify>
    - Server starts and logs allowed redirect domains
    - Redirect to allowed domain -> passes validation
    - Redirect to external domain -> blocked
    - Relative URLs (/dashboard) -> allowed
    - `npm run build` succeeds
  </verify>
  <done>
    - Redirect URLs validated against allowed domains
    - Domains loaded from env at startup
    - Invalid redirects blocked and logged
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance SSRF protection with DNS rebinding checks</name>
  <files>
    src/lib/ssrf-protection.ts
    src/workers/link-preview.worker.ts
  </files>
  <action>
1. Update `src/lib/ssrf-protection.ts` to add DNS rebinding documentation and hostname validation:
   ```typescript
   import { isIP } from "net";

   /**
    * SSRF Protection Utilities
    *
    * This module provides protection against Server-Side Request Forgery attacks,
    * including DNS rebinding protection.
    *
    * DNS Rebinding Protection:
    * - request-filtering-agent validates the resolved IP address, not just hostname
    * - This prevents DNS rebinding where attacker DNS first resolves to public IP
    *   (passing hostname check) then resolves to private IP (during actual request)
    * - The agent blocks requests AFTER DNS resolution if IP is private/internal
    *
    * Usage:
    * 1. Call isUrlSafe() to validate URL format before queuing
    * 2. Use RequestFilteringHttpAgent in actual fetch calls
    */

   // Blocked hostname patterns
   const BLOCKED_HOSTNAMES = [
     "localhost",
     "127.0.0.1",
     "::1",
     "0.0.0.0",
     "[::1]",
     "169.254.169.254", // AWS metadata
     "metadata.google.internal", // GCP metadata
   ];

   // Blocked URL schemes
   const ALLOWED_PROTOCOLS = ["http:", "https:"];

   // Blocked file extensions (non-HTML content)
   const BLOCKED_EXTENSIONS = [
     ".pdf", ".doc", ".docx", ".xls", ".xlsx",
     ".zip", ".tar", ".gz", ".rar",
     ".exe", ".dmg", ".pkg",
     ".mp3", ".mp4", ".avi", ".mov",
     ".jpg", ".jpeg", ".png", ".gif", ".svg",
   ];

   /**
    * Check if URL is safe for link preview fetching.
    * This performs URL-level validation BEFORE queuing.
    * Actual DNS rebinding protection happens via request-filtering-agent during fetch.
    */
   export function isUrlSafe(url: string): boolean {
     try {
       const parsed = new URL(url);

       // Protocol check
       if (!ALLOWED_PROTOCOLS.includes(parsed.protocol)) {
         return false;
       }

       // Hostname checks
       const hostname = parsed.hostname.toLowerCase();

       // Block direct IP addresses (force DNS resolution path for rebinding protection)
       if (isIP(hostname)) {
         console.log(`[SSRF] Blocked direct IP address: ${hostname}`);
         return false;
       }

       // Block known internal hostnames
       if (BLOCKED_HOSTNAMES.includes(hostname)) {
         console.log(`[SSRF] Blocked internal hostname: ${hostname}`);
         return false;
       }

       // Block hostnames ending with internal TLDs
       if (hostname.endsWith(".local") ||
           hostname.endsWith(".internal") ||
           hostname.endsWith(".localhost")) {
         console.log(`[SSRF] Blocked internal TLD: ${hostname}`);
         return false;
       }

       // File extension check
       const pathname = parsed.pathname.toLowerCase();
       if (BLOCKED_EXTENSIONS.some(ext => pathname.endsWith(ext))) {
         return false;
       }

       return true;
     } catch {
       return false;
     }
   }

   /**
    * Validate that hostname doesn't resolve to private IP.
    * Note: This is handled by request-filtering-agent at fetch time,
    * but can be called proactively for additional safety.
    */
   export async function validateNotPrivateIP(hostname: string): Promise<boolean> {
     // This function exists for documentation and testing purposes.
     // In production, request-filtering-agent handles this automatically
     // by blocking requests after DNS resolution if IP is private.

     // For now, we rely on request-filtering-agent's built-in protection.
     // This function can be extended to do proactive DNS lookup if needed.
     return true;
   }
   ```

2. Update `src/workers/link-preview.worker.ts` to add comment about DNS rebinding protection:
   ```typescript
   // At the top of the file, update/add comment:
   /**
    * Link Preview Worker
    *
    * SSRF Protection:
    * - isUrlSafe() validates URL format before processing
    * - RequestFilteringHttpAgent/HttpsAgent block requests to private IPs
    * - DNS rebinding attacks are prevented because the agent validates
    *   the resolved IP address (after DNS resolution), not just hostname
    *
    * The agent intercepts the request after DNS resolution, checking:
    * - 10.0.0.0/8 (private)
    * - 172.16.0.0/12 (private)
    * - 192.168.0.0/16 (private)
    * - 127.0.0.0/8 (loopback)
    * - 169.254.0.0/16 (link-local)
    * - etc.
    */
   ```

3. Ensure isIP is imported and direct IPs are blocked in isUrlSafe:
   - Already added in step 1 above

4. Add test case comments in the file for future reference:
   ```typescript
   // Test cases for SSRF protection:
   // isUrlSafe("http://localhost/secret") -> false (blocked hostname)
   // isUrlSafe("http://127.0.0.1/secret") -> false (direct IP blocked)
   // isUrlSafe("http://169.254.169.254/metadata") -> false (AWS metadata)
   // isUrlSafe("http://evil.com") -> true (passes URL check)
   //   BUT: if evil.com DNS resolves to 127.0.0.1, request-filtering-agent blocks
   // isUrlSafe("http://example.com/file.pdf") -> false (blocked extension)
   ```
  </action>
  <verify>
    - isUrlSafe rejects localhost, 127.0.0.1, direct IPs
    - isUrlSafe rejects .local, .internal TLDs
    - Link preview worker has DNS rebinding protection via request-filtering-agent
    - `npm run build` succeeds
  </verify>
  <done>
    - SSRF protection enhanced with explicit DNS rebinding documentation
    - Direct IP addresses blocked in URL validation
    - Internal hostnames and TLDs blocked
    - request-filtering-agent handles runtime DNS rebinding protection
  </done>
</task>

</tasks>

<verification>
1. Server logs allowed redirect domains on startup
2. Auth redirect to allowed domain -> works
3. Auth redirect to external domain -> blocked, falls back
4. Link preview for localhost URL -> blocked by isUrlSafe
5. Link preview for direct IP -> blocked
6. `npm run lint` passes
7. `npm run build` succeeds
</verification>

<success_criteria>
- Redirect URLs validated against allowed domains on startup
- Invalid redirects blocked with fallback to safe URL
- Link preview SSRF protection blocks direct IPs and internal hostnames
- DNS rebinding protection via request-filtering-agent documented
</success_criteria>

<output>
After completion, create `.planning/phases/32-medium-low-security/32-05-SUMMARY.md`
</output>
