---
phase: 32-medium-low-security
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/queue/attachment-cleanup.queue.ts
  - src/workers/attachment-cleanup.worker.ts
  - src/workers/index.ts
  - scripts/generate-sri.ts
  - next.config.ts
autonomous: true

must_haves:
  truths:
    - "Orphaned attachments deleted after 24 hours"
    - "Cleanup job runs daily"
    - "Deleted attachments logged with identifiers"
    - "Static assets have SRI hashes in production"
  artifacts:
    - path: "src/server/queue/attachment-cleanup.queue.ts"
      provides: "BullMQ cleanup queue definition"
      exports: ["attachmentCleanupQueue"]
    - path: "src/workers/attachment-cleanup.worker.ts"
      provides: "Cleanup job processor"
      exports: ["createAttachmentCleanupWorker"]
  key_links:
    - from: "src/workers/attachment-cleanup.worker.ts"
      to: "src/db/schema/file-attachment.ts"
      via: "query for orphaned files"
      pattern: "fileAttachments"
---

<objective>
Implement daily cleanup job for orphaned attachments and add SRI hashes to static assets.

Purpose: Clean up orphaned files (SEC2-22) and add Subresource Integrity for static assets (SEC2-17)
Output: Cleanup queue, worker, and SRI hash generation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/32-medium-low-security/32-CONTEXT.md
@.planning/phases/32-medium-low-security/32-RESEARCH.md

@src/server/queue/index.ts
@src/workers/index.ts
@src/db/schema/file-attachment.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create attachment cleanup queue and worker</name>
  <files>
    src/server/queue/attachment-cleanup.queue.ts
    src/workers/attachment-cleanup.worker.ts
    src/workers/index.ts
    src/server/queue/index.ts
  </files>
  <action>
1. Create `src/server/queue/attachment-cleanup.queue.ts`:
   ```typescript
   import { Queue } from "bullmq";
   import { getQueueConnection } from "./connection";

   export interface AttachmentCleanupJobData {
     gracePeriodHours: number;
   }

   export const attachmentCleanupQueue = new Queue<AttachmentCleanupJobData>(
     "attachment-cleanup",
     {
       connection: getQueueConnection(),
       defaultJobOptions: {
         attempts: 3,
         backoff: { type: "exponential", delay: 5000 },
         removeOnComplete: { count: 10 },
         removeOnFail: { count: 50 },
       },
     }
   );

   /**
    * Schedule daily cleanup job.
    * Call once at server startup.
    */
   export async function scheduleAttachmentCleanup(): Promise<void> {
     // Remove any existing repeatable jobs first to prevent duplicates
     const existingJobs = await attachmentCleanupQueue.getRepeatableJobs();
     for (const job of existingJobs) {
       await attachmentCleanupQueue.removeRepeatableByKey(job.key);
     }

     // Schedule daily cleanup at 3 AM
     await attachmentCleanupQueue.add(
       "daily-cleanup",
       { gracePeriodHours: 24 }, // 24-hour grace period per user decision
       {
         repeat: {
           pattern: "0 3 * * *", // Cron: 3 AM daily
         },
       }
     );

     console.log("[AttachmentCleanup] Daily cleanup job scheduled for 3 AM");
   }
   ```

2. Create `src/workers/attachment-cleanup.worker.ts`:
   ```typescript
   import { Worker } from "bullmq";
   import { db } from "@/db";
   import { fileAttachments, messages } from "@/db/schema";
   import { eq, lt, isNull, and, notExists } from "drizzle-orm";
   import { getQueueConnection } from "@/server/queue/connection";
   import { unlink } from "fs/promises";
   import { join } from "path";
   import type { AttachmentCleanupJobData } from "@/server/queue/attachment-cleanup.queue";

   const UPLOAD_DIR = process.env.UPLOAD_DIR || "public/uploads";

   /**
    * Attachment Cleanup Worker
    *
    * Deletes orphaned attachments that are:
    * 1. Never attached to a message (messageId is NULL) AND older than grace period
    * 2. Attached to a message that was deleted AND older than grace period
    *
    * Grace period (24 hours) prevents deleting in-progress uploads.
    */
   export function createAttachmentCleanupWorker(): Worker<AttachmentCleanupJobData> {
     return new Worker<AttachmentCleanupJobData>(
       "attachment-cleanup",
       async (job) => {
         const { gracePeriodHours } = job.data;
         const cutoffDate = new Date(Date.now() - gracePeriodHours * 60 * 60 * 1000);

         console.log(`[AttachmentCleanup] Starting cleanup job ${job.id}`);
         console.log(`[AttachmentCleanup] Deleting orphans older than ${cutoffDate.toISOString()}`);

         // Find orphaned attachments:
         // 1. messageId is NULL (never attached)
         // 2. messageId references deleted message (message doesn't exist)
         const orphaned = await db.query.fileAttachments.findMany({
           where: and(
             lt(fileAttachments.createdAt, cutoffDate),
             // Either no message OR message was deleted
             // Note: If using ON DELETE CASCADE, deleted messages auto-remove attachments
             // But we also catch never-attached uploads (messageId is NULL)
             isNull(fileAttachments.messageId)
           ),
         });

         console.log(`[AttachmentCleanup] Found ${orphaned.length} orphaned attachments`);

         let deletedCount = 0;
         let errorCount = 0;

         for (const attachment of orphaned) {
           try {
             // Delete file from disk
             const filePath = join(process.cwd(), UPLOAD_DIR, "attachments", attachment.filename);
             await unlink(filePath).catch(() => {
               // File may already be deleted, continue
               console.log(`[AttachmentCleanup] File not found (already deleted?): ${attachment.filename}`);
             });

             // Delete database record
             await db.delete(fileAttachments)
               .where(eq(fileAttachments.id, attachment.id));

             console.log(`[AttachmentCleanup] Deleted: id=${attachment.id} file=${attachment.filename} size=${attachment.sizeBytes}`);
             deletedCount++;

             // Update user storage quota
             if (attachment.uploadedBy) {
               // Import dynamically to avoid circular deps
               const { updateUsage } = await import("@/lib/security/storage-quota");
               await updateUsage(attachment.uploadedBy, -attachment.sizeBytes);
             }
           } catch (error) {
             console.error(`[AttachmentCleanup] Error deleting ${attachment.id}:`, error);
             errorCount++;
           }
         }

         console.log(`[AttachmentCleanup] Job ${job.id} complete: deleted=${deletedCount} errors=${errorCount}`);

         return { deletedCount, errorCount };
       },
       {
         connection: getQueueConnection(),
         concurrency: 1, // Only one cleanup job at a time
       }
     );
   }
   ```

3. Update `src/workers/index.ts` to include cleanup worker:
   ```typescript
   import { createAttachmentCleanupWorker } from "./attachment-cleanup.worker";

   // Add to workers array
   export function startWorkers() {
     const workers = [
       // ... existing workers ...
       createAttachmentCleanupWorker(),
     ];

     console.log(`[Workers] Started ${workers.length} workers`);
     return workers;
   }
   ```

4. Update `src/server/queue/index.ts` to schedule cleanup:
   ```typescript
   import { scheduleAttachmentCleanup } from "./attachment-cleanup.queue";

   export async function initQueues() {
     // ... existing queue init ...

     // Schedule attachment cleanup job
     await scheduleAttachmentCleanup();
   }
   ```

5. Ensure initQueues is called at server startup (check src/server/index.ts)
  </action>
  <verify>
    - `npm run build` succeeds
    - Server starts and logs "Daily cleanup job scheduled for 3 AM"
    - Create an attachment without message, wait 25 hours (or manually adjust cutoff for testing)
    - Verify orphaned attachment is deleted
    - Check logs show deleted file details
  </verify>
  <done>
    - Cleanup queue and worker created
    - Daily job scheduled at 3 AM
    - 24-hour grace period before deletion
    - Detailed logging of each deleted file
    - User storage quota updated on deletion
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SRI hashes for static assets</name>
  <files>
    scripts/generate-sri.ts
    next.config.ts
  </files>
  <action>
1. Install ssri package:
   `npm install ssri`

2. Create `scripts/generate-sri.ts`:
   ```typescript
   /**
    * Generate SRI hashes for static assets.
    *
    * Run after build: npx tsx scripts/generate-sri.ts
    * Outputs sri-manifest.json with integrity hashes for JS/CSS files.
    *
    * Note: Next.js handles SRI for its own chunks when configured.
    * This script is for any additional static assets.
    */
   import ssri from "ssri";
   import { readFileSync, writeFileSync, readdirSync, statSync } from "fs";
   import { join, extname } from "path";

   const BUILD_DIR = ".next/static";
   const OUTPUT_FILE = "public/sri-manifest.json";

   interface SRIManifest {
     generated: string;
     files: Record<string, string>;
   }

   function getFiles(dir: string, files: string[] = []): string[] {
     const items = readdirSync(dir);

     for (const item of items) {
       const fullPath = join(dir, item);
       const stat = statSync(fullPath);

       if (stat.isDirectory()) {
         getFiles(fullPath, files);
       } else {
         const ext = extname(item).toLowerCase();
         if ([".js", ".css"].includes(ext)) {
           files.push(fullPath);
         }
       }
     }

     return files;
   }

   function generateSRI(): void {
     console.log("[SRI] Generating integrity hashes...");

     const manifest: SRIManifest = {
       generated: new Date().toISOString(),
       files: {},
     };

     try {
       const files = getFiles(BUILD_DIR);

       for (const file of files) {
         const content = readFileSync(file);
         const integrity = ssri.fromData(content, { algorithms: ["sha384"] });
         const relativePath = file.replace(BUILD_DIR, "/_next/static");

         manifest.files[relativePath] = integrity.toString();
         console.log(`[SRI] ${relativePath}: ${integrity.toString().slice(0, 20)}...`);
       }

       writeFileSync(OUTPUT_FILE, JSON.stringify(manifest, null, 2));
       console.log(`[SRI] Manifest written to ${OUTPUT_FILE}`);
       console.log(`[SRI] Total files: ${Object.keys(manifest.files).length}`);
     } catch (error) {
       console.error("[SRI] Error:", error);
       process.exit(1);
     }
   }

   generateSRI();
   ```

3. Update `next.config.ts` to enable SRI for scripts:
   ```typescript
   // In next.config.ts
   const nextConfig: NextConfig = {
     // ... existing config ...

     // Enable SRI for scripts in production
     experimental: {
       // ... existing experimental config ...
     },

     // Add crossOrigin for scripts (required for SRI to work)
     // Note: Full SRI support depends on hosting setup
     // For now, we generate manifest for reference
   };
   ```

   Note: Next.js 14+ has limited SRI support. The script generates a manifest
   that can be used by custom loaders or for verification purposes.

4. Add build script to package.json:
   ```json
   {
     "scripts": {
       "build": "next build",
       "postbuild": "npx tsx scripts/generate-sri.ts"
     }
   }
   ```

5. Document SRI usage:
   - The sri-manifest.json can be used for:
     - Manual verification of asset integrity
     - Custom script loaders that add integrity attributes
     - Security auditing
  </action>
  <verify>
    - `npm run build` runs successfully
    - scripts/generate-sri.ts executes after build
    - public/sri-manifest.json contains hash entries
    - Hashes are in sha384 format
  </verify>
  <done>
    - SRI hash generation script created
    - Manifest generated after each build
    - Hashes available for JS/CSS files
    - Documentation for SRI usage added
  </done>
</task>

</tasks>

<verification>
1. Server startup logs "Daily cleanup job scheduled for 3 AM"
2. Create orphaned attachment (upload without attaching to message)
3. Manually trigger cleanup job (or wait/adjust time for testing)
4. Verify orphaned file deleted and logged
5. Verify user storage quota decreased
6. Run `npm run build` -> sri-manifest.json generated
7. Check manifest contains integrity hashes
8. `npm run lint` passes
9. `npm run build` succeeds
</verification>

<success_criteria>
- Orphaned attachments (never attached or message deleted) cleaned up after 24 hours
- Cleanup job runs daily at 3 AM
- Each deleted file logged with id, filename, size
- User storage quota updated when files deleted
- SRI hashes generated for static JS/CSS files after build
</success_criteria>

<output>
After completion, create `.planning/phases/32-medium-low-security/32-07-SUMMARY.md`
</output>
