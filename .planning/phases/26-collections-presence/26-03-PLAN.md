---
phase: 26-collections-presence
plan: 03
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - src/lib/push/send.ts
  - src/server/socket/handlers/notification.ts
autonomous: true

must_haves:
  truths:
    - "Push notifications are blocked when user has DND enabled"
    - "Socket.IO notifications are blocked when user has DND enabled"
  artifacts:
    - path: "src/lib/push/send.ts"
      provides: "DND check before sending push notifications"
      exports: ["isUserDndEnabled", "sendPushToUser"]
  key_links:
    - from: "src/lib/push/send.ts"
      to: "src/db/schema/user-status.ts"
      via: "drizzle query"
      pattern: "db\\.query\\.userStatuses"
    - from: "src/server/socket/handlers/notification.ts"
      to: "src/lib/push/send.ts"
      via: "function import"
      pattern: "isUserDndEnabled"
---

<objective>
Integrate DND mode into the notification pipeline.

Purpose: When user has DND enabled (STAT-06), all notifications (push and in-app) must be blocked. This is the critical integration point for the status feature.

Output: Centralized DND check function used by push sender and Socket.IO notification handler.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26-collections-presence/26-RESEARCH.md
@.planning/phases/26-collections-presence/26-01-SUMMARY.md
@src/lib/push/send.ts (current push implementation)
@src/server/socket/handlers/notification.ts (Socket.IO notification handler if exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DND check to push notification sender</name>
  <files>src/lib/push/send.ts</files>
  <action>
Update src/lib/push/send.ts to check DND status before sending:

1. Add imports at top:
   ```typescript
   import { db } from "@/db";
   import { userStatuses } from "@/db/schema";
   import { eq } from "drizzle-orm";
   ```

2. Add exported isUserDndEnabled function:
   ```typescript
   /**
    * Check if a user has DND enabled.
    * Exported for use in other notification points (Socket.IO, etc).
    */
   export async function isUserDndEnabled(userId: string): Promise<boolean> {
     const status = await db.query.userStatuses.findFirst({
       where: eq(userStatuses.userId, userId),
       columns: { dndEnabled: true },
     });
     return status?.dndEnabled ?? false;
   }
   ```

3. Update sendPushToUser function:
   - Add dndBlocked to return type: `Promise<{ sent: number; failed: number; removed: number; dndBlocked?: boolean }>`
   - At start of function (after VAPID check), add DND check:
     ```typescript
     // Check DND status first (STAT-06)
     if (await isUserDndEnabled(userId)) {
       console.log(`[Push] User ${userId} has DND enabled, skipping notification`);
       return { sent: 0, failed: 0, removed: 0, dndBlocked: true };
     }
     ```

DND check should be BEFORE getting subscriptions (early exit for efficiency).
  </action>
  <verify>
npx tsc --noEmit src/lib/push/send.ts
grep -q "isUserDndEnabled" src/lib/push/send.ts
grep -q "dndBlocked" src/lib/push/send.ts
  </verify>
  <done>Push sender checks DND status before sending. Exported isUserDndEnabled function for other notification points.</done>
</task>

<task type="auto">
  <name>Task 2: Add DND check to Socket.IO notification handler</name>
  <files>src/server/socket/handlers/notification.ts</files>
  <action>
First, check if src/server/socket/handlers/notification.ts exists. If it doesn't exist, check for notification emission points in the socket handlers.

If notification.ts exists:
1. Import isUserDndEnabled from "@/lib/push/send"
2. Before emitting notification:new events, check DND status
3. Skip emission if DND enabled, optionally log

If notification.ts doesn't exist, find where notification:new events are emitted (likely in reminder.worker.ts or message handlers):
1. For reminder worker: The reminder fires to user, check DND before emitting
2. For message notifications: Find emit("notification:new") calls

For reminder.worker.ts specifically (already exists):
1. Import isUserDndEnabled
2. Before emitting reminder:fired, check DND status
3. If DND enabled, skip the Socket.IO emission (but still process the reminder state change)

Key locations to check and update:
- src/workers/reminder.worker.ts - reminder:fired event
- src/server/socket/handlers/*.ts - any notification:new events
- Any file with io.to(userId).emit("notification

Note: Reminder:fired should still update reminder status to "fired" in DB, but skip the Socket.IO notification when DND is on.
  </action>
  <verify>
grep -r "isUserDndEnabled" src/workers/ src/server/socket/
  </verify>
  <done>DND check integrated into all notification emission points. Users with DND enabled don't receive in-app notifications.</done>
</task>

</tasks>

<verification>
Type check modified files:
```bash
npx tsc --noEmit
```

Test DND blocking (manual):
1. Set user status with DND enabled via action
2. Trigger a notification (e.g., mention in channel)
3. Verify push notification NOT sent (check console logs)
4. Verify Socket.IO notification NOT emitted
</verification>

<success_criteria>
- isUserDndEnabled exported from push/send.ts
- sendPushToUser returns early with dndBlocked when DND enabled
- Socket.IO notification emissions check DND before emitting
- Reminder worker checks DND before emitting reminder:fired
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/26-collections-presence/26-03-SUMMARY.md`
</output>
