---
phase: 26-collections-presence
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - src/lib/actions/bookmark.ts
  - src/lib/actions/user-status.ts
  - src/workers/status-expiration.worker.ts
  - src/workers/index.ts
autonomous: true

must_haves:
  truths:
    - "User can toggle bookmark on a message via server action"
    - "User can set custom status with emoji, text, and expiration"
    - "Status expiration worker clears status when job fires"
  artifacts:
    - path: "src/lib/actions/bookmark.ts"
      provides: "Bookmark CRUD server actions"
      exports: ["toggleBookmark", "getBookmarks", "isBookmarked"]
    - path: "src/lib/actions/user-status.ts"
      provides: "User status CRUD server actions with BullMQ integration"
      exports: ["setUserStatus", "clearUserStatus", "getUserStatus", "getMyStatus", "STATUS_PRESETS"]
    - path: "src/workers/status-expiration.worker.ts"
      provides: "Worker processor for status auto-clear"
      exports: ["createStatusExpirationWorker"]
  key_links:
    - from: "src/lib/actions/bookmark.ts"
      to: "src/db/schema/bookmark.ts"
      via: "drizzle query"
      pattern: "db\\.query\\.bookmarks"
    - from: "src/lib/actions/user-status.ts"
      to: "src/server/queue/status-expiration.queue.ts"
      via: "queue add/remove"
      pattern: "statusExpirationQueue\\.(add|getJob)"
    - from: "src/workers/status-expiration.worker.ts"
      to: "src/db/schema/user-status.ts"
      via: "drizzle delete"
      pattern: "db\\.delete\\(userStatuses\\)"
---

<objective>
Create server actions for bookmarks and user status, plus status expiration worker.

Purpose: Backend logic for saving/unsaving items, setting/clearing status, and auto-expiring status via BullMQ.

Output: Server actions callable from UI components, worker ready to process expiration jobs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26-collections-presence/26-RESEARCH.md
@.planning/phases/26-collections-presence/26-01-SUMMARY.md
@src/lib/actions/reminder.ts (pattern reference for server actions with BullMQ)
@src/workers/reminder.worker.ts (pattern reference for worker implementation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bookmark server actions</name>
  <files>src/lib/actions/bookmark.ts</files>
  <action>
Create src/lib/actions/bookmark.ts with "use server" directive:

1. toggleBookmark action:
   - Input: { type: "message" | "file", messageId?: string, fileId?: string }
   - Get session, throw if unauthorized
   - Check if bookmark exists for user + item
   - If exists: delete and return { bookmarked: false }
   - If not exists: insert and return { bookmarked: true }
   - Use appropriate whereClause based on type

2. getBookmarks action:
   - Get session, throw if unauthorized
   - Query bookmarks for user, ordered by createdAt desc
   - Include relations: message (with author, channel, conversation), file (with uploader, message with channel/conversation)
   - Return full bookmark list for BOOK-03

3. isBookmarked action:
   - Input: messageId: string
   - Get session, return false if no session
   - Query for bookmark existence
   - Return boolean

4. removeBookmark action (for BOOK-04):
   - Input: bookmarkId: string
   - Get session, throw if unauthorized
   - Delete bookmark by id (verify userId matches)

Follow auth pattern from reminder.ts: `auth.api.getSession({ headers: await headers() })`
  </action>
  <verify>
npx tsc --noEmit src/lib/actions/bookmark.ts
  </verify>
  <done>Bookmark server actions exist with toggle, list, check, and remove functionality.</done>
</task>

<task type="auto">
  <name>Task 2: Create user status server actions</name>
  <files>src/lib/actions/user-status.ts</files>
  <action>
Create src/lib/actions/user-status.ts with "use server" directive:

1. Define STATUS_PRESETS constant (exported for UI):
   ```typescript
   export const STATUS_PRESETS = [
     { key: "meeting", emoji: "ðŸ“…", text: "In a meeting" },
     { key: "sick", emoji: "ðŸ¤’", text: "Out sick" },
     { key: "vacation", emoji: "ðŸŒ´", text: "On vacation" },
     { key: "focusing", emoji: "ðŸŽ¯", text: "Focusing" },
   ] as const;
   ```

2. setUserStatus action:
   - Input: { emoji?: string, text?: string, expiresAt?: Date, dndEnabled?: boolean }
   - Get session, throw if unauthorized
   - Validate text length <= 100 chars (STAT-01)
   - Get existing status to find old jobId
   - If old jobId exists, cancel it via statusExpirationQueue.getJob().remove()
   - Upsert status using onConflictDoUpdate on userId
   - If expiresAt provided and in future:
     - Calculate delay = expiresAt.getTime() - Date.now()
     - Add job to statusExpirationQueue with delay and jobId: `status-${userId}`
     - Update status record with new jobId
   - Return status

3. clearUserStatus action (STAT-05):
   - Get session, throw if unauthorized
   - Get existing status
   - If exists and has jobId, cancel the job
   - Delete status record
   - Return { cleared: true }

4. getUserStatus action:
   - Input: userId: string
   - Query and return status (or null)

5. getMyStatus action:
   - Get session, return null if no session
   - Query and return current user's status

Follow BullMQ job management pattern from reminder.ts.
  </action>
  <verify>
npx tsc --noEmit src/lib/actions/user-status.ts
  </verify>
  <done>User status server actions exist with set, clear, get functionality and BullMQ expiration scheduling.</done>
</task>

<task type="auto">
  <name>Task 3: Create status expiration worker and register</name>
  <files>src/workers/status-expiration.worker.ts, src/workers/index.ts</files>
  <action>
Create src/workers/status-expiration.worker.ts following reminder.worker.ts pattern:

1. Import Worker and Job from "bullmq"
2. Import db and userStatuses schema
3. Import getQueueConnection
4. Import StatusExpirationJobData type

5. Create processStatusExpiration function:
   - Extract userId from job.data
   - Log processing start
   - Query user's current status
   - If no status, return { success: true, skipped: true }
   - If status.jobId !== job.id, return skipped (status was updated after this job was scheduled)
   - Delete the status record
   - Log completion
   - Return { success: true }

6. Create and export createStatusExpirationWorker function:
   - Create Worker with queue name "status-expiration"
   - Pass processStatusExpiration as processor
   - Set concurrency: 5
   - Add error and completion event handlers
   - Return worker

7. Update src/workers/index.ts:
   - Import createStatusExpirationWorker
   - Add: const statusExpirationWorker = createStatusExpirationWorker();
   - Add to shutdown: await statusExpirationWorker.close();

Critical: Check job.id matches status.jobId to prevent race condition where old job clears new status.
  </action>
  <verify>
npx tsc --noEmit src/workers/status-expiration.worker.ts
grep -q "statusExpirationWorker" src/workers/index.ts
  </verify>
  <done>Status expiration worker created and registered in worker index. Handles race condition with jobId verification.</done>
</task>

</tasks>

<verification>
Type check all new files:
```bash
npx tsc --noEmit src/lib/actions/bookmark.ts src/lib/actions/user-status.ts src/workers/status-expiration.worker.ts
```

Start worker and verify it loads:
```bash
npm run worker
# Should see: [Worker] BullMQ workers started
# Should include status expiration worker in output
```
</verification>

<success_criteria>
- toggleBookmark, getBookmarks, isBookmarked, removeBookmark actions exist
- setUserStatus, clearUserStatus, getUserStatus, getMyStatus actions exist
- STATUS_PRESETS exported for UI use
- Status expiration worker created and registered
- Worker handles jobId mismatch to prevent race conditions
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/26-collections-presence/26-02-SUMMARY.md`
</output>
