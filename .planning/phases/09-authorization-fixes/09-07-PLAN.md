---
phase: 09-authorization-fixes
plan: 07
type: execute
wave: 4
depends_on: []
files_modified:
  - src/db/schema/message.ts
  - drizzle/migrations/XXXX_add_sequence_constraint.sql
autonomous: true

must_haves:
  truths:
    - "Message sequences are unique per channel (channelId + sequence combination)"
    - "Message sequences are unique per conversation (conversationId + sequence combination)"
    - "Concurrent message sends cannot create duplicate sequences"
    - "Database enforces sequence uniqueness at constraint level"
  artifacts:
    - path: "src/db/schema/message.ts"
      provides: "Message schema with unique sequence constraints"
      contains: "uniqueIndex.*channel.*sequence|uniqueIndex.*conversation.*sequence"
    - path: "drizzle/migrations"
      provides: "Migration for sequence uniqueness"
  key_links:
    - from: "src/db/schema/message.ts"
      to: "database"
      via: "unique index constraint"
      pattern: "uniqueIndex"
---

<objective>
Add unique constraints on message sequences to prevent race condition duplicates.

Purpose: Current sequencing uses `max(sequence) + 1` without locking or uniqueness constraints. Concurrent sends can create duplicate sequences, breaking ordering and unread logic.

Output: Database schema with unique constraints on (channelId, sequence) and (conversationId, sequence).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Relevant source files
@src/db/schema/message.ts (file to modify)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unique indexes to message schema</name>
  <files>src/db/schema/message.ts</files>
  <action>
Modify `src/db/schema/message.ts` to add unique partial indexes on sequences.

1. Import `uniqueIndex` from drizzle-orm/pg-core (already has `index` imported):
   ```typescript
   import { pgTable, text, timestamp, uuid, integer, index, uniqueIndex, type AnyPgColumn, customType } from "drizzle-orm/pg-core";
   ```

2. Add unique indexes to the table definition (in the array returned by the third parameter function).

   The challenge: We need UNIQUE index on (channelId, sequence) WHERE channelId IS NOT NULL,
   and another on (conversationId, sequence) WHERE conversationId IS NOT NULL.

   Drizzle doesn't directly support partial unique indexes in the same way. We have options:

   Option A: Use standard unique indexes (will work but allows NULLs to be unique):
   ```typescript
   uniqueIndex("messages_channel_seq_unique_idx").on(table.channelId, table.sequence),
   uniqueIndex("messages_conversation_seq_unique_idx").on(table.conversationId, table.sequence),
   ```

   Option B: Use raw SQL via db.execute for the migration (more robust).

   **Use Option A** - PostgreSQL allows multiple NULLs in unique indexes by default, so this works correctly:
   - (channelId=X, sequence=1) is unique among channel messages
   - (channelId=NULL, sequence=1) for DM messages doesn't conflict (NULL != NULL)

   Update the index array at the bottom of the table definition:
   ```typescript
   }, (table) => [
     index("messages_channel_seq_idx").on(table.channelId, table.sequence),
     index("messages_conversation_seq_idx").on(table.conversationId, table.sequence),
     index("messages_author_idx").on(table.authorId),
     index("messages_parent_idx").on(table.parentId),
     index("messages_search_idx").using("gin", table.searchContent),
     // Add unique constraints for sequence integrity
     uniqueIndex("messages_channel_seq_unique_idx").on(table.channelId, table.sequence),
     uniqueIndex("messages_conversation_seq_unique_idx").on(table.conversationId, table.sequence),
   ]);
   ```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Unique indexes present: `grep "uniqueIndex" src/db/schema/message.ts`
  </verify>
  <done>
Message schema has unique indexes on (channelId, sequence) and (conversationId, sequence).
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate and apply migration</name>
  <files>drizzle/migrations</files>
  <action>
1. Generate the migration:
   ```bash
   npx drizzle-kit generate
   ```

2. Review the generated migration file in `drizzle/migrations/` - it should contain:
   ```sql
   CREATE UNIQUE INDEX "messages_channel_seq_unique_idx" ON "messages" ("channel_id", "sequence");
   CREATE UNIQUE INDEX "messages_conversation_seq_unique_idx" ON "messages" ("conversation_id", "sequence");
   ```

3. Apply the migration:
   ```bash
   npx drizzle-kit migrate
   ```

   If there are existing duplicate sequences (unlikely in dev), the migration will fail. In that case:
   - Run a query to identify duplicates: `SELECT channel_id, sequence, COUNT(*) FROM messages WHERE channel_id IS NOT NULL GROUP BY channel_id, sequence HAVING COUNT(*) > 1;`
   - Fix duplicates by updating sequences: `UPDATE messages SET sequence = sequence + 1 WHERE id = '<duplicate_id>';`
   - Retry migration

4. Verify the constraint exists:
   ```bash
   psql $DATABASE_URL -c "\d messages" | grep -i unique
   ```
  </action>
  <verify>
Migration generated: `ls -la drizzle/migrations/ | tail -1`
Migration applied: `npx drizzle-kit migrate` exits 0
Constraint exists in DB: `psql $DATABASE_URL -c "\d messages" 2>/dev/null | grep -i unique || echo "Check constraint manually"`
  </verify>
  <done>
Migration created and applied, unique constraints enforced at database level.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Schema has unique indexes: `grep "uniqueIndex" src/db/schema/message.ts`
3. Migration exists in drizzle/migrations/
4. Dev server starts without DB errors: `npm run dev` (briefly, then ctrl+c)
</verification>

<success_criteria>
- Message schema defines unique indexes on (channelId, sequence) and (conversationId, sequence)
- Migration file generated and applied
- Database enforces sequence uniqueness (concurrent sends with same sequence will fail, triggering retry)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-authorization-fixes/09-07-SUMMARY.md`
</output>
