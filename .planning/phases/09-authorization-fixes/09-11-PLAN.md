---
phase: 09-authorization-fixes
plan: 11
type: execute
wave: 5
depends_on: []
files_modified:
  - src/middleware.ts
autonomous: true

must_haves:
  truths:
    - "Middleware validates session token exists in database"
    - "Invalid/expired session tokens redirect to login"
    - "Valid session tokens allow request to proceed"
    - "Session validation uses better-auth API"
  artifacts:
    - path: "src/middleware.ts"
      provides: "Middleware with session validity check"
      contains: "auth.api|getSession|session"
  key_links:
    - from: "src/middleware.ts"
      to: "src/lib/auth"
      via: "session validation"
      pattern: "auth\\.api\\.getSession|validateSession"
---

<objective>
Improve middleware to validate session validity, not just cookie presence.

Purpose: Current middleware only checks if a session cookie EXISTS, not if it's VALID. Invalid/expired cookies reach protected routes until downstream checks run, which is inefficient and could allow partial access in edge cases.

Output: Modified middleware that validates session with better-auth before allowing access.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Relevant source files
@src/middleware.ts (file to modify)
@src/lib/auth.ts (better-auth instance)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement session validation in middleware</name>
  <files>src/middleware.ts</files>
  <action>
The challenge: Next.js middleware runs in the Edge runtime, which has limitations. We need to validate the session without making the middleware too slow.

**Option A: Call better-auth session endpoint**
Better-auth provides an API endpoint we can call. However, this adds latency to every request.

**Option B: Decode and validate JWT locally**
If better-auth uses JWT sessions, we can validate the token signature and expiry without a database call.

**Option C: Use better-auth middleware helper**
Check if better-auth provides a middleware helper for Next.js Edge runtime.

For now, implement **Option A** with caching consideration:

```typescript
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

// Public routes that don't require authentication
const publicRoutes = ["/login", "/signup", "/verify-email", "/api/auth", "/api/health", "/socket.io", "/accept-invite"];

// Static assets and other paths to skip
const skipPaths = ["/_next", "/favicon.ico", "/uploads"];

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // Skip static assets
  if (skipPaths.some((path) => pathname.startsWith(path))) {
    return NextResponse.next();
  }

  // Allow public routes
  if (publicRoutes.some((route) => pathname.startsWith(route))) {
    return NextResponse.next();
  }

  // Check for session cookie
  const sessionCookie = request.cookies.get("better-auth.session_token");

  if (!sessionCookie) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  // Validate session with better-auth API
  try {
    // Call the session endpoint to validate
    const sessionResponse = await fetch(new URL("/api/auth/get-session", request.url), {
      headers: {
        cookie: request.headers.get("cookie") || "",
      },
    });

    if (!sessionResponse.ok) {
      // Session invalid - redirect to login
      const response = NextResponse.redirect(new URL("/login", request.url));
      // Clear the invalid cookie
      response.cookies.delete("better-auth.session_token");
      return response;
    }

    const session = await sessionResponse.json();
    if (!session?.user) {
      // No user in session - redirect to login
      const response = NextResponse.redirect(new URL("/login", request.url));
      response.cookies.delete("better-auth.session_token");
      return response;
    }

    // Session valid - proceed
    return NextResponse.next();
  } catch (error) {
    console.error("[Middleware] Session validation error:", error);
    // On error, allow through (fail open for availability)
    // The downstream page will re-check anyway
    return NextResponse.next();
  }
}

export const config = {
  matcher: ["/((?!_next/static|_next/image|favicon.ico).*)"],
};
```

**Important considerations:**
1. This adds ~50-100ms latency per request for session validation
2. Could add caching layer (e.g., check a response header from previous validation)
3. Fail-open on errors to prevent complete lockout

**Alternative: Simpler validation**
If the latency is unacceptable, a simpler approach is to check cookie expiry:

```typescript
// Parse session token expiry from cookie if it's a JWT
// or just check cookie max-age/expires
```

Implement Option A first, can optimize later if needed.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Session validation present: `grep "get-session\|validateSession\|sessionResponse" src/middleware.ts`
  </verify>
  <done>
Middleware validates session with better-auth API and redirects invalid sessions to login.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add performance optimization with cookie age check</name>
  <files>src/middleware.ts</files>
  <action>
To reduce latency, add a quick local check before calling the session API.

Add cookie freshness check that skips full validation for recent requests:

```typescript
// Skip full validation if we validated recently (within last 5 minutes)
// This is determined by checking a validation timestamp cookie we set
const lastValidated = request.cookies.get("_session_validated");
if (lastValidated) {
  const validatedAt = parseInt(lastValidated.value, 10);
  const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
  if (validatedAt > fiveMinutesAgo) {
    // Recently validated, skip full check
    return NextResponse.next();
  }
}

// ... full validation logic ...

// After successful validation, set the timestamp cookie
const response = NextResponse.next();
response.cookies.set("_session_validated", Date.now().toString(), {
  httpOnly: true,
  sameSite: "lax",
  maxAge: 300, // 5 minutes
});
return response;
```

This optimization:
- First request after 5 minutes: Full validation (~100ms)
- Subsequent requests within 5 minutes: Cookie check only (~1ms)
- Provides good security/performance balance
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Caching present: `grep "_session_validated\|lastValidated" src/middleware.ts`
  </verify>
  <done>
Middleware has performance optimization with 5-minute validation caching.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Session validation call: `grep "get-session" src/middleware.ts`
3. Cache optimization: `grep "_session_validated" src/middleware.ts`
4. Dev server works: `npm run dev` (briefly test login flow)
</verification>

<success_criteria>
- Middleware validates session with better-auth API (not just cookie presence)
- Invalid sessions redirect to login with cookie cleared
- Performance optimization reduces latency for frequent requests
- Errors fail open (allow through) to prevent lockout
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-authorization-fixes/09-11-SUMMARY.md`
</output>
