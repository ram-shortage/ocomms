---
phase: 09-authorization-fixes
plan: 05
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/server/socket/handlers/unread.ts
autonomous: true

must_haves:
  truths:
    - "unread:fetch validates user has access to requested channels/conversations"
    - "unread:markRead validates user has access to the channel/conversation"
    - "unread:markMessageUnread validates user has access to the message's channel/DM"
    - "Unauthorized unread operations return empty/false and emit error"
  artifacts:
    - path: "src/server/socket/handlers/unread.ts"
      provides: "Unread handlers with authorization checks"
      contains: "isChannelMember|isConversationParticipant|getMessageContext"
  key_links:
    - from: "src/server/socket/handlers/unread.ts"
      to: "src/server/socket/authz.ts"
      via: "import and call"
      pattern: "import.*authz"
---

<objective>
Add authorization checks to all unread event handlers.

Purpose: Currently any authenticated user can query/modify unread counts for any channel/conversation ID. This allows information disclosure (knowing if channels have messages) and data manipulation.

Output: Modified `src/server/socket/handlers/unread.ts` with membership validation on all operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan summary (helpers created in 09-01)
@.planning/phases/09-authorization-fixes/09-01-SUMMARY.md

# Relevant source files
@src/server/socket/handlers/unread.ts (file to modify - handlers start at line 389)
@src/server/socket/authz.ts (authorization helpers from 09-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add authorization to unread:fetch handler</name>
  <files>src/server/socket/handlers/unread.ts</files>
  <action>
Modify the `handleUnreadEvents` function (starts at line 389).

1. Import authorization helpers at top of file:
   ```typescript
   import { isChannelMember, isConversationParticipant, getMessageContext } from "../authz";
   ```

2. Modify the unread:fetch handler (around line 397) to validate access:
   ```typescript
   socket.on("unread:fetch", async (data, callback) => {
     try {
       const channels: Record<string, number> = {};
       const conversations: Record<string, number> = {};

       if (data.channelIds) {
         for (const channelId of data.channelIds) {
           // Only return count if user is member
           const isMember = await isChannelMember(userId, channelId);
           if (isMember) {
             channels[channelId] = await unreadManager.getUnreadCount(userId, channelId);
           }
           // Silently skip unauthorized channels (don't reveal existence)
         }
       }

       if (data.conversationIds) {
         for (const conversationId of data.conversationIds) {
           // Only return count if user is participant
           const isParticipant = await isConversationParticipant(userId, conversationId);
           if (isParticipant) {
             conversations[conversationId] = await unreadManager.getConversationUnreadCount(userId, conversationId);
           }
           // Silently skip unauthorized conversations
         }
       }

       callback({ channels, conversations });
     } catch (error) {
       console.error("[Unread] Error fetching counts:", error);
       callback({ channels: {}, conversations: {} });
     }
   });
   ```

Note: We silently skip unauthorized entries rather than returning error - this prevents information disclosure about channel/conversation existence.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Authorization check present: `grep "isChannelMember" src/server/socket/handlers/unread.ts`
  </verify>
  <done>
unread:fetch only returns counts for channels/conversations the user is authorized to access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add authorization to unread:markRead and unread:markMessageUnread handlers</name>
  <files>src/server/socket/handlers/unread.ts</files>
  <action>
1. Modify the unread:markRead handler (around line 422):
   ```typescript
   socket.on("unread:markRead", async (data, callback) => {
     try {
       if (data.channelId) {
         const isMember = await isChannelMember(userId, data.channelId);
         if (!isMember) {
           socket.emit("error", { message: "Not authorized to mark this channel as read" });
           callback({ success: false });
           return;
         }
         await unreadManager.markChannelAsRead(userId, data.channelId);
       } else if (data.conversationId) {
         const isParticipant = await isConversationParticipant(userId, data.conversationId);
         if (!isParticipant) {
           socket.emit("error", { message: "Not authorized to mark this conversation as read" });
           callback({ success: false });
           return;
         }
         await unreadManager.markConversationAsRead(userId, data.conversationId);
       }
       callback({ success: true });
     } catch (error) {
       console.error("[Unread] Error marking as read:", error);
       callback({ success: false });
     }
   });
   ```

2. Modify the unread:markMessageUnread handler (around line 437):
   ```typescript
   socket.on("unread:markMessageUnread", async (data, callback) => {
     try {
       // Get message context to verify access
       const context = await getMessageContext(data.messageId);
       if (!context) {
         callback({ success: false });
         return;
       }

       // Verify membership
       if (context.channelId) {
         const isMember = await isChannelMember(userId, context.channelId);
         if (!isMember) {
           socket.emit("error", { message: "Not authorized to modify unread state" });
           callback({ success: false });
           return;
         }
       } else if (context.conversationId) {
         const isParticipant = await isConversationParticipant(userId, context.conversationId);
         if (!isParticipant) {
           socket.emit("error", { message: "Not authorized to modify unread state" });
           callback({ success: false });
           return;
         }
       }

       await unreadManager.markMessageAsUnread(userId, data.messageId);
       callback({ success: true });
     } catch (error) {
       console.error("[Unread] Error marking as unread:", error);
       callback({ success: false });
     }
   });
   ```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
All handlers have auth: `grep -c "isChannelMember\|isConversationParticipant" src/server/socket/handlers/unread.ts` (should be >= 3)
  </verify>
  <done>
unread:markRead and unread:markMessageUnread validate membership before modifying unread state.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Authorization import present: `grep "import.*authz" src/server/socket/handlers/unread.ts`
3. All three handlers have authorization checks
</verification>

<success_criteria>
- unread:fetch only returns counts for authorized channels/conversations
- unread:markRead validates channel/conversation membership
- unread:markMessageUnread validates message access
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-authorization-fixes/09-05-SUMMARY.md`
</output>
