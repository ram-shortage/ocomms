---
phase: 09-authorization-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/socket/authz.ts
autonomous: true

must_haves:
  truths:
    - "Authorization helpers exist and are importable from socket handlers"
    - "Channel membership check returns boolean based on DB lookup"
    - "Conversation participation check returns boolean based on DB lookup"
    - "Organization membership check returns boolean based on DB lookup"
  artifacts:
    - path: "src/server/socket/authz.ts"
      provides: "Reusable authorization helpers for Socket.IO handlers"
      exports: ["isChannelMember", "isConversationParticipant", "isOrganizationMember", "getMessageContext"]
  key_links:
    - from: "src/server/socket/authz.ts"
      to: "src/db/schema"
      via: "drizzle queries"
      pattern: "db\\.select.*from.*where"
---

<objective>
Create shared authorization helper functions for Socket.IO handlers.

Purpose: All socket handlers (thread, reaction, unread, room joins) need to validate channel/DM/org membership before performing operations. Creating reusable helpers avoids code duplication and ensures consistent authorization checks.

Output: `src/server/socket/authz.ts` with helper functions for membership validation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Relevant source files
@src/server/socket/handlers/message.ts (existing pattern for membership checks)
@src/server/socket/rooms.ts (room naming conventions)
@src/db/schema/channel.ts (channelMembers table)
@src/db/schema/conversation.ts (conversationParticipants table)
@src/db/schema/auth.ts (members table for org membership)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create authorization helpers module</name>
  <files>src/server/socket/authz.ts</files>
  <action>
Create `src/server/socket/authz.ts` with these functions:

1. `isChannelMember(userId: string, channelId: string): Promise<boolean>`
   - Query channelMembers for (userId, channelId) match
   - Return true if row exists, false otherwise
   - Use existing pattern from message.ts lines 31-40

2. `isConversationParticipant(userId: string, conversationId: string): Promise<boolean>`
   - Query conversationParticipants for (userId, conversationId) match
   - Return true if row exists, false otherwise
   - Use existing pattern from message.ts lines 43-52

3. `isOrganizationMember(userId: string, organizationId: string): Promise<boolean>`
   - Query members table for (userId, organizationId) match
   - Return true if row exists, false otherwise

4. `getMessageContext(messageId: string): Promise<{ channelId: string | null; conversationId: string | null } | null>`
   - Query messages table by ID
   - Return channelId/conversationId if found, null if not found
   - Useful for thread/reaction handlers that receive messageId

5. `getChannelOrganization(channelId: string): Promise<string | null>`
   - Query channels table by ID
   - Return organizationId if found, null if not found

6. `getConversationOrganization(conversationId: string): Promise<string | null>`
   - Query conversations table by ID
   - Return organizationId if found, null if not found

Import db from "@/db" and required schema tables from "@/db/schema".
Use eq and and from drizzle-orm for queries.
All functions are async and use standard drizzle select patterns.
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit`
Verify file exists with correct exports: `grep -E "export (async )?function" src/server/socket/authz.ts`
  </verify>
  <done>
Authorization helpers module exists at src/server/socket/authz.ts with all 6 helper functions exported and type-checking passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for authorization helpers</name>
  <files>src/server/socket/__tests__/authz.test.ts</files>
  <action>
Create test file `src/server/socket/__tests__/authz.test.ts` with tests for each helper function.

Use vitest (already in project). Structure:

```typescript
import { describe, it, expect, beforeEach, afterEach } from "vitest";
// Import helpers and db utilities

describe("Socket Authorization Helpers", () => {
  describe("isChannelMember", () => {
    it("returns true when user is member", async () => {
      // Setup: create test channel and membership
      // Assert: isChannelMember returns true
    });

    it("returns false when user is not member", async () => {
      // Assert: isChannelMember returns false for non-member
    });
  });

  describe("isConversationParticipant", () => {
    it("returns true when user is participant", async () => { ... });
    it("returns false when user is not participant", async () => { ... });
  });

  describe("isOrganizationMember", () => {
    it("returns true when user is org member", async () => { ... });
    it("returns false when user is not org member", async () => { ... });
  });

  describe("getMessageContext", () => {
    it("returns channelId for channel message", async () => { ... });
    it("returns conversationId for DM message", async () => { ... });
    it("returns null for non-existent message", async () => { ... });
  });
});
```

Use existing test database setup patterns if present, otherwise mock db calls with vitest.mock().
  </action>
  <verify>
Run tests: `npm test -- src/server/socket/__tests__/authz.test.ts`
All tests should pass.
  </verify>
  <done>
Tests exist and pass for all authorization helper functions.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Authorization helpers are exported: `grep "export" src/server/socket/authz.ts`
3. Tests pass: `npm test -- src/server/socket/__tests__/authz.test.ts`
</verification>

<success_criteria>
- src/server/socket/authz.ts exists with 6 exported helper functions
- All functions follow existing drizzle query patterns
- TypeScript compiles without errors
- Tests pass for all helper functions
</success_criteria>

<output>
After completion, create `.planning/phases/09-authorization-fixes/09-01-SUMMARY.md`
</output>
