---
phase: 07-search
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/app/(workspace)/[workspaceSlug]/search/page.tsx
  - src/components/search/search-input.tsx
  - src/components/search/search-results.tsx
autonomous: true

must_haves:
  truths:
    - "Member can navigate to search page"
    - "Member can type search query and submit"
    - "Search results display with message content and context"
    - "Member can click result to navigate to source message"
  artifacts:
    - path: "src/app/(workspace)/[workspaceSlug]/search/page.tsx"
      provides: "Search page route"
      min_lines: 30
    - path: "src/components/search/search-input.tsx"
      provides: "Search input component"
      exports: ["SearchInput"]
    - path: "src/components/search/search-results.tsx"
      provides: "Search results display"
      exports: ["SearchResults"]
  key_links:
    - from: "src/app/(workspace)/[workspaceSlug]/search/page.tsx"
      to: "src/lib/actions/search.ts"
      via: "searchMessages import"
      pattern: "import.*searchMessages"
    - from: "src/components/search/search-results.tsx"
      to: "navigation"
      via: "Link to message source"
      pattern: "href=.*channel|dm"
---

<objective>
Create search UI with input, results display, and navigation to source messages.

Purpose: Enable members to search messages through a dedicated search page, view results with context (author, channel/DM, timestamp), and navigate to the original message location.

Output:
- Search page at /[workspaceSlug]/search
- SearchInput component for query submission
- SearchResults component for displaying results with navigation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/7-search/07-01-SUMMARY.md
@src/lib/actions/search.ts
@src/components/channel/channel-header.tsx
@src/components/ui/input.tsx
@src/components/ui/card.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create search input component</name>
  <files>src/components/search/search-input.tsx</files>
  <action>
Create search input component at `src/components/search/search-input.tsx`:

1. Create "use client" component with props:
```typescript
interface SearchInputProps {
  initialQuery?: string;
  onSearch: (query: string) => void;
  isLoading?: boolean;
}
```

2. Component structure:
- Use controlled input with local state for query
- Use shadcn Input component from @/components/ui/input
- Add search icon (use lucide-react Search icon)
- Handle form submission (Enter key or submit button)
- Debounce optional but NOT required for v1 (user submits explicitly)

3. Styling:
- Use Tailwind classes consistent with existing components
- Include placeholder text: "Search messages..."
- Show loading state when isLoading is true
- Clear button (X icon) when query has text

4. Export the component.
  </action>
  <verify>
1. Component renders without errors
2. Typing in input updates local state
3. Pressing Enter calls onSearch with query
4. Clear button clears input
  </verify>
  <done>SearchInput component exists with controlled input, search submission, and loading state</done>
</task>

<task type="auto">
  <name>Task 2: Create search results component</name>
  <files>src/components/search/search-results.tsx</files>
  <action>
Create search results component at `src/components/search/search-results.tsx`:

1. Create component with props:
```typescript
import type { SearchResult } from "@/lib/actions/search";

interface SearchResultsProps {
  results: SearchResult[];
  workspaceSlug: string;
  isLoading?: boolean;
  query: string;
}
```

2. Handle states:
- Loading state: Show skeleton or "Searching..." message
- Empty query: Show instruction "Enter a search term to find messages"
- No results: Show "No messages found for '[query]'"
- Results: Show list of result cards

3. Each result card should display:
- Author avatar and name (use existing patterns from message-item.tsx)
- Message content (truncate if > 200 chars, use text-sm)
- Context badge: "#channel-name" or "DM with [name]"
- Relative timestamp (use date-fns formatDistanceToNow or similar)
- Click navigates to message source

4. Navigation links:
- For channel messages: `/${workspaceSlug}/channels/${channel.slug}`
- For DM messages: `/${workspaceSlug}/dm/${conversationId}`
- Use Next.js Link component

5. Styling:
- Use Card component for each result
- Hover state for clickable results
- Consistent spacing and typography with existing UI
  </action>
  <verify>
1. Component renders without errors
2. Loading state displays correctly
3. Empty state displays correctly
4. Results render with author, content, context, and timestamp
5. Clicking result navigates to correct URL
  </verify>
  <done>SearchResults component displays results with context and navigation links</done>
</task>

<task type="auto">
  <name>Task 3: Create search page</name>
  <files>src/app/(workspace)/[workspaceSlug]/search/page.tsx</files>
  <action>
Create search page at `src/app/(workspace)/[workspaceSlug]/search/page.tsx`:

1. Create async server component for the page:
```typescript
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { redirect, notFound } from "next/navigation";
```

2. Parse params and searchParams:
- Get workspaceSlug from params
- Get 'q' query parameter from searchParams (URL: /search?q=keyword)

3. Validate session and workspace access:
- Get session, redirect to /login if none
- Find organization by slug, return notFound if not found

4. Call searchMessages if query exists:
```typescript
import { searchMessages } from "@/lib/actions/search";

const results = q ? await searchMessages(organization.id, q) : [];
```

5. Render page layout:
- Page title: "Search"
- SearchInput component (client component wrapper needed for interactivity)
- SearchResults component with results

6. Create client wrapper for SearchInput that:
- Uses useRouter and useSearchParams
- Updates URL with query param on search: `router.push(\`/${workspaceSlug}/search?q=\${encodeURIComponent(query)}\`)`
- Preserves search state in URL for shareable links

7. Page structure:
```tsx
<div className="flex flex-col h-full p-6">
  <h1 className="text-2xl font-bold mb-4">Search</h1>
  <SearchInputClient workspaceSlug={workspaceSlug} initialQuery={q} />
  <div className="mt-6">
    <SearchResults results={results} workspaceSlug={workspaceSlug} query={q || ""} />
  </div>
</div>
```

8. The client wrapper component can be inline in the page file or in a separate file - inline is simpler for this use case.
  </action>
  <verify>
1. Navigate to /[workspace]/search - page loads
2. Enter query and submit - URL updates with ?q=query
3. Results display from server action
4. Refresh page with ?q=query - search results persist
5. Click result - navigates to channel/DM page
  </verify>
  <done>Search page works end-to-end with URL-based query state</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Navigate to search page: /[workspace]/search loads
2. Search for keyword: Results appear from accessible channels/DMs
3. Empty search: Shows appropriate empty state
4. Click result: Navigates to correct channel or DM
5. URL state: Query persists in URL, shareable
</verification>

<success_criteria>
- Search page accessible at /[workspaceSlug]/search
- Members can enter search queries
- Results display with author, content preview, and context
- Results link to source channel/DM
- Search state preserved in URL
- Loading and empty states handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/7-search/07-02-SUMMARY.md`
</output>
