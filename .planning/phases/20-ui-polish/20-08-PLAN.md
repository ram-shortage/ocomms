# Plan 20-08: Data Integrity & Concurrency Tests

## Frontmatter

```yaml
phase: 20
plan: 08
title: Data Integrity & Concurrency Tests
objective: Test race conditions, idempotency, and data consistency under concurrent operations
wave: 2
depends_on: []
autonomous: true
estimated_tasks: 3
files_modified:
  - tests/concurrency/message-sequence.test.ts
  - tests/concurrency/reaction-toggle.test.ts
  - tests/concurrency/idempotency.test.ts
```

## Context

Tests for data integrity under concurrent operations:
- Race conditions (message sequencing, thread reply sequencing)
- Idempotency (reaction toggle, notification settings, join/leave)
- Concurrent access patterns

These tests require either:
1. Parallel test execution against a real database
2. Mocked concurrency simulation

## Tasks

### Task 1: Message Sequence Concurrency Tests

<task id="1">
<title>Message sequence race condition tests</title>
<files>
- tests/concurrency/message-sequence.test.ts
</files>
<action>
Create tests that verify message sequencing under concurrent writes:

1. **Atomic sequence increment**
   - Two concurrent messages get different sequence numbers
   - No sequence number gaps
   - No duplicate sequence numbers

2. **Thread reply sequencing**
   - Concurrent replies to same thread get unique sequences
   - Parent replyCount updates correctly

3. **Channel message ordering**
   - Messages arrive in sequence order
   - Late-arriving messages don't break order

```typescript
import { describe, it, expect } from "vitest";

describe("Message Sequence Concurrency", () => {
  describe("Atomic sequence increment", () => {
    it("concurrent messages get unique sequences", async () => {
      // Setup: channel at sequence 0
      // Action: send 10 messages concurrently (Promise.all)
      // Assert: sequences are [1,2,3,4,5,6,7,8,9,10] with no gaps/duplicates

      const channel = await createTestChannel();
      const promises = Array(10).fill(null).map((_, i) =>
        sendMessage(channel.id, `Message ${i}`)
      );

      const messages = await Promise.all(promises);
      const sequences = messages.map(m => m.sequence).sort((a, b) => a - b);

      expect(sequences).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    });

    it("no sequence gaps under high concurrency", async () => {
      // Setup: channel at sequence 100
      // Action: send 50 messages concurrently
      // Assert: sequences are 101-150 with no gaps

      const channel = await createTestChannel({ startSequence: 100 });
      const promises = Array(50).fill(null).map(() =>
        sendMessage(channel.id, "Test")
      );

      await Promise.all(promises);

      const messages = await getChannelMessages(channel.id);
      const sequences = messages.map(m => m.sequence).sort((a, b) => a - b);

      // Check for gaps
      for (let i = 1; i < sequences.length; i++) {
        expect(sequences[i] - sequences[i-1]).toBe(1);
      }
    });
  });

  describe("Thread reply sequencing", () => {
    it("concurrent replies get unique thread sequences", async () => {
      // Setup: parent message
      // Action: send 5 replies concurrently
      // Assert: thread sequences are unique

      const parent = await createTestMessage();
      const promises = Array(5).fill(null).map(() =>
        replyToMessage(parent.id, "Reply")
      );

      const replies = await Promise.all(promises);
      const threadSeqs = replies.map(r => r.threadSequence);
      const uniqueSeqs = new Set(threadSeqs);

      expect(uniqueSeqs.size).toBe(5);
    });

    it("parent replyCount is accurate after concurrent replies", async () => {
      // Setup: parent with replyCount = 0
      // Action: send 10 replies concurrently
      // Assert: parent.replyCount = 10

      const parent = await createTestMessage();
      const promises = Array(10).fill(null).map(() =>
        replyToMessage(parent.id, "Reply")
      );

      await Promise.all(promises);

      const updated = await getMessage(parent.id);
      expect(updated.replyCount).toBe(10);
    });
  });
});
```
</action>
<verify>
```bash
npm run test -- tests/concurrency/message-sequence.test.ts
```
</verify>
<done>
- [ ] Concurrent message sequences unique tested
- [ ] No sequence gaps tested
- [ ] Thread reply sequences tested
- [ ] Parent replyCount accuracy tested
- [ ] All tests pass
</done>
</task>

### Task 2: Reaction Toggle Idempotency Tests

<task id="2">
<title>Reaction toggle idempotency tests</title>
<files>
- tests/concurrency/reaction-toggle.test.ts
</files>
<action>
Create tests for reaction toggle under concurrent operations:

1. **Double-toggle consistency**
   - Rapid toggle-toggle returns to original state
   - No orphaned reactions

2. **Concurrent toggles from same user**
   - Only one reaction exists after concurrent adds
   - Consistent state regardless of timing

3. **Concurrent toggles from multiple users**
   - Each user's reaction tracked correctly
   - No cross-user interference

```typescript
describe("Reaction Toggle Concurrency", () => {
  describe("Double-toggle consistency", () => {
    it("rapid toggle returns to original state", async () => {
      // Setup: message with no reactions
      // Action: toggle üëç, toggle üëç (rapid)
      // Assert: no reaction exists

      const message = await createTestMessage();

      // Rapid double toggle
      await Promise.all([
        toggleReaction(message.id, "üëç", user.id),
        toggleReaction(message.id, "üëç", user.id),
      ]);

      const reactions = await getReactions(message.id);
      const thumbsUp = reactions.filter(r => r.emoji === "üëç" && r.userId === user.id);

      // Should be 0 (added then removed) or consistent state
      expect(thumbsUp.length).toBeLessThanOrEqual(1);
    });
  });

  describe("Concurrent toggles from same user", () => {
    it("at most one reaction after concurrent adds", async () => {
      // Setup: message with no reactions
      // Action: 5 concurrent toggles from same user
      // Assert: 0 or 1 reaction (not 5)

      const message = await createTestMessage();
      const promises = Array(5).fill(null).map(() =>
        toggleReaction(message.id, "üëç", user.id)
      );

      await Promise.all(promises);

      const reactions = await getReactions(message.id);
      const userReactions = reactions.filter(r => r.userId === user.id);

      expect(userReactions.length).toBeLessThanOrEqual(1);
    });
  });

  describe("Concurrent toggles from multiple users", () => {
    it("each user reaction tracked independently", async () => {
      // Setup: 5 different users
      // Action: all toggle same emoji concurrently
      // Assert: 5 reactions (one per user)

      const message = await createTestMessage();
      const users = await createTestUsers(5);

      const promises = users.map(u =>
        toggleReaction(message.id, "üëç", u.id)
      );

      await Promise.all(promises);

      const reactions = await getReactions(message.id);
      const thumbsUp = reactions.filter(r => r.emoji === "üëç");

      expect(thumbsUp.length).toBe(5);
    });
  });
});
```
</action>
<verify>
```bash
npm run test -- tests/concurrency/reaction-toggle.test.ts
```
</verify>
<done>
- [ ] Double-toggle consistency tested
- [ ] Concurrent same-user toggles tested
- [ ] Concurrent multi-user toggles tested
- [ ] All tests pass
</done>
</task>

### Task 3: General Idempotency Tests

<task id="3">
<title>General idempotency tests</title>
<files>
- tests/concurrency/idempotency.test.ts
</files>
<action>
Create tests for idempotent operations:

1. **Notification settings updates**
   - Concurrent updates to same setting converge
   - Last write wins (deterministic)

2. **Channel join/leave**
   - Double-join doesn't create duplicate memberships
   - Double-leave doesn't error

3. **Push subscription**
   - Same endpoint updates existing subscription
   - No duplicate subscriptions

4. **Mark as read**
   - Concurrent mark-read calls succeed
   - Final state is consistent

```typescript
describe("Idempotency", () => {
  describe("Notification settings", () => {
    it("concurrent updates converge to consistent state", async () => {
      // Action: set to "mentions", "none", "all" concurrently
      // Assert: final state is one of these values

      const settings = ["mentions", "none", "all"];
      const promises = settings.map(s =>
        updateNotificationSettings(channel.id, user.id, s)
      );

      await Promise.all(promises);

      const final = await getNotificationSettings(channel.id, user.id);
      expect(settings).toContain(final.preference);
    });
  });

  describe("Channel membership", () => {
    it("double-join creates only one membership", async () => {
      // Action: join channel twice concurrently
      // Assert: only one membership record

      await Promise.all([
        joinChannel(channel.id, user.id),
        joinChannel(channel.id, user.id),
      ]);

      const memberships = await getChannelMemberships(channel.id, user.id);
      expect(memberships.length).toBe(1);
    });

    it("double-leave succeeds without error", async () => {
      // Setup: user is member
      // Action: leave twice concurrently
      // Assert: no error, user is not member

      await expect(Promise.all([
        leaveChannel(channel.id, user.id),
        leaveChannel(channel.id, user.id),
      ])).resolves.not.toThrow();

      const isMember = await isChannelMember(channel.id, user.id);
      expect(isMember).toBe(false);
    });
  });

  describe("Push subscription", () => {
    it("same endpoint updates existing subscription", async () => {
      // Setup: subscription exists for endpoint
      // Action: subscribe again with same endpoint, different keys
      // Assert: one subscription with new keys

      const endpoint = "https://push.example.com/abc123";

      await subscribe(user.id, { endpoint, keys: { p256dh: "key1", auth: "auth1" } });
      await subscribe(user.id, { endpoint, keys: { p256dh: "key2", auth: "auth2" } });

      const subs = await getUserSubscriptions(user.id);
      const matching = subs.filter(s => s.endpoint === endpoint);

      expect(matching.length).toBe(1);
      expect(matching[0].keys.p256dh).toBe("key2");
    });
  });

  describe("Mark as read", () => {
    it("concurrent mark-read calls succeed", async () => {
      // Action: mark same channel read 5 times concurrently
      // Assert: all succeed, unread count is 0

      await Promise.all(Array(5).fill(null).map(() =>
        markChannelRead(channel.id, user.id, 100)
      ));

      const unread = await getUnreadCount(channel.id, user.id);
      expect(unread).toBe(0);
    });
  });
});
```
</action>
<verify>
```bash
npm run test -- tests/concurrency/idempotency.test.ts
```
</verify>
<done>
- [ ] Notification settings idempotency tested
- [ ] Channel join idempotency tested
- [ ] Channel leave idempotency tested
- [ ] Push subscription idempotency tested
- [ ] Mark read idempotency tested
- [ ] All tests pass
</done>
</task>

## Verification

### must_haves

```yaml
truths:
  - "Message sequences have no gaps under concurrency"
  - "Reaction toggles are idempotent"
  - "Channel membership has no duplicates"
  - "Push subscriptions update rather than duplicate"

artifacts:
  - path: tests/concurrency/message-sequence.test.ts
    validates: ["Message sequences have no gaps under concurrency"]
  - path: tests/concurrency/reaction-toggle.test.ts
    validates: ["Reaction toggles are idempotent"]
  - path: tests/concurrency/idempotency.test.ts
    validates: ["Channel membership has no duplicates", "Push subscriptions update"]
```

### Verification Commands

```bash
npm run test -- tests/concurrency/
```

## Notes

These tests may require:
- Real database connection (not mocked) for true concurrency testing
- Transaction isolation verification
- Potential use of `Promise.all` with slight delays to simulate realistic race conditions

Consider adding a `test:concurrency` script that runs these against a test database.
