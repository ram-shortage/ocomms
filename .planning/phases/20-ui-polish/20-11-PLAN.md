# Plan 20-11: Offline & PWA Tests

## Frontmatter

```yaml
phase: 20
plan: 11
title: Offline & PWA Tests
objective: Test offline queueing, IndexedDB caching, service worker behavior, and PWA functionality
wave: 3
depends_on: []
autonomous: true
estimated_tasks: 4
files_modified:
  - src/lib/__tests__/offline-queue.test.ts
  - src/lib/__tests__/message-cache.test.ts
  - tests/pwa/service-worker.test.ts
  - tests/pwa/install-prompt.test.ts
```

## Context

Tests for PWA and offline functionality:
- Offline message queue (add, process, retry)
- IndexedDB message cache (read, write, cleanup)
- Service worker caching and updates
- PWA install prompt and iOS guidance

Note: Some tests require browser environment or Playwright for full e2e.

## Tasks

### Task 1: Offline Queue Tests

<task id="1">
<title>Offline message queue tests</title>
<files>
- src/lib/__tests__/offline-queue.test.ts
</files>
<action>
Test the offline send queue functionality:

1. **Queue operations**
   - Add message to queue
   - Get pending messages
   - Remove message from queue
   - Update message status

2. **Processing logic**
   - Process queue when online
   - Skip processing when offline
   - Retry failed messages with backoff

3. **Persistence**
   - Queue survives page reload (IndexedDB)
   - Queue cleared after successful send

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import {
  addToQueue,
  getQueuedMessages,
  processQueue,
  removeFromQueue,
  updateQueueStatus
} from "../offline-queue";

// Mock IndexedDB with fake-indexeddb
import "fake-indexeddb/auto";

// Mock navigator.onLine
const mockOnline = vi.fn(() => true);
Object.defineProperty(navigator, 'onLine', { get: mockOnline });

describe("Offline Queue", () => {
  beforeEach(async () => {
    // Clear queue before each test
    const db = await openQueueDB();
    await db.clear('sendQueue');
  });

  describe("Queue operations", () => {
    it("adds message to queue", async () => {
      const message = {
        id: "temp-1",
        content: "Hello",
        channelId: "ch-1",
        createdAt: new Date().toISOString(),
      };

      await addToQueue(message);

      const queued = await getQueuedMessages();
      expect(queued).toHaveLength(1);
      expect(queued[0].content).toBe("Hello");
    });

    it("gets pending messages for channel", async () => {
      await addToQueue({ id: "1", content: "A", channelId: "ch-1" });
      await addToQueue({ id: "2", content: "B", channelId: "ch-2" });
      await addToQueue({ id: "3", content: "C", channelId: "ch-1" });

      const ch1Messages = await getQueuedMessages("ch-1");
      expect(ch1Messages).toHaveLength(2);
    });

    it("removes message from queue", async () => {
      await addToQueue({ id: "1", content: "Test", channelId: "ch-1" });

      await removeFromQueue("1");

      const queued = await getQueuedMessages();
      expect(queued).toHaveLength(0);
    });

    it("updates message status", async () => {
      await addToQueue({ id: "1", content: "Test", channelId: "ch-1" });

      await updateQueueStatus("1", "failed", { retries: 1 });

      const queued = await getQueuedMessages();
      expect(queued[0].status).toBe("failed");
      expect(queued[0].retries).toBe(1);
    });
  });

  describe("Processing logic", () => {
    it("processes queue when online", async () => {
      mockOnline.mockReturnValue(true);
      const sendFn = vi.fn().mockResolvedValue({ success: true });

      await addToQueue({ id: "1", content: "Test", channelId: "ch-1" });
      await processQueue(sendFn);

      expect(sendFn).toHaveBeenCalled();
      const queued = await getQueuedMessages();
      expect(queued).toHaveLength(0); // Removed after success
    });

    it("skips processing when offline", async () => {
      mockOnline.mockReturnValue(false);
      const sendFn = vi.fn();

      await addToQueue({ id: "1", content: "Test", channelId: "ch-1" });
      await processQueue(sendFn);

      expect(sendFn).not.toHaveBeenCalled();
    });

    it("retries failed messages with exponential backoff", async () => {
      mockOnline.mockReturnValue(true);
      const sendFn = vi.fn()
        .mockRejectedValueOnce(new Error("Network error"))
        .mockResolvedValueOnce({ success: true });

      await addToQueue({ id: "1", content: "Test", channelId: "ch-1" });

      // First attempt - fails
      await processQueue(sendFn);
      let queued = await getQueuedMessages();
      expect(queued[0].retries).toBe(1);
      expect(queued[0].nextRetryAt).toBeGreaterThan(Date.now());

      // Wait for backoff and retry
      vi.advanceTimersByTime(5000);
      await processQueue(sendFn);

      queued = await getQueuedMessages();
      expect(queued).toHaveLength(0); // Success on retry
    });

    it("gives up after max retries", async () => {
      mockOnline.mockReturnValue(true);
      const sendFn = vi.fn().mockRejectedValue(new Error("Network error"));

      await addToQueue({ id: "1", content: "Test", channelId: "ch-1" });

      // Exhaust retries (default 5)
      for (let i = 0; i < 6; i++) {
        await processQueue(sendFn);
        vi.advanceTimersByTime(60000); // Advance past backoff
      }

      const queued = await getQueuedMessages();
      expect(queued[0].status).toBe("permanently_failed");
    });
  });
});
```
</action>
<verify>
```bash
npm run test -- src/lib/__tests__/offline-queue.test.ts
```
</verify>
<done>
- [ ] Add to queue tested
- [ ] Get pending tested
- [ ] Remove from queue tested
- [ ] Update status tested
- [ ] Online processing tested
- [ ] Offline skip tested
- [ ] Retry with backoff tested
- [ ] Max retries tested
- [ ] All tests pass
</done>
</task>

### Task 2: Message Cache Tests

<task id="2">
<title>IndexedDB message cache tests</title>
<files>
- src/lib/__tests__/message-cache.test.ts
</files>
<action>
Test IndexedDB message caching:

1. **Cache operations**
   - Write messages to cache
   - Read messages from cache
   - Query by channel with ordering

2. **Cache management**
   - Cleanup messages older than 7 days
   - Handle storage quota errors gracefully

3. **Normalization**
   - Flatten/unflatten message structure
   - Handle missing fields gracefully

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import {
  cacheMessages,
  getCachedMessages,
  clearOldMessages,
  getCacheStats,
} from "../message-cache";

import "fake-indexeddb/auto";

describe("Message Cache", () => {
  beforeEach(async () => {
    const db = await openCacheDB();
    await db.clear('messages');
  });

  describe("Cache operations", () => {
    it("writes messages to cache", async () => {
      const messages = [
        { id: "1", content: "Hello", channelId: "ch-1", sequence: 1 },
        { id: "2", content: "World", channelId: "ch-1", sequence: 2 },
      ];

      await cacheMessages(messages);

      const cached = await getCachedMessages("ch-1");
      expect(cached).toHaveLength(2);
    });

    it("reads messages ordered by sequence", async () => {
      await cacheMessages([
        { id: "2", content: "Second", channelId: "ch-1", sequence: 2 },
        { id: "1", content: "First", channelId: "ch-1", sequence: 1 },
        { id: "3", content: "Third", channelId: "ch-1", sequence: 3 },
      ]);

      const cached = await getCachedMessages("ch-1");
      expect(cached[0].content).toBe("First");
      expect(cached[1].content).toBe("Second");
      expect(cached[2].content).toBe("Third");
    });

    it("respects limit parameter", async () => {
      await cacheMessages(
        Array(100).fill(null).map((_, i) => ({
          id: String(i),
          content: `Message ${i}`,
          channelId: "ch-1",
          sequence: i,
        }))
      );

      const cached = await getCachedMessages("ch-1", { limit: 20 });
      expect(cached).toHaveLength(20);
    });

    it("updates existing messages", async () => {
      await cacheMessages([
        { id: "1", content: "Original", channelId: "ch-1", sequence: 1 },
      ]);

      await cacheMessages([
        { id: "1", content: "Updated", channelId: "ch-1", sequence: 1 },
      ]);

      const cached = await getCachedMessages("ch-1");
      expect(cached).toHaveLength(1);
      expect(cached[0].content).toBe("Updated");
    });
  });

  describe("Cache management", () => {
    it("clears messages older than 7 days", async () => {
      const oldDate = new Date();
      oldDate.setDate(oldDate.getDate() - 8);

      const recentDate = new Date();
      recentDate.setDate(recentDate.getDate() - 1);

      await cacheMessages([
        { id: "old", content: "Old", channelId: "ch-1", sequence: 1, cachedAt: oldDate },
        { id: "recent", content: "Recent", channelId: "ch-1", sequence: 2, cachedAt: recentDate },
      ]);

      await clearOldMessages(7);

      const cached = await getCachedMessages("ch-1");
      expect(cached).toHaveLength(1);
      expect(cached[0].content).toBe("Recent");
    });

    it("handles storage quota gracefully", async () => {
      // Mock storage quota error
      const originalPut = IDBObjectStore.prototype.put;
      IDBObjectStore.prototype.put = vi.fn().mockImplementation(() => {
        throw new DOMException("QuotaExceededError");
      });

      const result = await cacheMessages([
        { id: "1", content: "Test", channelId: "ch-1", sequence: 1 },
      ]);

      expect(result.success).toBe(false);
      expect(result.error).toBe("quota_exceeded");

      IDBObjectStore.prototype.put = originalPut;
    });
  });

  describe("Normalization", () => {
    it("flattens nested author object for storage", async () => {
      await cacheMessages([
        {
          id: "1",
          content: "Hello",
          channelId: "ch-1",
          sequence: 1,
          author: { id: "u1", name: "Alice", image: "/alice.jpg" },
        },
      ]);

      const cached = await getCachedMessages("ch-1");
      expect(cached[0].author.name).toBe("Alice");
    });

    it("handles missing author gracefully", async () => {
      await cacheMessages([
        { id: "1", content: "Hello", channelId: "ch-1", sequence: 1 },
      ]);

      const cached = await getCachedMessages("ch-1");
      expect(cached[0].author).toBeUndefined();
    });
  });
});
```
</action>
<verify>
```bash
npm run test -- src/lib/__tests__/message-cache.test.ts
```
</verify>
<done>
- [ ] Write to cache tested
- [ ] Read with ordering tested
- [ ] Limit parameter tested
- [ ] Update existing tested
- [ ] 7-day cleanup tested
- [ ] Quota error handling tested
- [ ] Normalization tested
- [ ] All tests pass
</done>
</task>

### Task 3: Service Worker Tests

<task id="3">
<title>Service worker behavior tests</title>
<files>
- tests/pwa/service-worker.test.ts
</files>
<action>
Test service worker caching and update behavior.

Note: These tests require a browser environment. Use Playwright or similar.

```typescript
import { test, expect } from "@playwright/test";

test.describe("Service Worker", () => {
  test.describe("Installation", () => {
    test("service worker installs and activates", async ({ page }) => {
      await page.goto("/");

      // Wait for SW to be ready
      const swReady = await page.evaluate(async () => {
        const reg = await navigator.serviceWorker.ready;
        return reg.active !== null;
      });

      expect(swReady).toBe(true);
    });

    test("app shell is cached after first visit", async ({ page }) => {
      await page.goto("/");

      // Check cache contents
      const cached = await page.evaluate(async () => {
        const cache = await caches.open("app-shell-v1");
        const keys = await cache.keys();
        return keys.map(k => k.url);
      });

      expect(cached).toContain(expect.stringContaining("/_next/static"));
    });
  });

  test.describe("Offline behavior", () => {
    test("serves cached page when offline", async ({ page, context }) => {
      // First visit (online) to cache
      await page.goto("/");
      await page.waitForSelector("[data-testid='app-loaded']");

      // Go offline
      await context.setOffline(true);

      // Reload should work from cache
      await page.reload();
      await expect(page.locator("[data-testid='app-loaded']")).toBeVisible();
    });

    test("shows offline page for uncached routes", async ({ page, context }) => {
      await page.goto("/");
      await context.setOffline(true);

      // Navigate to uncached route
      await page.goto("/some-uncached-route");

      await expect(page.locator("text=You're offline")).toBeVisible();
    });
  });

  test.describe("Update flow", () => {
    test("detects new service worker version", async ({ page }) => {
      await page.goto("/");

      // Simulate new SW version (in real test, deploy new version)
      const hasUpdate = await page.evaluate(async () => {
        const reg = await navigator.serviceWorker.ready;
        await reg.update();
        return reg.waiting !== null || reg.installing !== null;
      });

      // This would be true if a new version was deployed
      // For unit test, we just verify the check doesn't error
      expect(typeof hasUpdate).toBe("boolean");
    });

    test("update notification appears when new version ready", async ({ page }) => {
      await page.goto("/");

      // Trigger update notification (mock)
      await page.evaluate(() => {
        window.dispatchEvent(new CustomEvent("sw-update-available"));
      });

      await expect(page.locator("text=Update available")).toBeVisible();
    });

    test("clicking update reloads with new version", async ({ page }) => {
      await page.goto("/");

      // Show update notification
      await page.evaluate(() => {
        window.dispatchEvent(new CustomEvent("sw-update-available"));
      });

      // Click update
      await page.click("button:has-text('Update')");

      // Should reload (verify by checking page loaded)
      await page.waitForNavigation();
      await expect(page.locator("[data-testid='app-loaded']")).toBeVisible();
    });
  });
});
```
</action>
<verify>
```bash
npx playwright test tests/pwa/service-worker.test.ts
```
</verify>
<done>
- [ ] SW installation tested
- [ ] App shell caching tested
- [ ] Offline page serving tested
- [ ] Uncached route offline tested
- [ ] Update detection tested
- [ ] Update notification tested
- [ ] Update reload tested
- [ ] All tests pass
</done>
</task>

### Task 4: PWA Install Prompt Tests

<task id="4">
<title>PWA install prompt and iOS guidance tests</title>
<files>
- tests/pwa/install-prompt.test.ts
</files>
<action>
Test PWA install prompt behavior:

```typescript
import { test, expect } from "@playwright/test";

test.describe("PWA Install Prompt", () => {
  test.describe("Chrome/Edge (beforeinstallprompt)", () => {
    test("shows install prompt after engagement threshold", async ({ page }) => {
      await page.goto("/");

      // Simulate engagement (3 page views)
      await page.goto("/channels/general");
      await page.goto("/channels/random");
      await page.goto("/channels/general");

      // Or 30 seconds on page
      await page.waitForTimeout(31000);

      // Install banner should appear
      await expect(page.locator("[data-testid='install-prompt']")).toBeVisible();
    });

    test("install button triggers browser prompt", async ({ page }) => {
      // Pre-set engagement
      await page.evaluate(() => {
        localStorage.setItem("pwa-engagement", JSON.stringify({ pageViews: 5 }));
      });

      await page.goto("/");

      // Click install
      const installButton = page.locator("[data-testid='install-button']");
      await installButton.click();

      // Browser prompt would appear (can't fully test in Playwright)
      // Verify our handler was called
      const promptCalled = await page.evaluate(() => {
        return (window as any).__installPromptCalled === true;
      });
      expect(promptCalled).toBe(true);
    });

    test("dismiss hides prompt for session", async ({ page }) => {
      await page.evaluate(() => {
        localStorage.setItem("pwa-engagement", JSON.stringify({ pageViews: 5 }));
      });

      await page.goto("/");

      // Dismiss
      await page.click("[data-testid='install-dismiss']");

      // Prompt should be hidden
      await expect(page.locator("[data-testid='install-prompt']")).not.toBeVisible();

      // Should stay hidden on reload (within session)
      await page.reload();
      await expect(page.locator("[data-testid='install-prompt']")).not.toBeVisible();
    });
  });

  test.describe("iOS Safari (manual install)", () => {
    test.use({
      userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1",
    });

    test("shows iOS-specific install guidance", async ({ page }) => {
      await page.evaluate(() => {
        localStorage.setItem("pwa-engagement", JSON.stringify({ pageViews: 5 }));
      });

      await page.goto("/");

      // Should show iOS guidance instead of install button
      await expect(page.locator("text=Add to Home Screen")).toBeVisible();
      await expect(page.locator("text=Share")).toBeVisible();
    });

    test("iOS guidance has step-by-step instructions", async ({ page }) => {
      await page.evaluate(() => {
        localStorage.setItem("pwa-engagement", JSON.stringify({ pageViews: 5 }));
      });

      await page.goto("/");

      await expect(page.locator("text=Tap the Share button")).toBeVisible();
      await expect(page.locator("text=Add to Home Screen")).toBeVisible();
    });
  });

  test.describe("Already installed", () => {
    test("hides install prompt when running as PWA", async ({ page }) => {
      // Simulate standalone mode
      await page.addInitScript(() => {
        Object.defineProperty(window, 'matchMedia', {
          value: (query: string) => ({
            matches: query === '(display-mode: standalone)',
            addListener: () => {},
            removeListener: () => {},
          }),
        });
      });

      await page.goto("/");

      // Install prompt should not appear
      await expect(page.locator("[data-testid='install-prompt']")).not.toBeVisible();
    });
  });
});
```
</action>
<verify>
```bash
npx playwright test tests/pwa/install-prompt.test.ts
```
</verify>
<done>
- [ ] Engagement threshold tested
- [ ] Install button tested
- [ ] Dismiss behavior tested
- [ ] iOS guidance tested
- [ ] iOS instructions tested
- [ ] Already installed detection tested
- [ ] All tests pass
</done>
</task>

## Verification

### must_haves

```yaml
truths:
  - "Offline queue persists across page reloads"
  - "Failed sends retry with exponential backoff"
  - "Message cache respects 7-day retention"
  - "Service worker serves cached content offline"
  - "Install prompt appears after engagement threshold"

artifacts:
  - path: src/lib/__tests__/offline-queue.test.ts
    validates: ["Queue persists", "Retry with backoff"]
  - path: src/lib/__tests__/message-cache.test.ts
    validates: ["7-day retention"]
  - path: tests/pwa/service-worker.test.ts
    validates: ["SW serves cached content offline"]
  - path: tests/pwa/install-prompt.test.ts
    validates: ["Install prompt after engagement"]
```

### Verification Commands

```bash
# Unit tests (with fake-indexeddb)
npm run test -- src/lib/__tests__/offline-queue.test.ts
npm run test -- src/lib/__tests__/message-cache.test.ts

# E2E tests (with Playwright)
npx playwright test tests/pwa/
```

## Notes

**Dependencies to install:**
- `npm install -D fake-indexeddb` for IndexedDB mocking in unit tests
- `npm install -D @playwright/test` for PWA e2e tests (if not already installed)

**Test environment:**
- Unit tests use fake-indexeddb to mock IndexedDB in Node
- E2E tests require a running app instance and real browser
