---
phase: 05-mentions-notifications
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/db/schema/notification.ts
  - src/db/schema/index.ts
  - src/lib/socket-events.ts
  - src/server/socket/handlers/notification.ts
  - src/server/socket/handlers/message.ts
  - src/server/socket/index.ts
  - src/components/notification/notification-list.tsx
  - src/components/notification/notification-bell.tsx
  - src/components/workspace/workspace-header.tsx
autonomous: true

must_haves:
  truths:
    - "Mentioned member receives real-time notification"
    - "@channel notifies all channel members except sender"
    - "@here notifies only active channel members except sender"
    - "Notification shows in notification bell dropdown"
    - "User can mark notifications as read"
  artifacts:
    - path: "src/db/schema/notification.ts"
      provides: "Notifications table schema"
      contains: "notifications"
    - path: "src/server/socket/handlers/notification.ts"
      provides: "Notification creation and delivery"
      exports: ["createNotifications", "handleNotificationEvents"]
    - path: "src/components/notification/notification-bell.tsx"
      provides: "Bell icon with unread count"
      min_lines: 40
    - path: "src/components/notification/notification-list.tsx"
      provides: "Dropdown list of notifications"
      min_lines: 60
  key_links:
    - from: "src/server/socket/handlers/message.ts"
      to: "src/server/socket/handlers/notification.ts"
      via: "createNotifications called after message save"
      pattern: "createNotifications"
    - from: "src/server/socket/handlers/notification.ts"
      to: "notification:new event"
      via: "Socket emit to user rooms"
      pattern: "notification:new"
    - from: "src/components/notification/notification-bell.tsx"
      to: "src/components/notification/notification-list.tsx"
      via: "Bell opens NotificationList popover"
      pattern: "NotificationList"
---

<objective>
Implement notification storage and real-time delivery for mentions.

Purpose: When a user is @mentioned, they receive a notification that persists and can be viewed later.

Output: Notification schema, creation logic, socket delivery, and UI components.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/5-mentions-notifications/05-01-SUMMARY.md
@src/lib/socket-events.ts
@src/server/socket/handlers/message.ts
@src/server/socket/handlers/presence.ts
@src/db/schema/channel.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Notification schema and socket events</name>
  <files>src/db/schema/notification.ts, src/db/schema/index.ts, src/lib/socket-events.ts</files>
  <action>
Create notification persistence and event types:

1. **notification.ts schema:**
```ts
notifications table:
- id: uuid, primary key, default random
- userId: uuid, FK to users (who receives), cascade delete
- type: text ("mention" | "channel" | "here" | "thread_reply")
- messageId: uuid, FK to messages (optional, null if message deleted)
- channelId: uuid, FK to channels (optional, for channel context)
- conversationId: uuid, FK to conversations (optional, for DM context)
- actorId: uuid, FK to users (who triggered), set null on delete
- content: text (preview of message, first 100 chars)
- readAt: timestamp (null = unread)
- createdAt: timestamp, default now

Indexes:
- userId + readAt index for unread queries
- userId + createdAt for chronological list
```

2. **Export from index.ts**

3. **socket-events.ts additions:**
```ts
interface Notification {
  id: string;
  type: "mention" | "channel" | "here" | "thread_reply";
  messageId: string | null;
  channelId: string | null;
  conversationId: string | null;
  actorId: string | null;
  actorName: string | null;
  content: string;
  channelName?: string;
  readAt: Date | null;
  createdAt: Date;
}

ServerToClientEvents:
- "notification:new": (notification: Notification) => void
- "notification:read": (data: { notificationId: string }) => void
- "notification:readAll": () => void

ClientToServerEvents:
- "notification:markRead": (data: { notificationId: string }) => void
- "notification:markAllRead": () => void
- "notification:fetch": (
    data: { limit?: number },
    callback: (response: { notifications: Notification[]; unreadCount: number }) => void
  ) => void
```

Pattern: Notifications stored per-user for persistence. Real-time delivery via user-specific socket room.
  </action>
  <verify>
TypeScript compiles. Schema exports correctly.
  </verify>
  <done>
Notification table schema defined with proper indexes and socket event types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Notification creation and delivery logic</name>
  <files>src/server/socket/handlers/notification.ts, src/server/socket/handlers/message.ts, src/server/socket/index.ts</files>
  <action>
Create notification handling:

1. **notification.ts handler:**

Create `createNotifications` function (not a socket handler, called by message handler):
```ts
async function createNotifications(params: {
  io: SocketIOServer;
  message: Message;
  mentions: ParsedMention[];
  senderId: string;
  channelId?: string;
  conversationId?: string;
  presenceManager: PresenceManager;
}): Promise<void>
```

Logic:
- Import parseMentions from lib/mentions
- For each mention:
  - If type === "user": Find user by username/name, create notification
  - If type === "channel": Get all channel members (excluding sender), create notification for each
  - If type === "here": Get all channel members, filter by active presence, create notification for active only
- Use batch insert for efficiency
- After insert, emit "notification:new" to each user's socket room (user:{userId})

Create socket event handlers:
- `notification:markRead`: Update readAt to now() where id matches and userId matches
- `notification:markAllRead`: Update readAt on all unread for user
- `notification:fetch`: Return notifications with actor info, ordered by createdAt desc, limit 50 default

2. **Update message.ts:**
- Import createNotifications
- After successful message:new broadcast, call createNotifications with parsed mentions
- Pass presenceManager for @here filtering

3. **Register in index.ts:**
- Import and call handleNotificationEvents

Pattern: Notification creation is a side effect of message creation, not a separate user action.
  </action>
  <verify>
Send message with @username - notification created in DB.
Send @channel - all members get notifications.
Send @here - only active members get notifications.
  </verify>
  <done>
Mentions trigger notification creation and real-time delivery.
  </done>
</task>

<task type="auto">
  <name>Task 3: Notification UI components</name>
  <files>src/components/notification/notification-bell.tsx, src/components/notification/notification-list.tsx, src/components/workspace/workspace-header.tsx</files>
  <action>
Create notification UI:

1. **notification-list.tsx:**
- Receive notifications array and onMarkRead callback
- Render list of notification items
- Each item shows:
  - Actor name/avatar initial
  - Type indicator (mention icon, channel icon)
  - Content preview (truncated)
  - Time ago
  - Click navigates to message (channel/conversation link)
- Mark as read on click (call onMarkRead)
- "Mark all as read" button at top
- Empty state: "No notifications"
- Style: unread items have subtle blue-left border

2. **notification-bell.tsx:**
- Bell icon with unread count badge
- On mount: socket.emit notification:fetch to get initial
- Listen for notification:new, add to state
- Listen for notification:read, notification:readAll to update state
- Click opens Popover with NotificationList
- Badge shows count (max 99+)
- Animate badge on new notification (pulse)

3. **Update workspace-header.tsx (or equivalent header):**
- Add NotificationBell to header bar next to user menu
- Position in top-right area

Pattern: Use shadcn Popover for dropdown. Notifications stored in component state, synced via socket.
  </action>
  <verify>
Manual verification:
- Bell icon visible in header
- Click bell opens notification dropdown
- Notifications appear with correct info
- Click notification marks as read
- New notification updates badge count
  </verify>
  <done>
Notification bell with dropdown showing mentions and unread count.
  </done>
</task>

</tasks>

<verification>
End-to-end verification:
1. User A sends message "@userB check this"
2. User B sees notification bell badge update
3. User B opens bell, sees notification from User A
4. User B clicks notification, marked as read
5. @channel message creates notifications for all channel members
6. @here message creates notifications for only active members
</verification>

<success_criteria>
- Notifications persisted in database
- Real-time delivery via WebSocket
- Bell icon shows unread count
- Notifications list displays with actor and content
- Mark as read functionality works
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/5-mentions-notifications/05-02-SUMMARY.md`
</output>
