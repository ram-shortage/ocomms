---
phase: 31-high-security-bug-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/socket/middleware/rate-limit.ts
  - src/server/socket/index.ts
  - src/lib/socket-client.ts
  - src/components/message/message-input.tsx
autonomous: true

must_haves:
  truths:
    - "Rapid-fire Socket.IO events (>30/sec) are blocked without affecting normal usage"
    - "User sees 'Slow down' toast when rate limited"
    - "Rate limit resets after cooldown period"
  artifacts:
    - path: "src/server/socket/middleware/rate-limit.ts"
      provides: "Socket.IO rate limiting middleware"
      exports: ["rateLimitMiddleware"]
    - path: "src/server/socket/index.ts"
      provides: "Socket.IO server with rate limiting applied"
      contains: "rateLimitMiddleware"
  key_links:
    - from: "src/server/socket/index.ts"
      to: "src/server/socket/middleware/rate-limit.ts"
      via: "middleware import and socket.use()"
      pattern: "socket\\.use.*rateLimitMiddleware"
    - from: "src/lib/socket-client.ts"
      to: "sonner toast"
      via: "rate-limit event handler"
      pattern: "socket\\.on.*rate-limit"
---

<objective>
Implement Socket.IO rate limiting to prevent rapid-fire event abuse.

Purpose: SEC2-04 requires rate limiting on all Socket.IO handlers (reactions, typing, presence, threads) to prevent DoS attacks and abuse. This protects server resources from malicious clients sending excessive events.

Output: Rate limiting middleware applied to all socket events, with user-friendly toast warnings when limits are hit.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/31-high-security-bug-fixes/31-CONTEXT.md
@.planning/phases/31-high-security-bug-fixes/31-RESEARCH.md
@src/server/socket/index.ts
@src/server/socket/middleware/auth.ts
@src/lib/socket-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limiting middleware</name>
  <files>
    src/server/socket/middleware/rate-limit.ts
    src/server/socket/index.ts
  </files>
  <action>
Create rate limiting middleware using rate-limiter-flexible (already installed v9.0.1).

In `src/server/socket/middleware/rate-limit.ts`:
- Import RateLimiterMemory from rate-limiter-flexible
- Create limiter with:
  - points: 30 (events per duration - lenient per CONTEXT.md)
  - duration: 1 (1 second window)
  - blockDuration: 5 (5 second cooldown after limit hit)
- Export middleware function that:
  - Uses socket.data.userId as key (not socket.id or IP - per RESEARCH.md pitfall #6)
  - On success: calls next()
  - On rate limit: emits 'rate-limit' event with { message: 'Slow down', retryAfter: msBeforeNext }
  - Does NOT call next() when rate limited (blocks the event)

In `src/server/socket/index.ts`:
- Import rateLimitMiddleware
- Apply as socket middleware AFTER auth middleware: `io.use(rateLimitMiddleware)`
- Ensure rate limiting applies to all events (global bucket per CONTEXT.md)

Pattern from RESEARCH.md:
```typescript
socket.use(async (event, next) => {
  try {
    await rateLimiter.consume(socket.data.userId);
    next();
  } catch (rateLimiterRes) {
    socket.emit('rate-limit', { ... });
    // Don't call next() - blocks the event
  }
});
```
  </action>
  <verify>
Run: `npm run build` - no TypeScript errors
Run: `npm test -- --grep "socket"` - existing socket tests still pass
  </verify>
  <done>
Rate limiting middleware created and applied to Socket.IO server.
All socket events are rate limited by userId with 30 events/second limit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add client-side rate limit handler</name>
  <files>
    src/lib/socket-client.ts
    src/components/message/message-input.tsx
  </files>
  <action>
Add rate limit event handler to socket client.

In `src/lib/socket-client.ts`:
- Add 'rate-limit' to socket event types if needed
- Add handler for 'rate-limit' event that shows toast using sonner (already imported in project)
- Toast should be subtle/warning style (not error), duration 3000ms
- Show message and retry time: "Slow down - Please wait Xs"

Pattern:
```typescript
import { toast } from 'sonner';

socket.on('rate-limit', (data: { message: string; retryAfter: number }) => {
  toast.warning(data.message, {
    description: `Please wait ${Math.ceil(data.retryAfter / 1000)}s`,
    duration: 3000
  });
});
```

In `src/lib/socket-events.ts` (if types file exists):
- Add 'rate-limit' to ServerToClientEvents type

Verify sonner import works (already used in src/app/layout.tsx line ~61).
  </action>
  <verify>
Run: `npm run build` - no TypeScript errors
Manual test: Open browser console, verify no errors on page load
  </verify>
  <done>
Client shows toast warning when rate limited.
Toast is subtle (warning style, not blocking).
User can continue working after cooldown.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add rate limiting tests</name>
  <files>
    src/server/socket/__tests__/rate-limit.test.ts
  </files>
  <action>
Create test file for rate limiting middleware.

Tests to implement:
1. "allows normal event rate (under limit)" - 10 events should all succeed
2. "blocks rapid-fire events (over limit)" - 50 events in 100ms should trigger rate limit
3. "emits rate-limit event when blocked" - verify event shape { message, retryAfter }
4. "rate limits by userId not socketId" - same userId on different sockets shares limit
5. "resets after cooldown period" - after blockDuration, events allowed again

Use vitest mocking patterns from existing socket tests:
- Mock Socket with data.userId
- Simulate rapid event calls
- Verify next() called/not called appropriately

Do NOT mock the actual rate-limiter-flexible - test real behavior.
  </action>
  <verify>
Run: `npm test src/server/socket/__tests__/rate-limit.test.ts` - all tests pass
  </verify>
  <done>
Rate limiting has comprehensive test coverage.
Tests verify:
- Normal usage is not affected
- Abuse is blocked
- Rate limit event is emitted correctly
- Per-user rate limiting works
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. All socket tests pass: `npm test -- --grep "socket"`
3. New rate limit tests pass: `npm test src/server/socket/__tests__/rate-limit.test.ts`
4. Manual verification in dev:
   - Start server: `npm run dev`
   - Open browser, connect to workspace
   - Normal typing/reactions should work
   - Rapid-fire events (via console) should trigger rate limit toast
</verification>

<success_criteria>
- Socket.IO rate limiting middleware exists and is applied
- Limit is 30 events/second per user (global bucket, not per-event-type)
- Rate limited users receive 'rate-limit' event
- Client shows warning toast when rate limited
- Normal usage (reasonable typing, reactions) is not affected
- Tests verify correct behavior
</success_criteria>

<output>
After completion, create `.planning/phases/31-high-security-bug-fixes/31-01-SUMMARY.md`
</output>
