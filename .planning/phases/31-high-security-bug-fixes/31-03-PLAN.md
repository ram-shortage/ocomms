---
phase: 31-high-security-bug-fixes
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/admin/export/route.ts
  - src/lib/audit-integrity.ts
  - src/lib/audit-logger.ts
  - src/app/api/admin/audit-logs/route.ts
  - .env.example
autonomous: true

must_haves:
  truths:
    - "Data export derives organizationId from authenticated user, not request body"
    - "Unauthorized export attempts return 403 and log security event"
    - "Audit logs include hash chain for tamper detection"
    - "Audit log viewer shows warning when integrity check fails"
  artifacts:
    - path: "src/app/api/admin/export/route.ts"
      provides: "Secure data export endpoint"
      contains: "membership.organizationId"
    - path: "src/lib/audit-integrity.ts"
      provides: "HMAC hash chain functions"
      exports: ["computeEntryHash", "verifyChain"]
  key_links:
    - from: "src/app/api/admin/export/route.ts"
      to: "members table query"
      via: "derive org from membership"
      pattern: "organizationMembers.*userId.*session"
    - from: "src/lib/audit-logger.ts"
      to: "src/lib/audit-integrity.ts"
      via: "hash computation on log write"
      pattern: "computeEntryHash"
---

<objective>
Fix data export authorization boundary and implement audit log integrity verification.

Purpose: SEC2-08 (data export) currently uses organizationId from request body - attacker could export any org's data. SEC2-07 (audit integrity) requires tamper detection for audit logs. Both are critical authorization/integrity issues.

Output: Secure export endpoint that derives org from session, audit logs with HMAC hash chain, integrity verification in log viewer.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/31-high-security-bug-fixes/31-CONTEXT.md
@.planning/phases/31-high-security-bug-fixes/31-RESEARCH.md
@src/app/api/admin/export/route.ts
@src/lib/audit-logger.ts
@src/app/api/admin/audit-logs/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix data export authorization boundary</name>
  <files>
    src/app/api/admin/export/route.ts
    src/app/api/admin/__tests__/export.test.ts
  </files>
  <action>
Fix SEC2-08: Data export must derive organizationId from authenticated user, not request body.

Current vulnerable code (line ~54):
```typescript
const body = await request.json();
const { organizationId } = body;  // VULNERABLE - attacker controlled!
```

Fix by deriving from session:

1. Remove organizationId from request body parsing
2. Get user's organization membership from database:
```typescript
import { members } from "@/db/schema";
import { eq } from "drizzle-orm";

// Get user's organization membership (owner role)
const ownerMembership = await db.query.members.findFirst({
  where: and(
    eq(members.userId, session.user.id),
    eq(members.role, "owner")
  ),
});

if (!ownerMembership) {
  // Log security event for unauthorized attempt
  await auditLog({
    eventType: AuditEventType.AUTHZ_FAILURE,
    userId: session.user.id,
    ip: getClientIP(await headers()),
    details: {
      action: "data_export",
      reason: "not_owner"
    }
  });
  return NextResponse.json(
    { error: "Only organization owners can export data" },
    { status: 403 }
  );
}

// Use ONLY the derived organizationId
const organizationId = ownerMembership.organizationId;
```

3. Remove the "verify organization exists" check (redundant - membership proves it exists)
4. Remove the "verify user is owner" check (already done above)

Update export test to verify:
- Export uses session-derived orgId, not request body
- Attempt to export different org returns 403
- Security event logged on unauthorized attempt
  </action>
  <verify>
Run: `npm run build` - no TypeScript errors
Run: `npm test src/app/api/admin/__tests__/export.test.ts` - export tests pass
  </verify>
  <done>
Data export derives organizationId from authenticated user's ownership.
Cannot export other organizations' data.
Unauthorized attempts logged as security events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create audit log integrity library</name>
  <files>
    src/lib/audit-integrity.ts
    .env.example
  </files>
  <action>
Create hash chain implementation for audit log integrity (SEC2-07).

In `.env.example`, add:
```
# Audit log integrity (generate with: openssl rand -hex 32)
AUDIT_LOG_SECRET=your-secret-here
```

Create `src/lib/audit-integrity.ts`:
```typescript
import crypto from 'crypto';

interface AuditEntryData {
  id?: string;
  timestamp: string;
  eventType: string;
  userId?: string;
  organizationId?: string;
  details?: Record<string, unknown>;
}

/**
 * Compute HMAC-SHA256 hash for audit entry.
 * Links to previous entry via previousHash for tamper detection.
 */
export function computeEntryHash(
  entry: AuditEntryData,
  previousHash: string
): string {
  const secret = process.env.AUDIT_LOG_SECRET;
  if (!secret) {
    console.warn('AUDIT_LOG_SECRET not set - audit log integrity disabled');
    return '';
  }

  // Deterministic serialization for hash computation
  const data = JSON.stringify({
    timestamp: entry.timestamp,
    eventType: entry.eventType,
    userId: entry.userId || null,
    organizationId: entry.organizationId || null,
    previousHash
  });

  return crypto
    .createHmac('sha256', secret)
    .update(data)
    .digest('hex');
}

/**
 * Verify hash chain integrity for a sequence of audit entries.
 * Returns { valid: boolean, brokenAt?: number }
 */
export function verifyChain(
  entries: Array<AuditEntryData & { hash?: string; previousHash?: string }>
): { valid: boolean; brokenAt?: number } {
  const secret = process.env.AUDIT_LOG_SECRET;
  if (!secret) {
    // If no secret configured, can't verify - assume valid
    return { valid: true };
  }

  for (let i = 0; i < entries.length; i++) {
    const entry = entries[i];
    if (!entry.hash) continue; // Skip entries without hash (pre-migration)

    const expectedPreviousHash = i === 0 ? '' : (entries[i - 1].hash || '');
    const computedHash = computeEntryHash(entry, entry.previousHash || '');

    // Use timing-safe comparison
    try {
      const isValid = crypto.timingSafeEqual(
        Buffer.from(computedHash, 'hex'),
        Buffer.from(entry.hash, 'hex')
      );
      if (!isValid) {
        return { valid: false, brokenAt: i };
      }
    } catch {
      // Buffer length mismatch or invalid hex
      return { valid: false, brokenAt: i };
    }
  }

  return { valid: true };
}
```

Key points per RESEARCH.md:
- Use crypto.timingSafeEqual to prevent timing attacks
- Empty previousHash for first entry (bootstrap problem pitfall #4)
- Handle missing AUDIT_LOG_SECRET gracefully
  </action>
  <verify>
Run: `npm run build` - no TypeScript errors
  </verify>
  <done>
Audit integrity library created with HMAC hash chain.
Uses crypto.timingSafeEqual for timing-safe comparison.
Handles bootstrap (first entry) and missing secret gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate hash chain into audit logging and viewer</name>
  <files>
    src/lib/audit-logger.ts
    src/app/api/admin/audit-logs/route.ts
    src/lib/__tests__/audit-integrity.test.ts
  </files>
  <action>
Integrate hash chain into audit logger and add verification to viewer.

In `src/lib/audit-logger.ts`:
1. Import computeEntryHash
2. Modify auditLog function to:
   - Read most recent entry's hash from today's log file
   - Compute new entry hash with previousHash
   - Include hash and previousHash in written entry

```typescript
import { computeEntryHash } from './audit-integrity';

// In auditLog function, before writing:
const lastHash = await getLastEntryHash(logPath);
const hash = computeEntryHash({ ...data, timestamp }, lastHash);
const event = {
  ...data,
  timestamp,
  previousHash: lastHash,
  hash
};
```

Helper to get last entry hash:
```typescript
async function getLastEntryHash(logPath: string): Promise<string> {
  try {
    if (!existsSync(logPath)) return '';
    const content = await readFile(logPath, 'utf-8');
    const lines = content.trim().split('\n').filter(l => l);
    if (lines.length === 0) return '';
    const lastEntry = JSON.parse(lines[lines.length - 1]);
    return lastEntry.hash || '';
  } catch {
    return '';
  }
}
```

In `src/app/api/admin/audit-logs/route.ts`:
1. Import verifyChain
2. After filtering events, verify chain integrity
3. Return isValid flag and warning message in response

```typescript
import { verifyChain } from '@/lib/audit-integrity';

// After filtering events:
const integrityResult = verifyChain(filteredEvents);

const response = {
  events: paginatedEvents,
  pagination: { ... },
  integrity: {
    valid: integrityResult.valid,
    warning: integrityResult.valid
      ? null
      : 'Audit log integrity check failed. Possible tampering detected.'
  }
};
```

Create `src/lib/__tests__/audit-integrity.test.ts`:
- "computes consistent hash for same input"
- "different input produces different hash"
- "verifies valid chain"
- "detects modified entry"
- "handles first entry (empty previousHash)"
- "handles missing AUDIT_LOG_SECRET gracefully"
  </action>
  <verify>
Run: `npm run build` - no TypeScript errors
Run: `npm test src/lib/__tests__/audit-integrity.test.ts` - integrity tests pass
Run: `npm test src/app/api/admin/__tests__/audit-logs.test.ts` - audit API tests pass
  </verify>
  <done>
Audit log entries include HMAC hash chain.
API returns integrity status with warning if tampering detected.
New entries link to previous via hash.
Tests verify chain integrity detection.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. All tests pass: `npm test`
3. Export security test passes: `npm test src/app/api/admin/__tests__/export.test.ts`
4. Integrity tests pass: `npm test src/lib/__tests__/audit-integrity.test.ts`
5. Manual verification:
   - Export endpoint only allows owner's organization
   - Audit logs include hash field
   - Modifying log file triggers integrity warning
</verification>

<success_criteria>
- Data export derives organizationId from session, never from request
- Unauthorized export attempts return 403 and log security event
- Audit log entries include previousHash and hash fields
- Audit log API returns integrity check result
- Integrity check uses timing-safe comparison
- First entry (no previous) handled correctly
</success_criteria>

<output>
After completion, create `.planning/phases/31-high-security-bug-fixes/31-03-SUMMARY.md`
</output>
