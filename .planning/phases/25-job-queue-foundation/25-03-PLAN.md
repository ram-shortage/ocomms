---
phase: 25-job-queue-foundation
plan: 03
type: execute
wave: 2
depends_on: ["25-01", "25-02"]
files_modified:
  - src/lib/actions/scheduled-message.ts
  - src/components/schedule/schedule-send-dropdown.tsx
  - src/components/schedule/scheduled-messages-list.tsx
  - src/components/schedule/scheduled-message-edit-dialog.tsx
  - src/components/message/message-input.tsx
  - src/components/workspace/workspace-sidebar.tsx
  - src/workers/scheduled-message.worker.ts
  - src/workers/index.ts
  - src/server/socket/handlers/message.ts
autonomous: true

must_haves:
  truths:
    - "User can schedule a message for a specific date/time from compose area"
    - "User can view list of pending scheduled messages in sidebar"
    - "User can edit scheduled message content before send time"
    - "User can cancel a scheduled message"
    - "Scheduled message sends automatically at the scheduled time"
    - "Scheduled messages work for both channels and DMs"
  artifacts:
    - path: "src/lib/actions/scheduled-message.ts"
      provides: "Server actions for scheduled message CRUD"
      exports: ["createScheduledMessage", "getScheduledMessages", "updateScheduledMessage", "cancelScheduledMessage", "sendScheduledMessageNow"]
    - path: "src/components/schedule/schedule-send-dropdown.tsx"
      provides: "Dropdown for scheduling with quick-pick presets"
      min_lines: 80
    - path: "src/components/schedule/scheduled-messages-list.tsx"
      provides: "List view of pending scheduled messages"
      min_lines: 50
    - path: "src/workers/scheduled-message.worker.ts"
      provides: "Worker processor for sending scheduled messages"
      min_lines: 60
  key_links:
    - from: "src/components/schedule/schedule-send-dropdown.tsx"
      to: "src/lib/actions/scheduled-message.ts"
      via: "createScheduledMessage action call"
      pattern: "createScheduledMessage"
    - from: "src/workers/scheduled-message.worker.ts"
      to: "src/db/schema/scheduled-message.ts"
      via: "database queries"
      pattern: "scheduledMessages"
    - from: "src/components/message/message-input.tsx"
      to: "src/components/schedule/schedule-send-dropdown.tsx"
      via: "component composition"
      pattern: "ScheduleSendDropdown"
---

<objective>
Implement scheduled messages feature: users can compose messages and schedule them for future delivery with full management capabilities.

Purpose: Enables users to compose messages at convenient times and have them delivered at optimal times (e.g., schedule at 11pm to send at 9am when team is active).

Output: Complete scheduled messages feature with UI, server actions, and worker processing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-job-queue-foundation/25-RESEARCH.md
@.planning/phases/25-job-queue-foundation/25-CONTEXT.md
@.planning/phases/25-job-queue-foundation/25-01-SUMMARY.md
@.planning/phases/25-job-queue-foundation/25-02-SUMMARY.md

# Existing patterns
@src/lib/actions/channel.ts
@src/components/message/message-input.tsx
@src/server/socket/handlers/message.ts
@src/lib/socket-events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scheduled message server actions</name>
  <files>
    - src/lib/actions/scheduled-message.ts
  </files>
  <action>
    Create src/lib/actions/scheduled-message.ts with "use server" directive:

    1. **createScheduledMessage(data)**:
       - Verify auth session
       - Validate: content not empty, scheduledFor is in future
       - Either channelId or conversationId must be provided (not both, not neither)
       - If channel: verify user is channel member
       - If DM: verify user is conversation participant
       - Insert into scheduledMessages with status "pending"
       - Add delayed job to scheduledMessageQueue:
         ```typescript
         const delay = scheduledFor.getTime() - Date.now();
         const job = await scheduledMessageQueue.add(
           "send",
           { scheduledMessageId: scheduled.id },
           { delay, jobId: `scheduled-${scheduled.id}` }
         );
         ```
       - Update record with jobId
       - Return scheduled message

    2. **getScheduledMessages()**:
       - Get auth session
       - Query scheduledMessages where authorId = user.id AND status = "pending"
       - Order by scheduledFor ascending
       - Include channel/conversation relations for display
       - Return list

    3. **updateScheduledMessage(id, { content?, scheduledFor? })**:
       - Verify auth session
       - Verify user is author
       - Verify status is "pending"
       - Update record
       - If scheduledFor changed:
         - Remove old job: `scheduledMessageQueue.remove(oldJobId)`
         - Add new job with updated delay
         - Update jobId in record
       - Return updated record

    4. **cancelScheduledMessage(id)**:
       - Verify auth session
       - Verify user is author
       - Verify status is "pending"
       - Remove job from queue: `scheduledMessageQueue.remove(jobId)`
       - Update status to "cancelled"
       - Return success

    5. **sendScheduledMessageNow(id)**:
       - Verify auth session
       - Verify user is author
       - Verify status is "pending"
       - Remove delayed job
       - Add immediate job (no delay)
       - Return success

    Import patterns from existing actions (channel.ts) for auth and validation.
  </action>
  <verify>
    - File exists at src/lib/actions/scheduled-message.ts
    - `npx tsc --noEmit` passes
    - All 5 actions exported
  </verify>
  <done>Server actions for creating, listing, updating, canceling scheduled messages</done>
</task>

<task type="auto">
  <name>Task 2: Create schedule send UI components</name>
  <files>
    - src/components/schedule/schedule-send-dropdown.tsx
    - src/components/schedule/scheduled-messages-list.tsx
    - src/components/schedule/scheduled-message-edit-dialog.tsx
    - src/components/message/message-input.tsx
    - src/components/workspace/workspace-sidebar.tsx
  </files>
  <action>
    1. **Create src/components/schedule/schedule-send-dropdown.tsx**:
       - "use client" component
       - Props: onSendNow, onSchedule(date), disabled
       - UI: Split button pattern (like Gmail):
         - Main button: Send icon, calls onSendNow
         - Dropdown trigger: ChevronDown, opens Popover
       - Popover content:
         - "Tomorrow at 9:00 AM" - quick pick (addDays + setHours from date-fns)
         - "Monday at 9:00 AM" - quick pick (nextMonday + setHours)
         - Divider
         - "Custom time..." - shows datetime-local input
       - When scheduled, call onSchedule with Date object
       - Use existing Popover and Button components
       - Pattern from research section of 25-RESEARCH.md

    2. **Create src/components/schedule/scheduled-messages-list.tsx**:
       - "use client" component
       - Fetch scheduled messages via server action on mount
       - Display list with:
         - Message content preview (truncate at ~100 chars)
         - Scheduled time (format: "Tomorrow at 9:00 AM" or "Jan 25 at 3:30 PM")
         - Destination (channel name or DM participant names)
       - Each item has actions: Edit, Cancel, Send Now
       - Empty state: "No scheduled messages"
       - Loading state with skeleton

    3. **Create src/components/schedule/scheduled-message-edit-dialog.tsx**:
       - Dialog for editing scheduled message
       - Textarea for content
       - datetime-local input for new time
       - Save/Cancel buttons
       - Calls updateScheduledMessage action

    4. **Update src/components/message/message-input.tsx**:
       - Import ScheduleSendDropdown
       - Replace current Send button with ScheduleSendDropdown
       - onSendNow: existing send logic
       - onSchedule: call createScheduledMessage with content, targetId, targetType, scheduledFor
       - Clear content after scheduling (like after send)
       - Show toast on schedule success: "Message scheduled for {time}"

    5. **Update src/components/workspace/workspace-sidebar.tsx**:
       - Add "Scheduled" link in sidebar (below DMs or in a new section)
       - Icon: Clock from lucide-react
       - Links to scheduled messages list view
       - Show count badge if pending > 0

    Per 25-CONTEXT.md:
    - Schedule dropdown like Gmail's "Schedule send"
    - Quick-pick presets: Tomorrow 9am, Monday 9am, Custom (deliberately minimal)
    - Timezone handling: implicit (browser's timezone), no zone indicator displayed
  </action>
  <verify>
    - All component files exist
    - `npx tsc --noEmit` passes
    - Message input shows split send button
    - Dropdown shows quick-picks and custom option
  </verify>
  <done>Schedule send dropdown integrated into message input, scheduled messages list in sidebar</done>
</task>

<task type="auto">
  <name>Task 3: Implement worker processor for scheduled messages</name>
  <files>
    - src/workers/scheduled-message.worker.ts
    - src/workers/index.ts
  </files>
  <action>
    1. **Create src/workers/scheduled-message.worker.ts**:
       - Export createScheduledMessageWorker function
       - Create Worker for "scheduled-messages" queue
       - Processor logic:
         ```typescript
         async (job) => {
           const { scheduledMessageId } = job.data;

           // 1. Fetch from DB
           const scheduled = await db.query.scheduledMessages.findFirst({
             where: eq(scheduledMessages.id, scheduledMessageId),
           });

           if (!scheduled || scheduled.status !== "pending") {
             return { skipped: true, reason: "Not pending" };
           }

           // 2. Update to processing
           await db.update(scheduledMessages)
             .set({ status: "processing" })
             .where(eq(scheduledMessages.id, scheduledMessageId));

           try {
             // 3. Get next sequence number (atomic)
             const targetId = scheduled.channelId || scheduled.conversationId;
             const targetType = scheduled.channelId ? "channel" : "dm";

             // Use same sequence logic as message handler
             const maxSeq = await getMaxSequence(targetId, targetType);
             const sequence = maxSeq + 1;

             // 4. Create actual message
             const [newMessage] = await db.insert(messages).values({
               content: scheduled.content,
               authorId: scheduled.authorId,
               channelId: scheduled.channelId,
               conversationId: scheduled.conversationId,
               sequence,
             }).returning();

             // 5. Mark as sent
             await db.update(scheduledMessages)
               .set({
                 status: "sent",
                 sentAt: new Date(),
                 messageId: newMessage.id,
               })
               .where(eq(scheduledMessages.id, scheduledMessageId));

             // 6. Broadcast to room via Socket.IO Redis adapter
             await broadcastMessage(newMessage, targetId, targetType);

             return { success: true, messageId: newMessage.id };
           } catch (error) {
             await db.update(scheduledMessages)
               .set({ status: "failed", error: String(error) })
               .where(eq(scheduledMessages.id, scheduledMessageId));
             throw error; // Re-throw for BullMQ retry
           }
         }
         ```

       - For Socket.IO broadcast from worker, use emitter pattern from research:
         ```typescript
         import { Emitter } from "@socket.io/redis-emitter";
         import { Redis } from "ioredis";

         const redis = new Redis(process.env.REDIS_URL!);
         const emitter = new Emitter(redis);

         function broadcastMessage(message, targetId, targetType) {
           const room = targetType === "channel" ? `channel:${targetId}` : `dm:${targetId}`;
           emitter.to(room).emit("message:new", {
             ...message,
             createdAt: message.createdAt,
             updatedAt: message.updatedAt,
           });
         }
         ```

       Note: Install @socket.io/redis-emitter: `npm install @socket.io/redis-emitter`

    2. **Update src/workers/index.ts**:
       - Import createScheduledMessageWorker
       - Replace placeholder with real worker
       - Add to shutdown handler
  </action>
  <verify>
    - Worker file exists at src/workers/scheduled-message.worker.ts
    - `npm install @socket.io/redis-emitter` succeeds
    - `npx tsc --noEmit` passes
    - Worker starts without errors: `npm run worker`
  </verify>
  <done>Worker processes scheduled messages, creates message in DB, broadcasts via Socket.IO</done>
</task>

</tasks>

<verification>
1. Manual test: Schedule a message for 1 minute in future
2. Wait for scheduled time
3. Message appears in channel
4. View scheduled messages list shows pending items
5. Edit/cancel work before send time
6. "Send now" delivers immediately
</verification>

<success_criteria>
- SCHD-01: Can schedule message for specific date/time via dropdown
- SCHD-02: Can view list of scheduled messages in sidebar
- SCHD-03: Can edit scheduled message content before send time
- SCHD-04: Can cancel scheduled message
- SCHD-05: Works for both channels and DMs (channelId or conversationId)
- SCHD-06: Timezone-aware (datetime-local uses browser timezone, stored as UTC)
- SCHD-07: Quick-pick presets available (Tomorrow 9am, Monday 9am)
- Worker processes jobs and broadcasts via Socket.IO
</success_criteria>

<output>
After completion, create `.planning/phases/25-job-queue-foundation/25-03-SUMMARY.md`
</output>
