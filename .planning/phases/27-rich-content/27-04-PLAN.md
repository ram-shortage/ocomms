---
phase: 27-rich-content
plan: 04
type: execute
wave: 2
depends_on: [27-01]
files_modified:
  - src/app/api/upload/emoji/route.ts
  - src/lib/actions/custom-emoji.ts
  - src/lib/file-validation.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "User can upload custom emoji images PNG/JPG/GIF up to 128KB (EMOJ-01)"
    - "SVG uploads are converted to PNG for XSS protection (EMOJ-08)"
    - "Animated GIFs are supported (EMOJ-07)"
    - "Emoji names are unique within workspace (EMOJ-04)"
    - "User can delete own uploaded emoji (EMOJ-06)"
  artifacts:
    - path: "src/app/api/upload/emoji/route.ts"
      provides: "Emoji upload endpoint with SVG conversion"
      exports: ["POST"]
      min_lines: 60
    - path: "src/lib/actions/custom-emoji.ts"
      provides: "Server actions for emoji CRUD"
      exports: ["getWorkspaceEmojis", "deleteCustomEmoji"]
  key_links:
    - from: "src/app/api/upload/emoji/route.ts"
      to: "sharp"
      via: "SVG-to-PNG conversion"
      pattern: "sharp.*png"
    - from: "src/lib/actions/custom-emoji.ts"
      to: "src/db/schema/custom-emoji.ts"
      via: "database queries"
      pattern: "customEmojis"
---

<objective>
Build custom emoji backend with upload endpoint, SVG-to-PNG conversion, and CRUD actions.

Purpose: Allow workspace admins and channel creators to upload custom emoji with secure file handling (EMOJ-01, EMOJ-06, EMOJ-08).
Output: API endpoint for emoji upload and server actions for listing/deleting emoji.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/27-rich-content/27-CONTEXT.md
@.planning/phases/27-rich-content/27-RESEARCH.md
@.planning/phases/27-rich-content/27-01-SUMMARY.md

Reference existing patterns:
@src/app/api/upload/attachment/route.ts
@src/lib/file-validation.ts
@src/lib/actions/reminder.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install sharp and extend file validation</name>
  <files>package.json, src/lib/file-validation.ts</files>
  <action>
**Install sharp:**
```bash
npm install sharp
```

**Extend src/lib/file-validation.ts** to support SVG detection for emoji:

Add SVG signature detection to validateFileSignature function:
```typescript
// SVG: <?xml or <svg (text-based, check first bytes for common patterns)
// Note: SVG detection is approximate since it's XML text
const textStart = new TextDecoder().decode(bytes.slice(0, 100));
if (
  textStart.trim().startsWith('<?xml') ||
  textStart.trim().startsWith('<svg') ||
  textStart.includes('<svg')
) {
  return { extension: "svg", mimeType: "image/svg+xml", isImage: true };
}
```

Add this check AFTER the binary format checks (JPEG, PNG, GIF, WebP) but BEFORE returning null.

Also add a new constant:
```typescript
export const MAX_EMOJI_SIZE = 128 * 1024; // 128KB for emoji (EMOJ-01)
export const EMOJI_DIMENSIONS = 128; // 128x128 output size
```
  </action>
  <verify>npm ls sharp && npx tsc --noEmit src/lib/file-validation.ts</verify>
  <done>Sharp installed, file validation extended to detect SVG, emoji constants added</done>
</task>

<task type="auto">
  <name>Task 2: Create emoji upload endpoint</name>
  <files>src/app/api/upload/emoji/route.ts</files>
  <action>
Create emoji upload endpoint following attachment upload pattern:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { writeFile, mkdir } from "fs/promises";
import { join } from "path";
import { v4 as uuid } from "uuid";
import sharp from "sharp";
import { db } from "@/db";
import { customEmojis, organizations, members } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import {
  validateFileSignature,
  MAX_EMOJI_SIZE,
  EMOJI_DIMENSIONS,
} from "@/lib/file-validation";

// CONTEXT: Names allow letters, numbers, underscores, and hyphens
const EMOJI_NAME_REGEX = /^[a-zA-Z0-9_-]+$/;

export async function POST(request: NextRequest) {
  try {
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const formData = await request.formData();
    const file = formData.get("file") as File | null;
    const name = formData.get("name") as string | null;
    const workspaceId = formData.get("workspaceId") as string | null;

    if (!file || !name || !workspaceId) {
      return NextResponse.json(
        { error: "File, name, and workspaceId required" },
        { status: 400 }
      );
    }

    // Validate emoji name format (CONTEXT decision)
    if (!EMOJI_NAME_REGEX.test(name) || name.length > 64) {
      return NextResponse.json(
        { error: "Invalid emoji name. Use letters, numbers, underscores, hyphens (max 64 chars)" },
        { status: 400 }
      );
    }

    // Validate file size (EMOJ-01: 128KB)
    if (file.size > MAX_EMOJI_SIZE) {
      return NextResponse.json(
        { error: "File too large. Maximum size: 128KB" },
        { status: 400 }
      );
    }

    // CONTEXT: Admins and channel creators can upload
    // Check if user is admin in workspace
    const membership = await db.query.members.findFirst({
      where: and(
        eq(members.userId, session.user.id),
        eq(members.organizationId, workspaceId)
      ),
      columns: { role: true },
    });

    if (!membership) {
      return NextResponse.json({ error: "Not a member of workspace" }, { status: 403 });
    }

    // For now, allow admin and member roles (creator check would need channel context)
    // Restricting to admin only for workspace-level emoji
    if (membership.role !== "admin" && membership.role !== "owner") {
      return NextResponse.json(
        { error: "Admin access required to upload emoji" },
        { status: 403 }
      );
    }

    // Check name uniqueness within workspace (EMOJ-04)
    const existing = await db.query.customEmojis.findFirst({
      where: and(
        eq(customEmojis.workspaceId, workspaceId),
        eq(customEmojis.name, name)
      ),
    });

    if (existing) {
      return NextResponse.json(
        { error: `Emoji :${name}: already exists` },
        { status: 400 }
      );
    }

    // Read and validate file
    const arrayBuffer = await file.arrayBuffer();
    let buffer = Buffer.from(arrayBuffer);
    const uint8 = new Uint8Array(arrayBuffer);

    const validated = validateFileSignature(uint8);
    if (!validated || !["png", "jpg", "gif", "webp", "svg"].includes(validated.extension)) {
      return NextResponse.json(
        { error: "Invalid file type. Allowed: PNG, JPG, GIF, WebP, SVG" },
        { status: 400 }
      );
    }

    let finalMimeType: string;
    let isAnimated = false;

    // SVG -> PNG conversion for XSS protection (EMOJ-08)
    if (validated.extension === "svg") {
      buffer = await sharp(buffer)
        .resize(EMOJI_DIMENSIONS, EMOJI_DIMENSIONS, {
          fit: "contain",
          background: { r: 0, g: 0, b: 0, alpha: 0 },
        })
        .png()
        .toBuffer();
      finalMimeType = "image/png";
    } else {
      finalMimeType = validated.mimeType;
      isAnimated = validated.extension === "gif"; // EMOJ-07

      // Resize all images to standard size
      buffer = await sharp(buffer, { animated: isAnimated })
        .resize(EMOJI_DIMENSIONS, EMOJI_DIMENSIONS, {
          fit: "contain",
          background: { r: 0, g: 0, b: 0, alpha: 0 },
        })
        .toBuffer();
    }

    // Generate filename and save
    const extension = finalMimeType === "image/png" ? "png" :
                      finalMimeType === "image/gif" ? "gif" :
                      finalMimeType === "image/webp" ? "webp" : "jpg";
    const filename = `${uuid()}.${extension}`;
    const uploadDir = join(process.cwd(), "public", "uploads", "emoji");
    const filepath = join(uploadDir, filename);

    await mkdir(uploadDir, { recursive: true });
    await writeFile(filepath, buffer);

    const path = `/uploads/emoji/${filename}`;

    // Insert into database
    const [emoji] = await db
      .insert(customEmojis)
      .values({
        workspaceId,
        name,
        filename,
        path,
        mimeType: finalMimeType,
        sizeBytes: buffer.length,
        isAnimated,
        uploadedBy: session.user.id,
      })
      .returning();

    return NextResponse.json({
      id: emoji.id,
      name: emoji.name,
      path: emoji.path,
      isAnimated: emoji.isAnimated,
    });
  } catch (error) {
    console.error("Emoji upload error:", error);
    return NextResponse.json(
      { error: "Failed to upload emoji" },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>npx tsc --noEmit src/app/api/upload/emoji/route.ts</verify>
  <done>Emoji upload endpoint with SVG-to-PNG conversion, size validation, name uniqueness check</done>
</task>

<task type="auto">
  <name>Task 3: Create emoji CRUD server actions</name>
  <files>src/lib/actions/custom-emoji.ts</files>
  <action>
Create server actions for emoji management:

```typescript
"use server";

import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { db } from "@/db";
import { customEmojis, members } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import { unlink } from "fs/promises";
import { join } from "path";

export interface CustomEmoji {
  id: string;
  name: string;
  path: string;
  isAnimated: boolean;
  uploadedBy: string;
  createdAt: Date;
}

/**
 * Get all custom emojis for a workspace.
 * Returns array suitable for emoji picker integration.
 */
export async function getWorkspaceEmojis(workspaceId: string): Promise<CustomEmoji[]> {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) {
    throw new Error("Unauthorized");
  }

  // Verify user is member of workspace
  const membership = await db.query.members.findFirst({
    where: and(
      eq(members.userId, session.user.id),
      eq(members.organizationId, workspaceId)
    ),
  });

  if (!membership) {
    throw new Error("Not a member of workspace");
  }

  const emojis = await db.query.customEmojis.findMany({
    where: eq(customEmojis.workspaceId, workspaceId),
    orderBy: (emoji, { asc }) => [asc(emoji.name)],
  });

  return emojis.map((e) => ({
    id: e.id,
    name: e.name,
    path: e.path,
    isAnimated: e.isAnimated,
    uploadedBy: e.uploadedBy,
    createdAt: e.createdAt,
  }));
}

/**
 * Delete a custom emoji.
 * EMOJ-06: User can delete own uploaded emoji.
 * Admins can delete any emoji.
 */
export async function deleteCustomEmoji(
  emojiId: string
): Promise<{ success: boolean; error?: string }> {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) {
    return { success: false, error: "Unauthorized" };
  }

  // Fetch emoji
  const emoji = await db.query.customEmojis.findFirst({
    where: eq(customEmojis.id, emojiId),
  });

  if (!emoji) {
    return { success: false, error: "Emoji not found" };
  }

  // Check permissions: own emoji or admin
  const membership = await db.query.members.findFirst({
    where: and(
      eq(members.userId, session.user.id),
      eq(members.organizationId, emoji.workspaceId)
    ),
    columns: { role: true },
  });

  if (!membership) {
    return { success: false, error: "Not a member of workspace" };
  }

  const isOwner = emoji.uploadedBy === session.user.id;
  const isAdmin = membership.role === "admin" || membership.role === "owner";

  if (!isOwner && !isAdmin) {
    return { success: false, error: "Can only delete your own emoji or be admin" };
  }

  // Delete file from disk
  try {
    const filepath = join(process.cwd(), "public", emoji.path);
    await unlink(filepath);
  } catch (error) {
    // File may not exist, continue with DB deletion
    console.warn("Failed to delete emoji file:", error);
  }

  // Delete from database
  await db.delete(customEmojis).where(eq(customEmojis.id, emojiId));

  return { success: true };
}
```
  </action>
  <verify>npx tsc --noEmit src/lib/actions/custom-emoji.ts</verify>
  <done>Server actions for listing workspace emojis and deleting own/admin emojis</done>
</task>

</tasks>

<verification>
- [ ] npm ls sharp shows installed
- [ ] npx tsc --noEmit passes for all files
- [ ] validateFileSignature detects SVG files
- [ ] Upload endpoint converts SVG to PNG
- [ ] Upload endpoint resizes images to 128x128
- [ ] Name uniqueness enforced (returns error if exists)
- [ ] deleteCustomEmoji only allows owner or admin
</verification>

<success_criteria>
Custom emoji backend complete:
- Upload PNG/JPG/GIF up to 128KB (EMOJ-01)
- SVG converted to PNG (EMOJ-08)
- Animated GIFs preserved (EMOJ-07)
- Names unique per workspace (EMOJ-04)
- Users can delete own emoji (EMOJ-06)
</success_criteria>

<output>
After completion, create `.planning/phases/27-rich-content/27-04-SUMMARY.md`
</output>
