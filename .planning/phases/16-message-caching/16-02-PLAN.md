---
phase: 16-message-caching
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - src/lib/cache/use-cached-messages.ts
  - src/lib/cache/index.ts
  - src/components/message/message-list.tsx
  - src/components/channel/channel-content.tsx
  - src/components/dm/dm-content.tsx
  - src/components/pwa/PWAProvider.tsx
autonomous: false

must_haves:
  truths:
    - "Messages are cached when user views a channel"
    - "Messages are cached when user views a DM conversation"
    - "New real-time messages are cached as they arrive"
    - "Deleted messages are updated in cache with deletedAt timestamp"
    - "User can scroll through cached messages when offline"
    - "TTL cleanup runs on app initialization"
  artifacts:
    - path: "src/lib/cache/use-cached-messages.ts"
      provides: "React hooks for cached messages with useLiveQuery"
      exports: ["useCachedChannelMessages", "useCachedConversationMessages"]
    - path: "src/components/message/message-list.tsx"
      provides: "Message list with caching and offline fallback"
      contains: "cacheMessages"
    - path: "src/components/channel/channel-content.tsx"
      provides: "Channel content with cache initialization"
      contains: "cacheMessages"
    - path: "src/components/dm/dm-content.tsx"
      provides: "DM content with cache initialization"
      contains: "cacheMessages"
    - path: "src/components/pwa/PWAProvider.tsx"
      provides: "PWA provider with cache initialization"
      contains: "initializeCache"
  key_links:
    - from: "src/components/message/message-list.tsx"
      to: "src/lib/cache/messages.ts"
      via: "cacheMessage on socket events"
      pattern: "cacheMessage\\("
    - from: "src/components/message/message-list.tsx"
      to: "src/lib/cache/use-cached-messages.ts"
      via: "useCachedChannelMessages hook"
      pattern: "useCached(Channel|Conversation)Messages"
    - from: "src/components/message/message-list.tsx"
      to: "src/lib/pwa/use-online-status.ts"
      via: "useOnlineStatus for offline detection"
      pattern: "useOnlineStatus"
    - from: "src/components/pwa/PWAProvider.tsx"
      to: "src/lib/cache/init.ts"
      via: "initializeCache on mount"
      pattern: "initializeCache"
---

<objective>
Wire message caching into UI with offline fallback

Purpose: Connect the cache infrastructure from Plan 01 to the message display components so users can read cached messages when offline and messages are automatically cached during normal use.

Output: MessageList displays cached messages when offline, ChannelContent/DMContent cache messages on load, socket events update cache, PWAProvider initializes cache with TTL cleanup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-message-caching/16-RESEARCH.md
@.planning/phases/16-message-caching/16-01-SUMMARY.md

# Existing code to modify
@src/components/message/message-list.tsx
@src/components/channel/channel-content.tsx
@src/components/dm/dm-content.tsx
@src/components/pwa/PWAProvider.tsx
@src/lib/pwa/use-online-status.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create React hooks for cached messages</name>
  <files>
    - src/lib/cache/use-cached-messages.ts
    - src/lib/cache/index.ts
  </files>
  <action>
Create src/lib/cache/use-cached-messages.ts with reactive hooks:

1. useCachedChannelMessages(channelId: string | null): CachedMessage[]
   - Uses useLiveQuery from dexie-react-hooks
   - Query: db.messages.where("[channelId+sequence]").between([channelId, Dexie.minKey], [channelId, Dexie.maxKey]).toArray()
   - Return empty array if channelId is null
   - Default value: [] (while loading)
   - Dependencies: [channelId]

2. useCachedConversationMessages(conversationId: string | null): CachedMessage[]
   - Same pattern but with [conversationId+sequence] compound index

Note: useLiveQuery automatically re-renders when IndexedDB data changes, including from other tabs.

Update src/lib/cache/index.ts to export the new hooks.
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit src/lib/cache/use-cached-messages.ts
```
  </verify>
  <done>Reactive hooks provide cached messages with automatic updates when cache changes</done>
</task>

<task type="auto">
  <name>Task 2: Integrate caching into MessageList with offline fallback</name>
  <files>
    - src/components/message/message-list.tsx
  </files>
  <action>
Update src/components/message/message-list.tsx to:

1. Add imports:
   - { cacheMessage, cacheMessages, updateMessageDeletion } from "@/lib/cache"
   - { useCachedChannelMessages, useCachedConversationMessages } from "@/lib/cache"
   - { useOnlineStatus } from "@/lib/pwa/use-online-status"

2. Add online status and cached messages:
```typescript
const { isOnline } = useOnlineStatus();
const cachedChannelMessages = useCachedChannelMessages(
  targetType === "channel" ? targetId : null
);
const cachedConversationMessages = useCachedConversationMessages(
  targetType === "dm" ? targetId : null
);
```

3. Cache initial messages on mount (fire-and-forget, don't await in render):
```typescript
useEffect(() => {
  if (initialMessages.length > 0) {
    // Fire and forget - don't block rendering
    cacheMessages(initialMessages);
  }
}, [initialMessages]);
```

4. Update handleNewMessage to also cache:
```typescript
function handleNewMessage(message: Message) {
  // ... existing belongsToTarget check and setMessages ...

  if (belongsToTarget) {
    setMessages((prev) => [...prev, message]);
    // Cache the new message (fire and forget)
    cacheMessage(message);
    // ... existing reactions code ...
  }
}
```

5. Update handleDeletedMessage to also update cache:
```typescript
function handleDeletedMessage(data: { messageId: string; deletedAt: Date }) {
  setMessages((prev) => /* existing logic */);
  // Update cache with deletion (fire and forget)
  updateMessageDeletion(data.messageId, data.deletedAt);
}
```

6. Compute display messages based on online status:
```typescript
// When offline, fall back to cached messages
const displayMessages = isOnline
  ? messages // Real-time state (existing behavior)
  : targetType === "channel"
    ? cachedChannelMessages
    : cachedConversationMessages;
```

7. Use displayMessages instead of messages in the render:
   - Change `if (messages.length === 0)` to `if (displayMessages.length === 0)`
   - Change `messages.map((message) =>` to `displayMessages.map((message) =>`

Important: CachedMessage has a slightly different shape than Message (authorName/authorEmail are flattened, not nested in author). The MessageItem should handle this gracefully since it only uses message.author?.name which will be undefined for CachedMessage - update the map to reconstruct the author object:

```typescript
// For offline display, reconstruct author object from cached data
const normalizedMessages = displayMessages.map((msg) => ({
  ...msg,
  author: 'authorName' in msg
    ? { id: msg.authorId, name: msg.authorName, email: msg.authorEmail }
    : msg.author,
}));
```

Then use normalizedMessages in the render.
  </action>
  <verify>
TypeScript compiles and app runs:
```bash
npm run build
npm run dev
```
  </verify>
  <done>MessageList caches messages during use and displays cached data when offline</done>
</task>

<task type="auto">
  <name>Task 3: Initialize cache in PWAProvider</name>
  <files>
    - src/components/pwa/PWAProvider.tsx
  </files>
  <action>
Update src/components/pwa/PWAProvider.tsx to initialize cache on mount:

1. Add import:
```typescript
import { initializeCache } from "@/lib/cache";
```

2. Add useEffect to initialize cache (alongside existing SW registration logic):
```typescript
useEffect(() => {
  // Initialize message cache (runs cleanup on 7-day-old messages)
  initializeCache();
}, []);
```

This is the right place because:
- PWAProvider is mounted on every page via the root layout
- It already handles PWA lifecycle (SW registration)
- Cache initialization is a PWA concern (offline capability)
- initializeCache is idempotent (safe if called multiple times)
  </action>
  <verify>
App builds and PWAProvider initializes cache:
```bash
npm run build
npm run dev
# Check browser console for "[Cache] Initialized" log
```
  </verify>
  <done>Cache initialization runs on app load with 7-day TTL cleanup</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete message caching system with offline fallback:
    - IndexedDB schema with Dexie.js
    - Cache operations (store, retrieve, cleanup)
    - Reactive hooks for cached messages
    - Automatic caching when viewing channels/DMs
    - Automatic caching of new real-time messages
    - Offline fallback in MessageList
    - 7-day TTL cleanup on app initialization
  </what-built>
  <how-to-verify>
    1. Start the dev server: npm run dev
    2. Open DevTools > Application > IndexedDB
    3. Navigate to a channel with messages
    4. Verify: OCommsCache database exists with messages table
    5. Verify: Messages appear in IndexedDB (check "messages" object store)

    6. Test offline reading:
       a. Stay on the channel page
       b. Open DevTools > Network tab
       c. Set "No throttling" dropdown to "Offline"
       d. Verify: Messages still display (from cache)
       e. Verify: OfflineBanner appears (from Phase 15)

    7. Test new message caching:
       a. Set Network back to "Online"
       b. Send a new message
       c. Check IndexedDB - new message should appear
       d. Go offline again - new message should still show

    8. Test TTL (optional - can be simulated):
       - Messages have cachedAt timestamp visible in IndexedDB
       - Console shows "[Cache] Initialized" on page load
  </how-to-verify>
  <resume-signal>Type "approved" if caching works, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build succeeds:
```bash
npm run build
```

2. No TypeScript errors:
```bash
npx tsc --noEmit
```

3. Cache files exist:
```bash
ls -la src/lib/cache/
# Should show: db.ts, messages.ts, init.ts, use-cached-messages.ts, index.ts
```

4. Functional tests (manual):
- Navigate to channel -> messages cached in IndexedDB
- Go offline -> messages still display
- New message while online -> cached immediately
- App reload -> "[Cache] Initialized" in console
</verification>

<success_criteria>
- Messages populate IndexedDB when user views a channel (OFFL-01)
- User can scroll through cached messages with no network connection (OFFL-02)
- Messages older than 7 days are automatically cleaned up (OFFL-01)
- Real-time messages are cached as they arrive
- Deleted messages are updated in cache
- App initializes cache on load with TTL cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/16-message-caching/16-02-SUMMARY.md`
</output>
