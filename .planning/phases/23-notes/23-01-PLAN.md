---
phase: 23-notes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/note.ts
  - src/db/schema/index.ts
  - src/lib/socket-events.ts
autonomous: true

must_haves:
  truths:
    - "channelNotes table exists with version column for conflict detection"
    - "personalNotes table exists with unique constraint on (userId, organizationId)"
    - "Socket event types include note:updated for real-time sync"
  artifacts:
    - path: "src/db/schema/note.ts"
      provides: "channelNotes and personalNotes schema definitions"
      exports: ["channelNotes", "personalNotes", "channelNotesRelations", "personalNotesRelations"]
    - path: "src/lib/socket-events.ts"
      provides: "note:updated event type definitions"
      contains: "note:updated"
  key_links:
    - from: "src/db/schema/note.ts"
      to: "src/db/schema/channel.ts"
      via: "channelId foreign key"
      pattern: "references.*channels\\.id"
    - from: "src/db/schema/note.ts"
      to: "src/db/schema/auth.ts"
      via: "userId and organizationId foreign keys"
      pattern: "references.*users\\.id"
---

<objective>
Create database schema for channel notes and personal notes with version tracking for conflict detection, plus socket event types for real-time updates.

Purpose: Foundational data layer that all notes features depend on.
Output: Drizzle schema files for notes tables, updated socket event types.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-notes/23-RESEARCH.md

@src/db/schema/channel.ts (foreign key pattern)
@src/db/schema/auth.ts (users and organizations references)
@src/db/schema/index.ts (export pattern)
@src/lib/socket-events.ts (event type pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notes database schema</name>
  <files>src/db/schema/note.ts, src/db/schema/index.ts</files>
  <action>
Create `src/db/schema/note.ts` with two tables:

**channelNotes table:**
- id: uuid primary key with defaultRandom()
- channelId: uuid foreign key to channels.id with onDelete cascade
- content: text not null default ""
- version: integer not null default 1 (for optimistic locking)
- updatedBy: text foreign key to users.id with onDelete set null
- createdAt: timestamp not null defaultNow()
- updatedAt: timestamp not null defaultNow()
- Add uniqueIndex on channelId (one note per channel)

**personalNotes table:**
- id: uuid primary key with defaultRandom()
- userId: text foreign key to users.id with onDelete cascade
- organizationId: text foreign key to organizations.id with onDelete cascade
- content: text not null default ""
- version: integer not null default 1
- createdAt: timestamp not null defaultNow()
- updatedAt: timestamp not null defaultNow()
- Add uniqueIndex on (userId, organizationId)

**Relations:**
- channelNotesRelations: one-to-one with channel, one-to-one with updatedByUser
- personalNotesRelations: one-to-one with user, one-to-one with organization

Update `src/db/schema/index.ts` to export from "./note"

Follow exact patterns from existing schema files (channel.ts, pinned-message.ts).
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Both tables defined with version column, unique constraints, and relations exported</done>
</task>

<task type="auto">
  <name>Task 2: Add socket event types for notes</name>
  <files>src/lib/socket-events.ts</files>
  <action>
Add note events to existing socket event type definitions:

**ServerToClientEvents:**
```typescript
"note:updated": (data: {
  channelId?: string;
  workspaceId?: string; // For personal notes (organizationId)
  version: number;
  updatedBy: string;
  updatedByName: string;
}) => void;
```

**ClientToServerEvents:**
```typescript
"note:subscribe": (data: { channelId?: string; workspaceId?: string }) => void;
"note:unsubscribe": (data: { channelId?: string; workspaceId?: string }) => void;
```

Place these in alphabetical order with existing events in each interface.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Socket event types include note:updated, note:subscribe, note:unsubscribe</done>
</task>

<task type="auto">
  <name>Task 3: Run database migration</name>
  <files>none (migration generated)</files>
  <action>
Generate and run Drizzle migration:

```bash
npx drizzle-kit generate
npx drizzle-kit push
```

If using push for development, just run push. The tables should be created in the database.
  </action>
  <verify>`npx drizzle-kit push` completes without error, or check database has channel_notes and personal_notes tables</verify>
  <done>Database has both notes tables with correct columns and constraints</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Database has `channel_notes` table with version column
3. Database has `personal_notes` table with unique (user_id, organization_id) constraint
4. Socket event types compile without errors
</verification>

<success_criteria>
- channelNotes and personalNotes tables exist in database
- Version column exists for optimistic locking
- Socket event types defined for note updates
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/23-notes/23-01-SUMMARY.md`
</output>
