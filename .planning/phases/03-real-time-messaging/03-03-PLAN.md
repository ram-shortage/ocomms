---
phase: 03-real-time-messaging
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/server/socket/handlers/presence.ts
  - src/server/socket/index.ts
  - src/components/presence/presence-indicator.tsx
  - src/components/presence/presence-provider.tsx
  - src/app/(workspace)/layout.tsx
  - src/components/workspace/member-list.tsx
  - src/components/dm/dm-list.tsx
autonomous: true

must_haves:
  truths:
    - "User presence shows as active when connected"
    - "User presence shows as offline when disconnected"
    - "Presence updates propagate to all workspace members"
    - "User can manually set away status"
  artifacts:
    - path: "src/server/socket/handlers/presence.ts"
      provides: "Presence state management with Redis TTL"
      exports: ["setupPresence", "handlePresenceEvents"]
    - path: "src/components/presence/presence-indicator.tsx"
      provides: "Visual presence dot indicator"
      exports: ["PresenceIndicator"]
    - path: "src/components/presence/presence-provider.tsx"
      provides: "Context for presence state across app"
      exports: ["PresenceProvider", "usePresence"]
  key_links:
    - from: "src/server/socket/handlers/presence.ts"
      to: "ioredis"
      via: "Redis SETEX/DEL for TTL-based presence"
      pattern: "redis\\.setex|redis\\.del"
    - from: "src/components/presence/presence-provider.tsx"
      to: "socket"
      via: "on presence:update"
      pattern: "on.*presence:update"
---

<objective>
Implement user presence system with real-time status updates (active/away/offline).

Purpose: Show who's online - essential UX for real-time communication apps.
Output: Redis-backed presence with heartbeat, UI indicators throughout the app.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-real-time-messaging/03-RESEARCH.md
@.planning/phases/03-real-time-messaging/03-01-SUMMARY.md

@src/server/socket/index.ts
@src/server/socket/rooms.ts
@src/server/redis.ts
@src/lib/socket-events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Presence handlers with Redis TTL</name>
  <files>
    src/server/socket/handlers/presence.ts
    src/server/socket/index.ts
  </files>
  <action>
    Create presence handlers at src/server/socket/handlers/presence.ts:

    Constants:
    - PRESENCE_TTL = 60 seconds (Redis key expiry)
    - HEARTBEAT_INTERVAL = 30000 ms (client heartbeat)

    Type: PresenceStatus = "active" | "away" | "offline"

    Export setupPresence(io: Server, redis: Redis):
    Returns object with methods:
    - setOnline(userId, workspaceId): SETEX presence:{workspaceId}:{userId} TTL "active", broadcast presence:update to workspace room
    - setAway(userId, workspaceId): SETEX with "away", broadcast
    - setOffline(userId, workspaceId): DEL key, broadcast with status "offline"
    - getStatus(userId, workspaceId): GET key, return status or "offline"
    - getWorkspacePresence(workspaceId, userIds): Pipeline GET all user keys, return Record<userId, status>
    - heartbeat(userId, workspaceId): EXPIRE to refresh TTL (don't change status)

    Export handlePresenceEvents(socket, io, presence):
    - On connection: presence.setOnline(userId, workspaceId)
    - Set up heartbeat interval: call presence.heartbeat every HEARTBEAT_INTERVAL
    - socket.on("presence:setAway"): presence.setAway()
    - socket.on("presence:setActive"): presence.setOnline()
    - socket.on("disconnect"): clearInterval(heartbeatTimer), presence.setOffline()

    Note: workspaceId comes from socket.data.workspaceId (set during room join)

    Update src/server/socket/index.ts:
    - Import presence handlers and Redis client
    - Create presence instance with setupPresence(io, redis)
    - Call handlePresenceEvents(socket, io, presence) in connection handler
    - Store workspaceId in socket.data when user joins workspace room
  </action>
  <verify>
    TypeScript compiles without errors
    Redis operations properly typed with ioredis
  </verify>
  <done>
    Presence state persisted in Redis with auto-expiry, heartbeat keeps users online, disconnect triggers offline
  </done>
</task>

<task type="auto">
  <name>Task 2: Presence UI components and provider</name>
  <files>
    src/components/presence/presence-indicator.tsx
    src/components/presence/presence-provider.tsx
    src/app/(workspace)/layout.tsx
  </files>
  <action>
    Create PresenceIndicator at src/components/presence/presence-indicator.tsx:
    - Props: status ("active" | "away" | "offline"), size ("sm" | "md" | "lg")
    - Render colored dot:
      - active: green (bg-green-500)
      - away: yellow (bg-yellow-500)
      - offline: gray (bg-gray-400)
    - Size variants: sm = 8px, md = 10px, lg = 12px
    - Include subtle ring/border for visibility on varied backgrounds

    Create PresenceProvider at src/components/presence/presence-provider.tsx:
    - "use client" directive
    - Create PresenceContext with:
      - presenceMap: Record<string, PresenceStatus>
      - getPresence(userId): PresenceStatus
    - In provider:
      - useSocket to get connection
      - State: presenceMap
      - On mount: fetch initial presence for workspace members via API call
      - Subscribe to "presence:update" events, update presenceMap
      - Emit heartbeat on visibility change (window focus = active, blur = away)
    - Export usePresence hook that consumes context

    Create API route for initial presence fetch (or use server action):
    - Accept workspaceId and list of userIds
    - Call presence.getWorkspacePresence from Redis
    - Return presenceMap
    - Note: This can be done via socket emit with callback instead of REST if simpler

    Update workspace layout at src/app/(workspace)/layout.tsx:
    - Wrap children with PresenceProvider
    - Pass workspaceId from route params
  </action>
  <verify>
    TypeScript compiles without errors
    PresenceIndicator renders correct colors
    PresenceProvider compiles with proper context typing
  </verify>
  <done>
    Presence indicator component, context provider with real-time updates, visibility-based away detection
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate presence indicators in UI</name>
  <files>
    src/components/workspace/member-list.tsx
    src/components/dm/dm-list.tsx
  </files>
  <action>
    Update MemberList at src/components/workspace/member-list.tsx:
    - Import usePresence and PresenceIndicator
    - For each member, get presence status: usePresence().getPresence(member.userId)
    - Add PresenceIndicator next to member avatar
    - Position: absolute bottom-right of avatar, or inline after name

    Update DMList at src/components/dm/dm-list.tsx:
    - Import usePresence and PresenceIndicator
    - For 1:1 DMs: show other participant's presence next to their name
    - For group DMs: optionally show count of online participants, or skip presence
    - Add PresenceIndicator to each DM item

    Style considerations:
    - Presence dot should not obscure avatar
    - Use z-index to layer correctly
    - Consider using avatar component wrapper with presence overlay
  </action>
  <verify>
    TypeScript compiles without errors
    npm run build succeeds
    Presence indicators visible in member list and DM list
  </verify>
  <done>
    Presence indicators visible throughout workspace UI, updating in real-time
  </done>
</task>

</tasks>

<verification>
- User connects -> status becomes "active"
- User disconnects -> status becomes "offline" (after TTL or immediately on clean disconnect)
- User switches tabs -> status becomes "away"
- User returns to tab -> status becomes "active"
- All workspace members see presence updates in real-time
- Presence visible in member list and DM list
</verification>

<success_criteria>
- Presence shows as active/away/offline accurately
- Presence updates propagate to all connected clients
- Heartbeat keeps presence alive during long sessions
- Disconnect (clean or crash) triggers offline status
- UI indicators visible in member list and DM list
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time-messaging/03-03-SUMMARY.md`
</output>
