---
phase: 29-stabilization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/socket/handlers/notes.ts
  - src/server/socket/handlers/typing.ts
  - src/server/socket/index.ts
autonomous: true

must_haves:
  truths:
    - "Notes socket subscribe/broadcast requires channel membership"
    - "Typing events require channel/DM membership before broadcast"
    - "Presence fetch validates organization membership"
  artifacts:
    - path: "src/server/socket/handlers/notes.ts"
      provides: "Authorization checks for note subscriptions"
      contains: "isChannelMember"
    - path: "src/server/socket/handlers/typing.ts"
      provides: "Authorization checks for typing events"
      contains: "isChannelMember"
    - path: "src/server/socket/index.ts"
      provides: "Organization membership check for presence"
      contains: "isOrganizationMember"
  key_links:
    - from: "src/server/socket/handlers/notes.ts"
      to: "src/server/socket/authz.ts"
      via: "import isChannelMember, isOrganizationMember"
      pattern: "import.*isChannelMember.*from.*authz"
    - from: "src/server/socket/handlers/typing.ts"
      to: "src/server/socket/authz.ts"
      via: "import isChannelMember, isConversationParticipant"
      pattern: "import.*isChannelMember.*from.*authz"
---

<objective>
Fix H-1 (notes socket auth), M-7 (typing auth), and M-1 (presence auth) security vulnerabilities.

Purpose: Close the highest severity security findings (1 HIGH, 2 MEDIUM) that allow unauthorized users to join rooms and broadcast events.
Output: Socket handlers with proper authorization checks using existing authz.ts helpers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-stabilization/29-RESEARCH.md
@CODE_REVIEW_04.MD

Source files to modify:
@src/server/socket/handlers/notes.ts
@src/server/socket/handlers/typing.ts
@src/server/socket/index.ts
@src/server/socket/authz.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix H-1 - Add authorization to notes socket handlers</name>
  <files>src/server/socket/handlers/notes.ts</files>
  <action>
Import `isChannelMember` and `isOrganizationMember` from `../authz`.

Modify `note:subscribe` handler:
- For channelId: Check `await isChannelMember(userId, channelId)` before joining room
- For workspaceId: Check `await isOrganizationMember(userId, workspaceId)` before joining room
- Emit `socket.emit("error", { message: "Not authorized" })` and return early if checks fail

Modify `note:broadcast` handler:
- For channelId: Check `await isChannelMember(userId, channelId)` before broadcasting
- For workspaceId: Personal notes only broadcast to user's own room (already scoped by userId in room name, so minimal risk, but add org membership check for consistency)
- Emit error and return early if checks fail

Pattern to follow (from research):
```typescript
socket.on("note:subscribe", async (data) => {
  const { channelId, workspaceId } = data;

  if (channelId) {
    const isMember = await isChannelMember(userId, channelId);
    if (!isMember) {
      socket.emit("error", { message: "Not authorized to subscribe to channel notes" });
      return;
    }
    socket.join(getNoteChannelRoom(channelId));
  }
  // Similar for workspaceId with isOrganizationMember
});
```
  </action>
  <verify>
Read the modified file and confirm:
- `isChannelMember` and `isOrganizationMember` are imported
- `note:subscribe` has authorization checks before `socket.join()`
- `note:broadcast` has authorization checks before `socket.to().emit()`
- Error messages are emitted on failed auth
  </verify>
  <done>
Notes socket handlers require membership verification before subscribing to rooms or broadcasting updates
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix M-7 - Add authorization to typing handlers</name>
  <files>src/server/socket/handlers/typing.ts</files>
  <action>
Import `isChannelMember` and `isConversationParticipant` from `../authz`.

Modify `typing:start` handler:
- Before broadcasting, check membership based on targetType:
  - If targetType === "channel": `await isChannelMember(userId, targetId)`
  - If targetType === "dm": `await isConversationParticipant(userId, targetId)`
- Emit error and return early if not authorized

Modify `typing:stop` handler:
- Same authorization checks as typing:start

The disconnect handler doesn't need additional checks because it only broadcasts if `activeTyping` was set (which requires passing the start/stop auth checks first).

Pattern:
```typescript
socket.on("typing:start", async (data) => {
  const { targetId, targetType } = data;

  // Verify membership before broadcasting
  if (targetType === "channel") {
    const isMember = await isChannelMember(userId, targetId);
    if (!isMember) {
      socket.emit("error", { message: "Not authorized to type in this channel" });
      return;
    }
  } else {
    const isParticipant = await isConversationParticipant(userId, targetId);
    if (!isParticipant) {
      socket.emit("error", { message: "Not authorized to type in this conversation" });
      return;
    }
  }

  // ... rest of handler
});
```
  </action>
  <verify>
Read the modified file and confirm:
- `isChannelMember` and `isConversationParticipant` are imported
- `typing:start` checks channel/conversation membership before broadcasting
- `typing:stop` checks channel/conversation membership before broadcasting
- Error messages are emitted on failed auth
  </verify>
  <done>
Typing events require channel/conversation membership verification before broadcasting
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix M-1 - Add organization membership check to presence fetch</name>
  <files>src/server/socket/index.ts</files>
  <action>
Locate the `presence:fetch` handler (around line 184-204 per CODE_REVIEW).

Import `isOrganizationMember` from `./authz` if not already imported.

Add authorization check before processing presence:
```typescript
socket.on("presence:fetch", async (data) => {
  const { workspaceId, userIds } = data;

  // Verify requester is member of the workspace
  const isMember = await isOrganizationMember(socket.data.userId, workspaceId);
  if (!isMember) {
    socket.emit("error", { message: "Not authorized to fetch presence for this workspace" });
    return;
  }

  // ... existing presence fetch logic
});
```

This prevents any authenticated user from fetching presence for arbitrary workspaces.
  </action>
  <verify>
Read the modified file and confirm:
- `isOrganizationMember` is imported (or already was)
- `presence:fetch` handler validates workspace membership before fetching presence
- Error is emitted if user is not a workspace member
  </verify>
  <done>
Presence fetch requires organization membership verification before returning user statuses
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `npm run lint` - should pass
2. Run `npm run typecheck` - should pass
3. Run `npm test` - existing tests should pass
4. Read each modified file and verify authorization checks are in place
</verification>

<success_criteria>
- H-1 closed: Notes socket handlers verify channel/org membership before subscribe/broadcast
- M-7 closed: Typing handlers verify channel/conversation membership before broadcast
- M-1 closed: Presence fetch verifies organization membership before returning data
- All auth checks use existing authz.ts helpers (no new implementations)
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/29-stabilization/29-01-SUMMARY.md`
</output>
