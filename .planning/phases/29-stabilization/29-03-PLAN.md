---
phase: 29-stabilization
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/socket/handlers/thread.ts
autonomous: true

must_haves:
  truths:
    - "Thread reply inserts use retry logic for sequence conflicts"
    - "Thread replies validate message length"
    - "Thread reply fetch uses pagination with reasonable limits"
  artifacts:
    - path: "src/server/socket/handlers/thread.ts"
      provides: "Rate limiting, length validation, pagination, retry logic"
      contains: "MAX_MESSAGE_LENGTH"
  key_links:
    - from: "src/server/socket/handlers/thread.ts"
      to: "src/server/socket/handlers/message.ts"
      via: "shared constants and patterns"
      pattern: "MAX_MESSAGE_LENGTH|insertMessageWithRetry"
---

<objective>
Fix M-2 (thread race condition), M-3 (thread limits), and M-11 (thread pagination) security vulnerabilities.

Purpose: Close 3 MEDIUM severity findings in thread handlers that cause race conditions and DoS vectors.
Output: Thread handler with retry logic, validation, and pagination matching message handler patterns.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-stabilization/29-RESEARCH.md
@CODE_REVIEW_04.MD

Source files:
@src/server/socket/handlers/thread.ts
@src/server/socket/handlers/message.ts (reference for patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix M-2 and M-3 - Add retry logic and validation to thread replies</name>
  <files>src/server/socket/handlers/thread.ts</files>
  <action>
Import `MAX_MESSAGE_LENGTH` from `./message.ts` (or define locally if not exported).

For M-3 (length validation), add before insert:
```typescript
if (content.length > MAX_MESSAGE_LENGTH) {
  socket.emit("error", { message: `Message exceeds ${MAX_MESSAGE_LENGTH} character limit` });
  return;
}
```

For M-2 (race condition), implement retry logic similar to message.ts pattern.

Look at how message.ts handles sequence generation with retry on constraint violation (error code 23505). Apply the same pattern to thread reply insert:

```typescript
const MAX_RETRIES = 3;
let attempt = 0;

while (attempt < MAX_RETRIES) {
  try {
    // Get next sequence using single statement to minimize race window
    const [maxSeq] = await db
      .select({ max: sql<number>`COALESCE(MAX(${messages.sequence}), 0)` })
      .from(messages)
      .where(eq(messages.parentId, parentId));

    const nextSequence = (maxSeq?.max ?? 0) + 1;

    // Insert with the computed sequence
    const [reply] = await db
      .insert(messages)
      .values({
        id: nanoid(),
        content,
        userId,
        channelId: parent.channelId,
        conversationId: parent.conversationId,
        parentId,
        sequence: nextSequence,
        // ... other fields
      })
      .returning();

    return reply; // Success
  } catch (error: unknown) {
    if (error instanceof Error && error.message.includes("23505")) {
      // Unique constraint violation - retry
      attempt++;
      if (attempt >= MAX_RETRIES) {
        throw new Error("Failed to create reply after retries");
      }
      continue;
    }
    throw error; // Re-throw other errors
  }
}
```

If there's a rate limiter in message.ts, consider adding to thread replies as well (optional per M-3 recommendation).
  </action>
  <verify>
Read the modified file and confirm:
- MAX_MESSAGE_LENGTH is used to validate content length
- Thread reply insert uses retry logic for sequence conflicts
- Error handling catches 23505 (unique constraint) and retries
- Appropriate error messages emitted to socket
  </verify>
  <done>
Thread replies validate message length and use retry logic for race-safe sequence generation
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix M-11 - Add pagination to thread reply fetch</name>
  <files>src/server/socket/handlers/thread.ts</files>
  <action>
Locate `getReplies` or similar function that fetches thread replies (around lines 215-270 per CODE_REVIEW).

Add pagination parameters with reasonable defaults:

```typescript
interface GetRepliesParams {
  parentId: string;
  limit?: number;
  cursor?: number; // sequence number to start after
}

const MAX_PAGE_SIZE = 100;
const DEFAULT_PAGE_SIZE = 50;

export async function getReplies({ parentId, limit = DEFAULT_PAGE_SIZE, cursor }: GetRepliesParams) {
  // Clamp limit to prevent abuse
  const safeLimit = Math.min(Math.max(1, limit), MAX_PAGE_SIZE);

  const whereConditions = [eq(messages.parentId, parentId)];

  if (cursor !== undefined) {
    whereConditions.push(gt(messages.sequence, cursor));
  }

  const replies = await db.query.messages.findMany({
    where: and(...whereConditions),
    orderBy: asc(messages.sequence),
    limit: safeLimit + 1, // Fetch one extra to detect hasMore
  });

  const hasMore = replies.length > safeLimit;
  const items = hasMore ? replies.slice(0, safeLimit) : replies;
  const nextCursor = hasMore ? items[items.length - 1]?.sequence : undefined;

  return {
    items,
    hasMore,
    nextCursor,
  };
}
```

Update the socket handler that calls this to pass pagination params from client and return the paginated response.

Import `gt`, `asc` from drizzle-orm if not already imported.
  </action>
  <verify>
Read the modified file and confirm:
- Pagination parameters (limit, cursor) are accepted
- Limit is clamped to MAX_PAGE_SIZE (e.g., 100)
- Response includes hasMore and nextCursor for client pagination
- Large threads don't return unbounded results
  </verify>
  <done>
Thread reply fetch uses pagination with clamped limits to prevent DoS
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `npm run lint` - should pass
2. Run `npm run typecheck` - should pass
3. Run `npm test` - existing tests should pass
4. Verify thread-handlers.test.ts still passes (source validation tests)
</verification>

<success_criteria>
- M-2 closed: Thread reply insert uses retry logic for sequence conflicts
- M-3 closed: Thread replies validate message length (and optionally rate limited)
- M-11 closed: Thread reply fetch uses pagination with max 100 items per page
- Patterns match existing message.ts implementation
</success_criteria>

<output>
After completion, create `.planning/phases/29-stabilization/29-03-SUMMARY.md`
</output>
