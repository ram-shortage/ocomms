---
phase: 29-stabilization
plan: 10
type: execute
wave: 4
depends_on: ["29-05"]
files_modified:
  - src/lib/actions/__tests__/scheduled-message.test.ts
  - src/lib/actions/__tests__/reminder.test.ts
  - src/lib/actions/__tests__/bookmark.test.ts
autonomous: true

must_haves:
  truths:
    - "Tests cover scheduled message CRUD operations"
    - "Tests cover reminder create, snooze, complete operations"
    - "Tests cover bookmark toggle and list operations"
  artifacts:
    - path: "src/lib/actions/__tests__/scheduled-message.test.ts"
      provides: "Unit tests for scheduled message actions"
      min_lines: 100
    - path: "src/lib/actions/__tests__/reminder.test.ts"
      provides: "Unit tests for reminder actions"
      min_lines: 100
    - path: "src/lib/actions/__tests__/bookmark.test.ts"
      provides: "Unit tests for bookmark actions"
      min_lines: 80
  key_links:
    - from: "test files"
      to: "source actions"
      via: "database mocking pattern"
      pattern: "vi\\.mock\\(\"@/db\""
---

<objective>
Create unit tests for v0.5.0 server actions: scheduled messages, reminders, and bookmarks.

Purpose: Provide test coverage for Phase 25-26 features (TEST-01, TEST-04).
Output: Comprehensive tests using database mocking pattern covering happy path and error cases.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-stabilization/29-RESEARCH.md

Pattern reference:
@src/lib/actions/__tests__/channels.test.ts

Source files to test:
@src/lib/actions/scheduled-message.ts
@src/lib/actions/reminder.ts
@src/lib/actions/bookmark.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scheduled message action tests</name>
  <files>src/lib/actions/__tests__/scheduled-message.test.ts</files>
  <action>
Create comprehensive tests for scheduled message CRUD:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import {
  createScheduledMessage,
  getScheduledMessages,
  updateScheduledMessage,
  cancelScheduledMessage,
  sendScheduledMessageNow,
} from "../scheduled-message";

// Standard mocks
vi.mock("next/headers", () => ({
  headers: vi.fn().mockResolvedValue(new Headers()),
}));
vi.mock("next/cache", () => ({ revalidatePath: vi.fn() }));

const mockGetSession = vi.fn();
vi.mock("@/lib/auth", () => ({
  auth: { api: { getSession: (...args: unknown[]) => mockGetSession(...args) } },
}));

const mockFindFirst = vi.fn();
const mockFindMany = vi.fn();
const mockInsert = vi.fn();
const mockUpdate = vi.fn();
const mockDelete = vi.fn();

vi.mock("@/db", () => ({
  db: {
    query: {
      channelMembers: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
      conversationParticipants: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
      scheduledMessages: {
        findFirst: (...args: unknown[]) => mockFindFirst(...args),
        findMany: (...args: unknown[]) => mockFindMany(...args),
      },
    },
    insert: (...args: unknown[]) => mockInsert(...args),
    update: (...args: unknown[]) => mockUpdate(...args),
    delete: (...args: unknown[]) => mockDelete(...args),
  },
}));

// Mock BullMQ queue
vi.mock("@/server/queue/scheduled-message.queue", () => ({
  scheduledMessageQueue: {
    add: vi.fn().mockResolvedValue({ id: "job-123" }),
    getJob: vi.fn().mockResolvedValue({ remove: vi.fn() }),
  },
}));

describe("Scheduled Message Actions", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockGetSession.mockResolvedValue({ user: { id: "user-123" } });
  });

  describe("createScheduledMessage", () => {
    it("rejects unauthenticated user", async () => {
      mockGetSession.mockResolvedValue(null);

      await expect(
        createScheduledMessage({
          content: "hello",
          scheduledFor: new Date(Date.now() + 60000),
          channelId: "ch-1",
        })
      ).rejects.toThrow("Unauthorized");
    });

    it("rejects non-channel-member", async () => {
      mockFindFirst.mockResolvedValueOnce(null); // not a member

      await expect(
        createScheduledMessage({
          content: "hello",
          scheduledFor: new Date(Date.now() + 60000),
          channelId: "ch-1",
        })
      ).rejects.toThrow("Not a member");
    });

    it("creates scheduled message for channel member", async () => {
      mockFindFirst.mockResolvedValueOnce({ id: "member-1" }); // is member
      const scheduled = { id: "sm-1", content: "hello", status: "pending" };
      mockInsert.mockReturnValue({
        values: () => ({ returning: () => Promise.resolve([scheduled]) }),
      });

      const result = await createScheduledMessage({
        content: "hello",
        scheduledFor: new Date(Date.now() + 60000),
        channelId: "ch-1",
      });

      expect(result.id).toBe("sm-1");
      expect(mockInsert).toHaveBeenCalled();
    });

    it("rejects past scheduled time", async () => {
      mockFindFirst.mockResolvedValueOnce({ id: "member-1" });

      await expect(
        createScheduledMessage({
          content: "hello",
          scheduledFor: new Date(Date.now() - 60000), // past
          channelId: "ch-1",
        })
      ).rejects.toThrow();
    });
  });

  describe("cancelScheduledMessage", () => {
    it("rejects canceling non-owned message", async () => {
      mockFindFirst.mockResolvedValueOnce({ id: "sm-1", userId: "other-user" });

      await expect(cancelScheduledMessage("sm-1")).rejects.toThrow("Not authorized");
    });

    it("cancels owned pending message", async () => {
      mockFindFirst.mockResolvedValueOnce({
        id: "sm-1",
        userId: "user-123",
        status: "pending",
        jobId: "job-123",
      });
      mockUpdate.mockReturnValue({
        set: () => ({ where: () => Promise.resolve() }),
      });

      await cancelScheduledMessage("sm-1");

      expect(mockUpdate).toHaveBeenCalled();
    });
  });

  describe("getScheduledMessages", () => {
    it("returns only user's scheduled messages", async () => {
      mockFindMany.mockResolvedValueOnce([
        { id: "sm-1", content: "hello", status: "pending" },
        { id: "sm-2", content: "world", status: "pending" },
      ]);

      const result = await getScheduledMessages();

      expect(result).toHaveLength(2);
    });
  });
});
```
  </action>
  <verify>
Run `npm test src/lib/actions/__tests__/scheduled-message.test.ts`:
- All tests pass
- Tests cover create, cancel, get operations
- Tests verify authorization checks
  </verify>
  <done>
Scheduled message action tests provide coverage for SCHD-01 through SCHD-07
  </done>
</task>

<task type="auto">
  <name>Task 2: Create reminder action tests</name>
  <files>src/lib/actions/__tests__/reminder.test.ts</files>
  <action>
Create comprehensive tests for reminder operations:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import {
  createReminder,
  getReminders,
  snoozeReminder,
  completeReminder,
  cancelReminder,
} from "../reminder";

// Standard mocks (same pattern)
vi.mock("next/headers", () => ({
  headers: vi.fn().mockResolvedValue(new Headers()),
}));
vi.mock("next/cache", () => ({ revalidatePath: vi.fn() }));

const mockGetSession = vi.fn();
vi.mock("@/lib/auth", () => ({
  auth: { api: { getSession: (...args: unknown[]) => mockGetSession(...args) } },
}));

const mockFindFirst = vi.fn();
const mockFindMany = vi.fn();
const mockInsert = vi.fn();
const mockUpdate = vi.fn();
const mockDelete = vi.fn();

vi.mock("@/db", () => ({
  db: {
    query: {
      messages: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
      channelMembers: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
      conversationParticipants: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
      reminders: {
        findFirst: (...args: unknown[]) => mockFindFirst(...args),
        findMany: (...args: unknown[]) => mockFindMany(...args),
      },
    },
    insert: (...args: unknown[]) => mockInsert(...args),
    update: (...args: unknown[]) => mockUpdate(...args),
  },
}));

vi.mock("@/server/queue/reminder.queue", () => ({
  reminderQueue: {
    add: vi.fn().mockResolvedValue({ id: "job-123" }),
    getJob: vi.fn().mockResolvedValue({ remove: vi.fn() }),
  },
}));

describe("Reminder Actions", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockGetSession.mockResolvedValue({ user: { id: "user-123" } });
  });

  describe("createReminder", () => {
    it("rejects unauthenticated user", async () => {
      mockGetSession.mockResolvedValue(null);

      await expect(
        createReminder({
          messageId: "msg-1",
          remindAt: new Date(Date.now() + 60000),
        })
      ).rejects.toThrow("Unauthorized");
    });

    it("requires message access", async () => {
      // Message exists in a channel
      mockFindFirst.mockResolvedValueOnce({ id: "msg-1", channelId: "ch-1" });
      // User not a member
      mockFindFirst.mockResolvedValueOnce(null);

      await expect(
        createReminder({
          messageId: "msg-1",
          remindAt: new Date(Date.now() + 60000),
        })
      ).rejects.toThrow("Not authorized");
    });

    it("creates reminder for accessible message", async () => {
      mockFindFirst
        .mockResolvedValueOnce({ id: "msg-1", channelId: "ch-1" }) // message
        .mockResolvedValueOnce({ id: "member-1" }); // channel member
      mockInsert.mockReturnValue({
        values: () => ({ returning: () => Promise.resolve([{ id: "rem-1" }]) }),
      });

      const result = await createReminder({
        messageId: "msg-1",
        remindAt: new Date(Date.now() + 60000),
      });

      expect(result.id).toBe("rem-1");
    });
  });

  describe("snoozeReminder", () => {
    it("rejects snoozing non-owned reminder", async () => {
      mockFindFirst.mockResolvedValueOnce({ id: "rem-1", userId: "other-user" });

      await expect(snoozeReminder("rem-1", 20)).rejects.toThrow("Not authorized");
    });

    it("snoozes owned reminder", async () => {
      mockFindFirst.mockResolvedValueOnce({
        id: "rem-1",
        userId: "user-123",
        status: "fired",
      });
      mockUpdate.mockReturnValue({
        set: () => ({ where: () => Promise.resolve() }),
      });

      await snoozeReminder("rem-1", 20);

      expect(mockUpdate).toHaveBeenCalled();
    });
  });

  describe("completeReminder", () => {
    it("marks reminder as completed", async () => {
      mockFindFirst.mockResolvedValueOnce({ id: "rem-1", userId: "user-123" });
      mockUpdate.mockReturnValue({
        set: () => ({ where: () => Promise.resolve() }),
      });

      await completeReminder("rem-1");

      expect(mockUpdate).toHaveBeenCalled();
    });
  });
});
```
  </action>
  <verify>
Run `npm test src/lib/actions/__tests__/reminder.test.ts`:
- All tests pass
- Tests cover create, snooze, complete, cancel
- Tests verify message access authorization
  </verify>
  <done>
Reminder action tests provide coverage for RMND-01 through RMND-07
  </done>
</task>

<task type="auto">
  <name>Task 3: Create bookmark action tests</name>
  <files>src/lib/actions/__tests__/bookmark.test.ts</files>
  <action>
Create tests for bookmark operations:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import {
  toggleBookmark,
  getBookmarks,
  removeBookmark,
} from "../bookmark";

// Standard mocks
vi.mock("next/headers", () => ({
  headers: vi.fn().mockResolvedValue(new Headers()),
}));
vi.mock("next/cache", () => ({ revalidatePath: vi.fn() }));

const mockGetSession = vi.fn();
vi.mock("@/lib/auth", () => ({
  auth: { api: { getSession: (...args: unknown[]) => mockGetSession(...args) } },
}));

const mockFindFirst = vi.fn();
const mockFindMany = vi.fn();
const mockInsert = vi.fn();
const mockDelete = vi.fn();

vi.mock("@/db", () => ({
  db: {
    query: {
      messages: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
      channelMembers: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
      conversationParticipants: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
      bookmarks: {
        findFirst: (...args: unknown[]) => mockFindFirst(...args),
        findMany: (...args: unknown[]) => mockFindMany(...args),
      },
    },
    insert: (...args: unknown[]) => mockInsert(...args),
    delete: (...args: unknown[]) => mockDelete(...args),
  },
}));

describe("Bookmark Actions", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockGetSession.mockResolvedValue({ user: { id: "user-123" } });
  });

  describe("toggleBookmark", () => {
    it("rejects unauthenticated user", async () => {
      mockGetSession.mockResolvedValue(null);

      await expect(toggleBookmark("msg-1", "message")).rejects.toThrow("Unauthorized");
    });

    it("adds bookmark when not bookmarked", async () => {
      // Message exists and user has access
      mockFindFirst
        .mockResolvedValueOnce({ id: "msg-1", channelId: "ch-1" }) // message
        .mockResolvedValueOnce({ id: "member-1" }) // channel member
        .mockResolvedValueOnce(null); // no existing bookmark

      mockInsert.mockReturnValue({
        values: () => ({ returning: () => Promise.resolve([{ id: "bm-1" }]) }),
      });

      const result = await toggleBookmark("msg-1", "message");

      expect(result.bookmarked).toBe(true);
    });

    it("removes bookmark when already bookmarked", async () => {
      mockFindFirst
        .mockResolvedValueOnce({ id: "msg-1", channelId: "ch-1" })
        .mockResolvedValueOnce({ id: "member-1" })
        .mockResolvedValueOnce({ id: "bm-1" }); // existing bookmark

      mockDelete.mockReturnValue({
        where: () => Promise.resolve(),
      });

      const result = await toggleBookmark("msg-1", "message");

      expect(result.bookmarked).toBe(false);
    });
  });

  describe("getBookmarks", () => {
    it("returns user's bookmarks", async () => {
      mockFindMany.mockResolvedValueOnce([
        { id: "bm-1", type: "message", messageId: "msg-1" },
        { id: "bm-2", type: "file", fileId: "file-1" },
      ]);

      const result = await getBookmarks();

      expect(result).toHaveLength(2);
    });
  });

  describe("removeBookmark", () => {
    it("removes owned bookmark", async () => {
      mockFindFirst.mockResolvedValueOnce({ id: "bm-1", userId: "user-123" });
      mockDelete.mockReturnValue({ where: () => Promise.resolve() });

      await removeBookmark("bm-1");

      expect(mockDelete).toHaveBeenCalled();
    });

    it("rejects removing non-owned bookmark", async () => {
      mockFindFirst.mockResolvedValueOnce({ id: "bm-1", userId: "other-user" });

      await expect(removeBookmark("bm-1")).rejects.toThrow("Not authorized");
    });
  });
});
```
  </action>
  <verify>
Run `npm test src/lib/actions/__tests__/bookmark.test.ts`:
- All tests pass
- Tests cover toggle, get, remove operations
- Tests verify message access for toggle
  </verify>
  <done>
Bookmark action tests provide coverage for BOOK-01 through BOOK-05
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `npm test` - all new action tests pass
2. Run `npm run lint` - no lint errors
3. Tests use consistent mocking pattern from channels.test.ts
4. Tests cover both authorized and unauthorized scenarios
</verification>

<success_criteria>
- scheduled-message.test.ts covers SCHD requirements (create, update, cancel, send-now)
- reminder.test.ts covers RMND requirements (create, snooze, complete, cancel)
- bookmark.test.ts covers BOOK requirements (toggle, list, remove)
- All tests follow established mocking pattern
- Authorization checks verified in all actions
</success_criteria>

<output>
After completion, create `.planning/phases/29-stabilization/29-10-SUMMARY.md`
</output>
