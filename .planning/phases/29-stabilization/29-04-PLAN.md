---
phase: 29-stabilization
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/socket/index.ts
  - src/server/socket/handlers/unread.ts
  - src/server/socket/handlers/notification.ts
autonomous: true

must_haves:
  truths:
    - "Presence/unread fetches reject oversized ID arrays"
    - "Notification fetch has capped limit and batched queries"
  artifacts:
    - path: "src/server/socket/index.ts"
      provides: "Array size cap for presence fetch"
      contains: "MAX_IDS"
    - path: "src/server/socket/handlers/unread.ts"
      provides: "Array size cap for unread fetch"
      contains: "MAX_IDS"
    - path: "src/server/socket/handlers/notification.ts"
      provides: "Capped limit and batched channel queries"
      contains: "MAX_LIMIT"
  key_links:
    - from: "notification handler"
      to: "batch query"
      via: "inArray for channel lookup"
      pattern: "inArray"
---

<objective>
Fix M-12 (unbounded arrays) and M-13 (notification limits) security vulnerabilities.

Purpose: Close 2 MEDIUM severity DoS vectors caused by unbounded input arrays and missing query limits.
Output: Socket handlers with array size caps and batched queries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-stabilization/29-RESEARCH.md
@CODE_REVIEW_04.MD

Source files:
@src/server/socket/index.ts
@src/server/socket/handlers/unread.ts
@src/server/socket/handlers/notification.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix M-12 - Cap array sizes in presence and unread fetches</name>
  <files>src/server/socket/index.ts, src/server/socket/handlers/unread.ts</files>
  <action>
Define constant at top of each file:
```typescript
const MAX_IDS_PER_REQUEST = 100;
```

In `presence:fetch` handler (socket/index.ts around line 188-204):
```typescript
socket.on("presence:fetch", async (data) => {
  const { workspaceId, userIds } = data;

  // Cap array size
  if (userIds.length > MAX_IDS_PER_REQUEST) {
    socket.emit("error", {
      message: `Maximum ${MAX_IDS_PER_REQUEST} user IDs per request`
    });
    return;
  }

  // ... existing logic
});
```

In unread handlers (unread.ts around lines 401-427):
Find where channelIds/conversationIds arrays are received and add:
```typescript
socket.on("unread:fetch", async (data) => {
  const { channelIds, conversationIds } = data;

  // Cap array sizes
  const totalIds = (channelIds?.length ?? 0) + (conversationIds?.length ?? 0);
  if (totalIds > MAX_IDS_PER_REQUEST) {
    socket.emit("error", {
      message: `Maximum ${MAX_IDS_PER_REQUEST} IDs per request`
    });
    return;
  }

  // ... existing logic
});
```
  </action>
  <verify>
Read both modified files and confirm:
- MAX_IDS_PER_REQUEST constant defined (e.g., 100)
- presence:fetch rejects userIds arrays > limit
- unread:fetch rejects combined channelIds+conversationIds > limit
- Error messages explain the limit
  </verify>
  <done>
Presence and unread fetch handlers cap input array sizes to prevent DoS
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix M-13 - Cap notification limit and batch channel queries</name>
  <files>src/server/socket/handlers/notification.ts</files>
  <action>
Locate `notification:fetch` handler (around lines 375-412 per CODE_REVIEW).

Add limit clamping:
```typescript
const MAX_NOTIFICATION_LIMIT = 100;
const DEFAULT_NOTIFICATION_LIMIT = 50;

socket.on("notification:fetch", async (data) => {
  const { limit = DEFAULT_NOTIFICATION_LIMIT, cursor } = data;

  // Clamp limit
  const safeLimit = Math.min(Math.max(1, limit), MAX_NOTIFICATION_LIMIT);

  // Fetch notifications with safe limit
  const notifications = await db.query.notifications.findMany({
    where: eq(notifications.userId, userId),
    limit: safeLimit,
    // ... other options
  });

  // ... rest of handler
});
```

For the N+1 channel lookups, batch fetch all channels at once:
```typescript
// Instead of per-notification channel lookup:
// BAD: for (const n of notifications) { await getChannel(n.channelId) }

// GOOD: Batch fetch all unique channel IDs
const channelIds = [...new Set(notifications.map(n => n.channelId).filter(Boolean))];
const channelsMap = new Map<string, Channel>();

if (channelIds.length > 0) {
  const channels = await db.query.channels.findMany({
    where: inArray(channels.id, channelIds),
  });
  for (const ch of channels) {
    channelsMap.set(ch.id, ch);
  }
}

// Then map notifications with channels from the Map
const enrichedNotifications = notifications.map(n => ({
  ...n,
  channel: n.channelId ? channelsMap.get(n.channelId) : undefined,
}));
```

Import `inArray` from drizzle-orm.
  </action>
  <verify>
Read the modified file and confirm:
- MAX_NOTIFICATION_LIMIT constant defined (e.g., 100)
- Incoming limit is clamped before use
- Channel lookups use batch query with inArray (not per-notification)
- Response returns paginated results
  </verify>
  <done>
Notification fetch clamps limit and uses batched channel queries to prevent DoS
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `npm run lint` - should pass
2. Run `npm run typecheck` - should pass
3. Run `npm test` - existing tests should pass
4. Verify the handlers handle edge cases (empty arrays, zero limit)
</verification>

<success_criteria>
- M-12 closed: Presence and unread fetches reject arrays > 100 IDs
- M-13 closed: Notification fetch clamps limit to 100 and batches channel queries
- No N+1 query patterns remain in notification handler
- All handlers handle edge cases gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/29-stabilization/29-04-SUMMARY.md`
</output>
