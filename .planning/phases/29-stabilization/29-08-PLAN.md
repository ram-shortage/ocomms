---
phase: 29-stabilization
plan: 08
type: execute
wave: 3
depends_on: ["29-02"]
files_modified:
  - src/lib/actions/__tests__/user-status.test.ts
  - src/lib/actions/__tests__/user-group.test.ts
  - src/lib/actions/__tests__/link-preview.test.ts
autonomous: true

must_haves:
  truths:
    - "Tests verify user status lookup requires auth and org membership"
    - "Tests verify group member list requires org membership"
    - "Tests verify link preview fetch requires message access"
  artifacts:
    - path: "src/lib/actions/__tests__/user-status.test.ts"
      provides: "Auth tests for user status actions"
      min_lines: 80
    - path: "src/lib/actions/__tests__/user-group.test.ts"
      provides: "Auth tests for user group actions"
      min_lines: 60
    - path: "src/lib/actions/__tests__/link-preview.test.ts"
      provides: "Auth tests for link preview actions"
      min_lines: 60
  key_links:
    - from: "test files"
      to: "source actions"
      via: "database mocking pattern"
      pattern: "vi\\.mock\\(\"@/db\""
---

<objective>
Create unit tests proving security fixes for M-8, M-9, M-10 are in place.

Purpose: Verify server action authorization checks are correctly implemented (TEST-01, TEST-04).
Output: Test files using database mocking pattern to test authorization logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-stabilization/29-RESEARCH.md
@.planning/phases/29-stabilization/29-02-SUMMARY.md (after Plan 02 completes)

Pattern reference:
@src/lib/actions/__tests__/channels.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user status action authorization tests</name>
  <files>src/lib/actions/__tests__/user-status.test.ts</files>
  <action>
Create test file using database mocking pattern from channels.test.ts:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { getUserStatus, setUserStatus, clearUserStatus } from "../user-status";

// Mock next/headers
vi.mock("next/headers", () => ({
  headers: vi.fn().mockResolvedValue(new Headers()),
}));

// Mock next/cache
vi.mock("next/cache", () => ({
  revalidatePath: vi.fn(),
}));

// Mock auth
const mockGetSession = vi.fn();
vi.mock("@/lib/auth", () => ({
  auth: {
    api: {
      getSession: (...args: unknown[]) => mockGetSession(...args),
    },
  },
}));

// Mock database
const mockFindFirst = vi.fn();
const mockInsert = vi.fn();
const mockUpdate = vi.fn();
const mockDelete = vi.fn();

vi.mock("@/db", () => ({
  db: {
    query: {
      userStatuses: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
      members: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
    },
    insert: (...args: unknown[]) => mockInsert(...args),
    update: (...args: unknown[]) => mockUpdate(...args),
    delete: (...args: unknown[]) => mockDelete(...args),
  },
}));

describe("User Status Actions (M-8 fix)", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockGetSession.mockResolvedValue({
      user: { id: "user-123", name: "Test User" },
    });
  });

  describe("getUserStatus", () => {
    it("rejects unauthenticated requests", async () => {
      mockGetSession.mockResolvedValue(null);

      await expect(getUserStatus("other-user-id", "org-123")).rejects.toThrow("Unauthorized");
    });

    it("allows self-lookup without organization context", async () => {
      mockFindFirst.mockResolvedValueOnce({ id: "status-1", emoji: "..." });

      const result = await getUserStatus("user-123");

      expect(result).toBeDefined();
      expect(result?.emoji).toBe("...");
    });

    it("rejects cross-user lookup without organization context", async () => {
      await expect(getUserStatus("other-user-id")).rejects.toThrow(
        "Organization context required"
      );
    });

    it("verifies organization membership for cross-user lookup", async () => {
      // Mock: requester is NOT in the organization
      mockFindFirst.mockResolvedValueOnce(null); // org membership check fails

      await expect(getUserStatus("other-user-id", "org-123")).rejects.toThrow(
        "Not authorized"
      );
    });

    it("returns status when requester and target share organization", async () => {
      // Mock: requester is in org
      mockFindFirst
        .mockResolvedValueOnce({ id: "member-1" }) // requester org membership
        .mockResolvedValueOnce({ id: "member-2" }) // target org membership
        .mockResolvedValueOnce({ id: "status-1", emoji: "..." }); // status

      const result = await getUserStatus("other-user-id", "org-123");

      expect(result).toBeDefined();
    });
  });

  describe("setUserStatus", () => {
    it("rejects unauthenticated requests", async () => {
      mockGetSession.mockResolvedValue(null);

      await expect(setUserStatus({ emoji: "...", text: "test" })).rejects.toThrow("Unauthorized");
    });

    it("creates status for authenticated user", async () => {
      mockFindFirst.mockResolvedValueOnce(null); // no existing status
      mockInsert.mockReturnValue({
        values: () => ({ returning: () => Promise.resolve([{ id: "status-1" }]) }),
      });

      const result = await setUserStatus({ emoji: "...", text: "test", dndEnabled: false });

      expect(result).toBeDefined();
      expect(mockInsert).toHaveBeenCalled();
    });
  });
});
```
  </action>
  <verify>
Run `npm test src/lib/actions/__tests__/user-status.test.ts`:
- All tests pass
- Tests verify auth required
- Tests verify org membership for cross-user lookup
- Tests use correct mocking pattern
  </verify>
  <done>
User status action tests verify M-8 authorization fix is in place
  </done>
</task>

<task type="auto">
  <name>Task 2: Create user group action authorization tests</name>
  <files>src/lib/actions/__tests__/user-group.test.ts</files>
  <action>
Create test file:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { getGroupMembers, getGroupByHandle } from "../user-group";

// Standard mocks (same as user-status.test.ts)
vi.mock("next/headers", () => ({
  headers: vi.fn().mockResolvedValue(new Headers()),
}));

const mockGetSession = vi.fn();
vi.mock("@/lib/auth", () => ({
  auth: { api: { getSession: (...args: unknown[]) => mockGetSession(...args) } },
}));

const mockFindFirst = vi.fn();
const mockFindMany = vi.fn();
vi.mock("@/db", () => ({
  db: {
    query: {
      userGroups: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
      userGroupMembers: { findMany: (...args: unknown[]) => mockFindMany(...args) },
      members: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
    },
  },
}));

describe("User Group Actions (M-9 and L-4 fixes)", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockGetSession.mockResolvedValue({
      user: { id: "user-123" },
    });
  });

  describe("getGroupMembers (M-9)", () => {
    it("rejects unauthenticated requests", async () => {
      mockGetSession.mockResolvedValue(null);

      await expect(getGroupMembers("group-123")).rejects.toThrow("Unauthorized");
    });

    it("rejects when group not found", async () => {
      mockFindFirst.mockResolvedValueOnce(null); // group not found

      await expect(getGroupMembers("group-123")).rejects.toThrow("Group not found");
    });

    it("rejects when requester not in group organization", async () => {
      // Group exists
      mockFindFirst.mockResolvedValueOnce({ id: "group-123", organizationId: "org-456" });
      // But requester is not a member
      mockFindFirst.mockResolvedValueOnce(null);

      await expect(getGroupMembers("group-123")).rejects.toThrow("Not authorized");
    });

    it("returns members when requester is in organization", async () => {
      mockFindFirst
        .mockResolvedValueOnce({ id: "group-123", organizationId: "org-456" }) // group
        .mockResolvedValueOnce({ id: "member-1" }); // org membership
      mockFindMany.mockResolvedValueOnce([
        { userId: "user-1", user: { name: "Alice" } },
        { userId: "user-2", user: { name: "Bob" } },
      ]);

      const result = await getGroupMembers("group-123");

      expect(result).toHaveLength(2);
    });
  });

  describe("getGroupByHandle (L-4)", () => {
    it("rejects unauthenticated requests", async () => {
      mockGetSession.mockResolvedValue(null);

      await expect(getGroupByHandle("designers", "org-123")).rejects.toThrow("Unauthorized");
    });

    it("verifies organization membership", async () => {
      mockFindFirst.mockResolvedValueOnce(null); // not a member

      await expect(getGroupByHandle("designers", "org-123")).rejects.toThrow("Not authorized");
    });

    it("returns group when authorized", async () => {
      mockFindFirst
        .mockResolvedValueOnce({ id: "member-1" }) // org membership
        .mockResolvedValueOnce({ id: "group-1", handle: "designers" }); // group

      const result = await getGroupByHandle("designers", "org-123");

      expect(result).toBeDefined();
      expect(result?.handle).toBe("designers");
    });
  });
});
```
  </action>
  <verify>
Run `npm test src/lib/actions/__tests__/user-group.test.ts`:
- All tests pass
- Tests verify M-9 (getGroupMembers requires org membership)
- Tests verify L-4 (getGroupByHandle requires auth and org membership)
  </verify>
  <done>
User group action tests verify M-9 and L-4 authorization fixes are in place
  </done>
</task>

<task type="auto">
  <name>Task 3: Create link preview action authorization tests</name>
  <files>src/lib/actions/__tests__/link-preview.test.ts</files>
  <action>
Create test file:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { getLinkPreviews } from "../link-preview";

// Standard mocks
vi.mock("next/headers", () => ({
  headers: vi.fn().mockResolvedValue(new Headers()),
}));

const mockGetSession = vi.fn();
vi.mock("@/lib/auth", () => ({
  auth: { api: { getSession: (...args: unknown[]) => mockGetSession(...args) } },
}));

const mockFindFirst = vi.fn();
const mockFindMany = vi.fn();
vi.mock("@/db", () => ({
  db: {
    query: {
      messages: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
      channelMembers: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
      conversationParticipants: { findFirst: (...args: unknown[]) => mockFindFirst(...args) },
      linkPreviews: { findMany: (...args: unknown[]) => mockFindMany(...args) },
    },
  },
}));

describe("Link Preview Actions (M-10 fix)", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockGetSession.mockResolvedValue({
      user: { id: "user-123" },
    });
  });

  describe("getLinkPreviews", () => {
    it("rejects unauthenticated requests", async () => {
      mockGetSession.mockResolvedValue(null);

      await expect(getLinkPreviews("msg-123")).rejects.toThrow("Unauthorized");
    });

    it("rejects when message not found", async () => {
      mockFindFirst.mockResolvedValueOnce(null); // message not found

      await expect(getLinkPreviews("msg-123")).rejects.toThrow("Message not found");
    });

    it("rejects when user not a channel member", async () => {
      // Message in a channel
      mockFindFirst.mockResolvedValueOnce({ id: "msg-123", channelId: "ch-456", conversationId: null });
      // User not a member
      mockFindFirst.mockResolvedValueOnce(null);

      await expect(getLinkPreviews("msg-123")).rejects.toThrow("Not authorized");
    });

    it("rejects when user not a conversation participant", async () => {
      // Message in a DM
      mockFindFirst.mockResolvedValueOnce({ id: "msg-123", channelId: null, conversationId: "conv-789" });
      // User not a participant
      mockFindFirst.mockResolvedValueOnce(null);

      await expect(getLinkPreviews("msg-123")).rejects.toThrow("Not authorized");
    });

    it("returns previews for channel member", async () => {
      mockFindFirst
        .mockResolvedValueOnce({ id: "msg-123", channelId: "ch-456", conversationId: null })
        .mockResolvedValueOnce({ id: "member-1" }); // is member
      mockFindMany.mockResolvedValueOnce([
        { id: "preview-1", url: "https://example.com", title: "Example" },
      ]);

      const result = await getLinkPreviews("msg-123");

      expect(result).toHaveLength(1);
      expect(result[0].title).toBe("Example");
    });

    it("returns previews for conversation participant", async () => {
      mockFindFirst
        .mockResolvedValueOnce({ id: "msg-123", channelId: null, conversationId: "conv-789" })
        .mockResolvedValueOnce({ id: "participant-1" }); // is participant
      mockFindMany.mockResolvedValueOnce([
        { id: "preview-1", url: "https://example.com", title: "Example" },
      ]);

      const result = await getLinkPreviews("msg-123");

      expect(result).toHaveLength(1);
    });
  });
});
```
  </action>
  <verify>
Run `npm test src/lib/actions/__tests__/link-preview.test.ts`:
- All tests pass
- Tests verify auth required
- Tests verify channel membership for channel messages
- Tests verify conversation participation for DM messages
  </verify>
  <done>
Link preview action tests verify M-10 authorization fix is in place
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `npm test` - all new tests pass
2. Run `npm run lint` - no lint errors in test files
3. Tests use established database mocking pattern
4. Tests cover both positive (authorized) and negative (unauthorized) cases
</verification>

<success_criteria>
- user-status.test.ts validates M-8 fix (auth + org membership for cross-user status)
- user-group.test.ts validates M-9 fix (org membership for group members) and L-4 fix
- link-preview.test.ts validates M-10 fix (message access for previews)
- All tests follow channels.test.ts mocking pattern
- Tests pass in CI
</success_criteria>

<output>
After completion, create `.planning/phases/29-stabilization/29-08-SUMMARY.md`
</output>
