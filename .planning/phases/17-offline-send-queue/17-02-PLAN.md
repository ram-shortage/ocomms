---
phase: 17-offline-send-queue
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - src/lib/cache/queue-processor.ts
  - src/lib/cache/sync-on-reconnect.ts
  - src/lib/cache/index.ts
autonomous: true

must_haves:
  truths:
    - "Queued messages send automatically when online"
    - "Network reconnect triggers queue processing"
    - "Tab visibility triggers queue processing (Safari fallback)"
    - "Failed sends increment retry count with backoff delay"
  artifacts:
    - path: "src/lib/cache/queue-processor.ts"
      provides: "Queue processing with socket integration"
      exports: ["processQueue", "registerBackgroundSync"]
    - path: "src/lib/cache/sync-on-reconnect.ts"
      provides: "Event listeners for sync triggers"
      exports: ["initSyncOnReconnect", "cleanupSyncListeners"]
  key_links:
    - from: "src/lib/cache/queue-processor.ts"
      to: "src/lib/cache/send-queue.ts"
      via: "imports queue operations"
      pattern: "from.*send-queue"
    - from: "src/lib/cache/queue-processor.ts"
      to: "src/lib/retry/backoff.ts"
      via: "imports backoff utilities"
      pattern: "from.*backoff"
    - from: "src/lib/cache/sync-on-reconnect.ts"
      to: "src/lib/cache/queue-processor.ts"
      via: "calls processQueue on events"
      pattern: "processQueue"
---

<objective>
Create queue processing logic that sends pending messages via Socket.io with retry support.

Purpose: Messages queued offline must automatically send when network returns, with exponential backoff for failures and support for both Chrome Background Sync and Safari fallback events.

Output: Queue processor with socket integration, sync event listeners for online/visibility/socket connect events.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-offline-send-queue/17-RESEARCH.md

# Prior plan context - queue infrastructure (MUST BE COMPLETE)
# Read this summary to understand available queue operations
@.planning/phases/17-offline-send-queue/17-01-SUMMARY.md

@src/lib/socket-events.ts
@src/lib/socket-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create queue processor with socket integration</name>
  <files>src/lib/cache/queue-processor.ts</files>
  <action>
Create queue-processor.ts that processes pending messages via Socket.io:

1. Import dependencies:
   - getPendingMessages, updateQueueStatus, removeFromQueue from "./send-queue"
   - calculateBackoff, shouldRetry, sleep from "@/lib/retry/backoff"
   - Socket type from "socket.io-client"

2. Module-level state:
   - let isProcessing = false (prevents concurrent processing)

3. processQueue(socket: Socket): Promise<void>
   - Guard: if isProcessing || !navigator.onLine, return early
   - Set isProcessing = true in try block, false in finally

   - Get pending messages with getPendingMessages()
   - For each message:
     a. Skip if failed and !shouldRetry(msg.retryCount)
     b. Apply backoff delay if retryCount > 0: await sleep(calculateBackoff(msg.retryCount))
     c. Update status to "sending": await updateQueueStatus(msg.clientId, "sending")
     d. Send via socket with callback:
        - For channel/dm: socket.emit("message:send", {targetId, targetType, content}, callback)
        - For thread (parentId not null): socket.emit("thread:reply", {parentId, content}, callback)
        - Wrap in Promise with 10 second timeout
     e. On success (response.success && response.messageId):
        - Update status to "sent" with serverId
        - Remove from queue: await removeFromQueue(msg.clientId)
     f. On failure:
        - Update status to "failed" with incremented retryCount and lastError

4. registerBackgroundSync(): Promise<void>
   - Check for Background Sync API: "serviceWorker" in navigator && "SyncManager" in window
   - If available: await navigator.serviceWorker.ready then registration.sync.register("send-messages")
   - Catch and log errors (not critical - fallback exists)

Add console.log with [QueueProcessor] prefix for debugging.

IMPORTANT: Handle rate limit errors specially - if error.code === "RATE_LIMITED" and error.retryAfter, use that duration instead of exponential backoff for next attempt.
  </action>
  <verify>
TypeScript compiles:
```
npx tsc --noEmit src/lib/cache/queue-processor.ts
```
  </verify>
  <done>
queue-processor.ts exports processQueue and registerBackgroundSync functions. Queue processes messages with backoff, handles both message:send and thread:reply events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sync-on-reconnect listeners</name>
  <files>src/lib/cache/sync-on-reconnect.ts</files>
  <action>
Create sync-on-reconnect.ts that sets up event listeners to trigger queue processing:

1. Import dependencies:
   - processQueue from "./queue-processor"
   - Socket type from "socket.io-client"

2. Module-level state:
   - let socket: Socket | null = null

3. initSyncOnReconnect(socketInstance: Socket): void
   - Store socket reference
   - Add event listeners:
     a. window.addEventListener("online", handleOnline)
     b. document.addEventListener("visibilitychange", handleVisibilityChange)
     c. socketInstance.on("connect", handleSocketConnect)

4. handleOnline(): void
   - Log: "[Sync] Online event - processing queue"
   - If socket?.connected: processQueue(socket).catch(console.error)

5. handleVisibilityChange(): void
   - If document.visibilityState === "visible" && navigator.onLine && socket?.connected:
     - Log: "[Sync] Tab visible - processing queue"
     - processQueue(socket).catch(console.error)

6. handleSocketConnect(): void
   - Log: "[Sync] Socket connected - processing queue"
   - Add random jitter delay (0-500ms) to avoid thundering herd:
     const jitter = Math.random() * 500
     setTimeout(() => { if (socket) processQueue(socket).catch(console.error) }, jitter)

7. cleanupSyncListeners(): void
   - window.removeEventListener("online", handleOnline)
   - document.removeEventListener("visibilitychange", handleVisibilityChange)
   - if (socket) socket.off("connect", handleSocketConnect)
   - socket = null

Use [Sync] prefix for console logs.
  </action>
  <verify>
TypeScript compiles:
```
npx tsc --noEmit src/lib/cache/sync-on-reconnect.ts
```
  </verify>
  <done>
sync-on-reconnect.ts exports initSyncOnReconnect and cleanupSyncListeners. Listeners trigger processQueue on online, visibilitychange, and socket connect events.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update cache barrel exports</name>
  <files>src/lib/cache/index.ts</files>
  <action>
Add exports for queue processor and sync modules:

1. Export from "./queue-processor":
   - processQueue
   - registerBackgroundSync

2. Export from "./sync-on-reconnect":
   - initSyncOnReconnect
   - cleanupSyncListeners

Keep existing exports unchanged.
  </action>
  <verify>
TypeScript compiles and exports available:
```
npx tsc --noEmit src/lib/cache/index.ts
```
  </verify>
  <done>
index.ts exports processQueue, registerBackgroundSync, initSyncOnReconnect, cleanupSyncListeners from cache module.
  </done>
</task>

</tasks>

<verification>
1. All TypeScript files compile without errors
2. processQueue correctly handles both message:send and thread:reply
3. Backoff delays applied between retry attempts
4. Sync listeners trigger on online, visibility, and socket connect events
5. Jitter applied to socket connect to avoid thundering herd
</verification>

<success_criteria>
- Queue processor sends pending messages via socket when online
- Failed sends retry with exponential backoff (1s, 2s, 4s, 8s...)
- Messages exceeding 5 retries are skipped (marked failed)
- Reconnect events trigger queue processing
- Rate limit errors respected (use server's retryAfter)
</success_criteria>

<output>
After completion, create `.planning/phases/17-offline-send-queue/17-02-SUMMARY.md`
</output>
