---
phase: 17-offline-send-queue
plan: 03
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - src/hooks/use-send-message.ts
  - src/lib/cache/use-send-queue.ts
  - src/components/message/message-input.tsx
  - src/components/message/message-list.tsx
  - src/lib/cache/index.ts
autonomous: true

must_haves:
  truths:
    - "User can type and submit a message while offline"
    - "Message appears immediately in UI before server confirmation"
    - "Pending messages show in message list with optimistic display"
  artifacts:
    - path: "src/hooks/use-send-message.ts"
      provides: "Hook combining queue + optimistic UI"
      exports: ["useSendMessage"]
    - path: "src/lib/cache/use-send-queue.ts"
      provides: "Reactive hook for pending messages"
      exports: ["useSendQueue"]
    - path: "src/components/message/message-input.tsx"
      provides: "Updated input using useSendMessage"
      contains: "useSendMessage"
    - path: "src/components/message/message-list.tsx"
      provides: "Message list with pending messages merged"
      contains: "useSendQueue"
  key_links:
    - from: "src/hooks/use-send-message.ts"
      to: "src/lib/cache/send-queue.ts"
      via: "imports queueMessage"
      pattern: "queueMessage"
    - from: "src/components/message/message-input.tsx"
      to: "src/hooks/use-send-message.ts"
      via: "uses hook for sending"
      pattern: "useSendMessage"
    - from: "src/components/message/message-list.tsx"
      to: "src/lib/cache/use-send-queue.ts"
      via: "merges pending messages"
      pattern: "useSendQueue"
---

<objective>
Create optimistic UI hooks and integrate them into MessageInput and MessageList components.

Purpose: Users must see their message appear instantly when they hit send, even while offline. This requires hooks that queue messages locally and display them optimistically until server confirmation.

Output: useSendMessage hook for queueing, useSendQueue hook for display, updated components.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-offline-send-queue/17-RESEARCH.md

# Prior plan context - queue infrastructure (MUST BE COMPLETE)
@.planning/phases/17-offline-send-queue/17-01-SUMMARY.md

@src/components/message/message-input.tsx
@src/components/message/message-list.tsx
@src/lib/socket-client.ts
@src/lib/pwa/use-online-status.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useSendMessage hook</name>
  <files>src/hooks/use-send-message.ts</files>
  <action>
Create src/hooks/use-send-message.ts (create hooks directory if needed):

"use client";

1. Import dependencies:
   - useCallback from "react"
   - useSocket from "@/lib/socket-client"
   - useOnlineStatus from "@/lib/pwa/use-online-status"
   - queueMessage, processQueue, registerBackgroundSync from "@/lib/cache"
   - QueuedMessage type from "@/lib/cache"

2. Interface UseSendMessageOptions:
   - targetId: string
   - targetType: "channel" | "dm"
   - parentId?: string | null (for thread replies)

3. Interface UseSendMessageReturn:
   - sendMessage: (content: string) => Promise<{ clientId: string }>
   - isOnline: boolean

4. useSendMessage hook:
   - Get socket from useSocket()
   - Get isOnline from useOnlineStatus()

   - sendMessage callback (wrapped in useCallback):
     a. Generate clientId with crypto.randomUUID()
     b. Create message object (Omit<QueuedMessage, "retryCount" | "lastError" | "lastAttemptAt">):
        - clientId
        - serverId: null
        - content: content.trim()
        - targetId
        - targetType
        - parentId: parentId ?? null
        - status: "pending"
        - createdAt: new Date()
     c. Always queue to IndexedDB first: await queueMessage(message)
     d. If isOnline:
        - Process immediately: processQueue(socket).catch(console.error)
     e. If offline:
        - Register background sync: registerBackgroundSync().catch(console.error)
     f. Return { clientId }

   - Return { sendMessage, isOnline }

Note: processQueue import comes from queue-processor via cache barrel (from 17-02, may need to import directly if running parallel).
  </action>
  <verify>
TypeScript compiles:
```
npx tsc --noEmit src/hooks/use-send-message.ts
```
  </verify>
  <done>
useSendMessage hook exports sendMessage function that queues messages locally and triggers processing when online.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useSendQueue hook for reactive display</name>
  <files>src/lib/cache/use-send-queue.ts, src/lib/cache/index.ts</files>
  <action>
Create src/lib/cache/use-send-queue.ts:

"use client";

1. Import dependencies:
   - useLiveQuery from "dexie-react-hooks"
   - db, QueuedMessage from "./db"

2. useSendQueue(targetId: string | null): QueuedMessage[]
   - If targetId is null, return empty array (SSR safety + conditional use)
   - Use useLiveQuery to query sendQueue:
     - Return db.sendQueue
       .where("targetId").equals(targetId)
       .filter(msg => msg.status !== "sent")
       .sortBy("createdAt")
   - Default value: [] (empty array while loading)
   - Dependencies: [targetId]

3. Export useSendQueue

Update src/lib/cache/index.ts:
- Add export for useSendQueue from "./use-send-queue"

Note: useLiveQuery automatically re-renders when IndexedDB data changes, providing reactive updates.
  </action>
  <verify>
TypeScript compiles:
```
npx tsc --noEmit src/lib/cache/use-send-queue.ts src/lib/cache/index.ts
```
  </verify>
  <done>
useSendQueue hook provides reactive array of pending messages for a target, updates automatically when queue changes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update MessageInput to use useSendMessage</name>
  <files>src/components/message/message-input.tsx</files>
  <action>
Update MessageInput to use the new useSendMessage hook:

1. Add import:
   - useSendMessage from "@/hooks/use-send-message"

2. Inside component, call hook:
   - const { sendMessage: queueAndSend, isOnline } = useSendMessage({ targetId, targetType })

3. Update sendMessage callback:
   - Replace direct socket.emit with queueAndSend(content.trim())
   - Keep setIsSending(true) before call
   - On success: setContent(""), setIsSending(false)
   - On error: setIsSending(false), log error

4. Update disabled state:
   - Remove the socket.emit callback pattern
   - Simplify: just call queueAndSend and clear input

5. Keep existing rate limit handling - this still applies server-side

6. Optionally show offline indicator:
   - If !isOnline, show small text "(offline - will send when connected)"
   - Place below character counter, only when offline

Note: The optimistic display happens in MessageList via useSendQueue. MessageInput just needs to queue and clear.
  </action>
  <verify>
TypeScript compiles:
```
npx tsc --noEmit src/components/message/message-input.tsx
```

Manual test: Type a message and submit - should queue (check console for [Cache] log).
  </verify>
  <done>
MessageInput uses useSendMessage hook. Messages queue to IndexedDB immediately. Input clears on submit.
  </done>
</task>

</tasks>

<verification>
1. All TypeScript files compile without errors
2. useSendMessage queues messages with clientId
3. useSendQueue reactively returns pending messages
4. MessageInput clears on submit regardless of online status
5. Messages appear in queue (can verify with browser DevTools > Application > IndexedDB)
</verification>

<success_criteria>
- User can submit message while offline (input clears, no error)
- Message queued to IndexedDB with status "pending"
- useSendQueue returns pending messages for display
- processQueue called when online, registerBackgroundSync called when offline
</success_criteria>

<output>
After completion, create `.planning/phases/17-offline-send-queue/17-03-SUMMARY.md`
</output>
