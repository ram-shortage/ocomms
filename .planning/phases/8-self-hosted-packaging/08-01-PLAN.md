---
phase: 08-self-hosted-packaging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - docker-compose.yml
  - docker-compose.dev.yml
  - nginx/conf.d/default.conf
  - scripts/build-server.ts
  - scripts/migrate.ts
  - src/app/api/health/route.ts
  - next.config.ts
  - .env.example
  - .dockerignore
autonomous: true

must_haves:
  truths:
    - "Platform deploys with single docker-compose command"
    - "Platform runs without external service dependencies"
    - "All services start in correct order (db -> app -> nginx)"
    - "WebSocket connections work through nginx proxy"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage build with esbuild-bundled custom server"
      contains: "FROM node:22-alpine"
    - path: "docker-compose.yml"
      provides: "Production orchestration"
      contains: "services:"
    - path: "nginx/conf.d/default.conf"
      provides: "Reverse proxy with WebSocket support"
      contains: "proxy_http_version 1.1"
    - path: "src/app/api/health/route.ts"
      provides: "Health check endpoint for Docker"
      exports: ["GET"]
  key_links:
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build context"
      pattern: "build:"
    - from: "nginx/conf.d/default.conf"
      to: "app:3000"
      via: "upstream proxy"
      pattern: "proxy_pass http://app"
    - from: "docker-compose.yml"
      to: "db service"
      via: "depends_on with health check"
      pattern: "condition: service_healthy"
---

<objective>
Create Docker deployment infrastructure for single-command self-hosted deployment.

Purpose: Enable admins to deploy OComms with `docker compose up -d` without external dependencies.
Output: Dockerfile, docker-compose.yml, nginx config, health check endpoint, build scripts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/8-self-hosted-packaging/08-RESEARCH.md

# Key existing files
@src/server/index.ts
@package.json
@next.config.ts
@drizzle.config.ts
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dockerfile and build infrastructure</name>
  <files>
    Dockerfile
    .dockerignore
    scripts/build-server.ts
    scripts/migrate.ts
    next.config.ts
    package.json
  </files>
  <action>
1. Update next.config.ts to enable standalone output mode:
   ```typescript
   const nextConfig: NextConfig = {
     output: "standalone",
   };
   ```

2. Create .dockerignore to exclude dev files:
   ```
   .git
   .next
   node_modules
   dist
   dist-server
   .env
   .env.local
   *.log
   .planning
   ```

3. Create scripts/build-server.ts for esbuild bundling:
   - Entry: src/server/index.ts
   - Output: dist-server/index.js
   - Platform: node, target: node22
   - Bundle: true, minify: true, sourcemap: true
   - External: next, sharp, lightningcss (native addons)

4. Create scripts/migrate.ts for programmatic migration:
   - Import drizzle and migrate from drizzle-orm/postgres-js/migrator
   - Run migrations from ./src/db/migrations folder
   - Exit cleanly after completion

5. Create multi-stage Dockerfile:
   - Stage 1 (deps): Install dependencies with npm ci
   - Stage 2 (builder): Build Next.js and bundle server with esbuild
   - Stage 3 (runner): Production image with non-root user
   - Copy standalone output, static files, public folder, bundled server, node_modules/next
   - Set NODE_ENV=production, HOSTNAME=0.0.0.0
   - Expose port 3000
   - CMD: node index.js

6. Add esbuild to devDependencies in package.json:
   ```json
   "esbuild": "^0.24.0"
   ```

7. Add build:docker script to package.json:
   ```json
   "build:docker": "npm run build && tsx scripts/build-server.ts"
   ```
  </action>
  <verify>
    - `cat Dockerfile` shows multi-stage build
    - `cat next.config.ts` shows output: "standalone"
    - `cat scripts/build-server.ts` shows esbuild config
    - `npm install` succeeds with esbuild
  </verify>
  <done>
    Dockerfile exists with multi-stage build, standalone mode enabled, server bundler script created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Docker Compose and nginx configuration</name>
  <files>
    docker-compose.yml
    docker-compose.dev.yml
    nginx/conf.d/default.conf
    src/app/api/health/route.ts
    .env.example
  </files>
  <action>
1. Create src/app/api/health/route.ts health check endpoint:
   - GET handler that checks database connectivity with `db.execute(sql\`SELECT 1\`)`
   - Return { status: "healthy", timestamp } on success (200)
   - Return { status: "unhealthy", error } on failure (503)

2. Create docker-compose.yml for production:
   Services:
   - nginx: nginx:1.25-alpine
     - Ports: 80:80
     - Volumes: ./nginx/conf.d:/etc/nginx/conf.d:ro
     - depends_on: app (service_healthy)
     - restart: unless-stopped

   - app: build from Dockerfile
     - Environment (from .env):
       - DATABASE_URL=postgresql://postgres:${DB_PASSWORD}@db:5432/ocomms
       - REDIS_URL=redis://redis:6379
       - BETTER_AUTH_SECRET=${AUTH_SECRET}
       - BETTER_AUTH_URL=${APP_URL}
       - NEXT_PUBLIC_APP_URL=${APP_URL}
       - SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS, EMAIL_FROM
     - depends_on: db (service_healthy), redis (service_started)
     - healthcheck: wget -q --spider http://localhost:3000/api/health
       - interval: 30s, timeout: 10s, retries: 3, start_period: 40s
     - restart: unless-stopped

   - db: postgres:16-alpine
     - Environment: POSTGRES_USER, POSTGRES_PASSWORD (from DB_PASSWORD), POSTGRES_DB
     - Volumes: postgres_data:/var/lib/postgresql/data, ./backups:/backups
     - healthcheck: pg_isready -U postgres
       - interval: 10s, timeout: 5s, retries: 5, start_period: 30s
     - restart: unless-stopped

   - redis: redis:7-alpine
     - Command: redis-server --appendonly yes
     - Volumes: redis_data:/data
     - healthcheck: redis-cli ping
     - restart: unless-stopped

   Volumes: postgres_data, redis_data

3. Create docker-compose.dev.yml for local development:
   - Only db and redis services (app runs on host)
   - Map ports: 5432:5432 for db, 6379:6379 for redis
   - No nginx (dev uses Next.js dev server directly)

4. Create nginx/conf.d/default.conf:
   - Upstream: app:3000
   - Server block on port 80
   - Location / with proxy_pass, Host, X-Real-IP, X-Forwarded-For, X-Forwarded-Proto headers
   - Location /socket.io/ with WebSocket upgrade:
     - proxy_http_version 1.1
     - Upgrade and Connection headers
     - proxy_read_timeout 86400 for long-lived connections

5. Update .env.example with Docker-specific variables:
   ```
   # Database
   DATABASE_URL=postgresql://postgres:changeme@localhost:5432/ocomms
   DB_PASSWORD=changeme

   # Auth
   BETTER_AUTH_SECRET=generate-a-secret-here
   AUTH_SECRET=generate-a-secret-here
   BETTER_AUTH_URL=http://localhost:3000

   # App URL (change for production)
   APP_URL=http://localhost
   NEXT_PUBLIC_APP_URL=http://localhost

   # SMTP (optional for dev)
   SMTP_HOST=
   SMTP_PORT=587
   SMTP_USER=
   SMTP_PASS=
   EMAIL_FROM=

   # Redis (optional - falls back to in-memory)
   REDIS_URL=redis://localhost:6379
   ```
  </action>
  <verify>
    - `cat docker-compose.yml` shows all four services with health checks
    - `cat nginx/conf.d/default.conf` shows WebSocket upgrade config
    - `cat src/app/api/health/route.ts` shows database check
    - `cat docker-compose.dev.yml` shows db and redis only
  </verify>
  <done>
    Docker Compose files created with health checks, nginx configured for WebSocket proxy, health endpoint exists.
  </done>
</task>

</tasks>

<verification>
1. All files exist:
   - Dockerfile, .dockerignore
   - docker-compose.yml, docker-compose.dev.yml
   - nginx/conf.d/default.conf
   - scripts/build-server.ts, scripts/migrate.ts
   - src/app/api/health/route.ts

2. Configuration valid:
   - next.config.ts has output: "standalone"
   - package.json has esbuild and build:docker script
   - .env.example has all required variables

3. Structural integrity:
   - docker-compose.yml has depends_on with conditions
   - nginx config has WebSocket headers
   - Dockerfile uses non-root user
</verification>

<success_criteria>
- Platform can be built with `docker compose build`
- Health check endpoint responds at /api/health
- Nginx config supports WebSocket upgrades
- All services have health checks defined
</success_criteria>

<output>
After completion, create `.planning/phases/8-self-hosted-packaging/08-01-SUMMARY.md`
</output>
