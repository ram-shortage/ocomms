---
phase: 14-security-fixes
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/socket/handlers/notification.ts
  - src/components/message/message-input.tsx
  - src/lib/socket-events.ts
autonomous: true

must_haves:
  truths:
    - "@mention autocomplete only shows users in the same organization"
    - "Character counter always visible showing current/max format"
    - "Send button disabled when over limit with red counter"
    - "Rate limit feedback displays inline below input"
  artifacts:
    - path: "src/server/socket/handlers/notification.ts"
      provides: "Organization-scoped mention resolution"
      contains: "innerJoin.*members"
    - path: "src/components/message/message-input.tsx"
      provides: "Character counter and rate limit UI"
      contains: "MAX_MESSAGE_LENGTH"
    - path: "src/lib/socket-events.ts"
      provides: "Error event types"
      contains: "RATE_LIMITED"
  key_links:
    - from: "src/server/socket/handlers/notification.ts"
      to: "members table"
      via: "inner join on organizationId"
      pattern: "eq.*members.organizationId"
    - from: "src/components/message/message-input.tsx"
      to: "socket error event"
      via: "socket.on error handler"
      pattern: "socket.on.*error"
---

<objective>
Fix @mention scoping to organization, add client-side character counter and rate limit UI, and verify URL handling.

Purpose: Prevent cross-organization mention leakage, provide clear input validation feedback, and handle rate limiting gracefully in the UI.

Output: Updated notification.ts with org-scoped mentions, message-input.tsx with character counter and rate limit UI.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-security-fixes/14-CONTEXT.md
@.planning/phases/14-security-fixes/14-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scope @mention resolution to organization (SECFIX-01)</name>
  <files>src/server/socket/handlers/notification.ts</files>
  <action>
Update the createNotifications function to scope user mention lookups to the organization.

The current code (lines 99-105) queries users by name without organization filtering:
```typescript
const [targetUser] = await db
  .select({ id: users.id })
  .from(users)
  .where(eq(users.name, mention.value))
  .limit(1);
```

Add organization-scoped lookup. The function already receives workspaceId parameter (which is organizationId).

1. Add members import if not present (it is in the imports but as channelMembers, need org members):
```typescript
import { notifications, users, channelMembers, channels, channelNotificationSettings, members } from "@/db/schema";
```

2. Update the user mention lookup in createNotifications (inside the `if (mention.type === "user")` block):
```typescript
if (mention.type === "user") {
  // SECFIX-01: Scope user lookup to organization
  let targetUser: { id: string } | undefined;

  if (workspaceId) {
    // Channel context - require org membership
    const [result] = await db
      .select({ id: users.id })
      .from(users)
      .innerJoin(members, eq(members.userId, users.id))
      .where(
        and(
          eq(users.name, mention.value),
          eq(members.organizationId, workspaceId)
        )
      )
      .limit(1);
    targetUser = result;
  } else if (conversationId) {
    // DM context - lookup by name (DMs are already scoped to conversation participants)
    const [result] = await db
      .select({ id: users.id })
      .from(users)
      .where(eq(users.name, mention.value))
      .limit(1);
    targetUser = result;
  }

  if (targetUser && targetUser.id !== senderId && !notifiedUserIds.has(targetUser.id)) {
    // ... rest of existing logic unchanged
  }
}
```

This ensures that @mentions in channels only resolve to users who are members of the same organization.
  </action>
  <verify>
Read the updated notification.ts and confirm:
1. members is imported from db/schema
2. User mention lookup uses innerJoin with members table when workspaceId is set
3. The query filters by members.organizationId = workspaceId
4. DM context still uses simple name lookup (DMs are already scoped)
  </verify>
  <done>@mention resolution is scoped to organization membership</done>
</task>

<task type="auto">
  <name>Task 2: Add character counter and rate limit UI to message input (SECFIX-05 client, SECFIX-06 client)</name>
  <files>src/components/message/message-input.tsx, src/lib/socket-events.ts</files>
  <action>
Update message-input.tsx with character counter and rate limit feedback per CONTEXT.md decisions.

1. First, update socket-events.ts to add error codes to the ServerToClientEvents error type if not present:
```typescript
// In ServerToClientEvents interface, ensure error has proper structure:
error: (data: { message: string; code?: string; retryAfter?: number }) => void;
```

2. Update message-input.tsx:

a) Add constant at top of file:
```typescript
const MAX_MESSAGE_LENGTH = 10_000;
```

b) Add state for rate limit:
```typescript
const [rateLimitMessage, setRateLimitMessage] = useState<string | null>(null);
```

c) Add socket error listener in useEffect:
```typescript
useEffect(() => {
  const handleError = (data: { message: string; code?: string; retryAfter?: number }) => {
    if (data.code === "RATE_LIMITED") {
      setRateLimitMessage(data.message);
      // Clear after retryAfter seconds (or 60s default)
      setTimeout(() => {
        setRateLimitMessage(null);
      }, (data.retryAfter ?? 60) * 1000);
    }
  };

  socket.on("error", handleError);
  return () => {
    socket.off("error", handleError);
  };
}, [socket]);
```

d) Update send button disabled logic:
```typescript
const isOverLimit = content.length > MAX_MESSAGE_LENGTH;
const isSendDisabled = !content.trim() || isSending || isOverLimit || rateLimitMessage !== null;
```

e) Disable textarea while rate limited per CONTEXT.md:
```typescript
disabled={isSending || rateLimitMessage !== null}
```

f) Add character counter and rate limit message in JSX (after the button, before closing form tag):
```jsx
{/* Character counter - always visible per CONTEXT.md */}
<div className="flex justify-between items-center mt-1 px-1">
  <span className={`text-xs ${isOverLimit ? 'text-red-500' : 'text-gray-400'}`}>
    {content.length.toLocaleString()}/{MAX_MESSAGE_LENGTH.toLocaleString()}
  </span>
  {isOverLimit && (
    <span className="text-xs text-red-500">
      Message too long
    </span>
  )}
</div>

{/* Rate limit message - inline below input per CONTEXT.md */}
{rateLimitMessage && (
  <div className="text-sm text-amber-600 mt-2 px-1">
    {rateLimitMessage}
  </div>
)}
```

g) Update Button disabled prop:
```typescript
disabled={isSendDisabled}
```
  </action>
  <verify>
Read the updated files and confirm:
1. MAX_MESSAGE_LENGTH = 10_000 constant exists
2. rateLimitMessage state exists
3. Socket error listener handles RATE_LIMITED code
4. Character counter shows {current}/{max} format
5. Counter turns red when over limit
6. Send button disabled when over limit or rate limited
7. Textarea disabled when rate limited
8. Rate limit message displays inline below input
  </verify>
  <done>Message input has character counter and rate limit feedback</done>
</task>

<task type="auto">
  <name>Task 3: Audit NEXT_PUBLIC_APP_URL usage (SECFIX-07)</name>
  <files>src/server/index.ts</files>
  <action>
Verify all URL constructions use NEXT_PUBLIC_APP_URL environment variable.

Per the research, the codebase already uses NEXT_PUBLIC_APP_URL in most places. The only concern is server/index.ts line 21:
```typescript
origin: process.env.NEXT_PUBLIC_APP_URL || `http://${hostname}:${port}`,
```

This fallback is fine for development but should log a warning in production.

Add a warning log if NEXT_PUBLIC_APP_URL is not set and NODE_ENV is production:

```typescript
// After line 9 (after dev const):
if (!dev && !process.env.NEXT_PUBLIC_APP_URL) {
  console.warn("[Server] NEXT_PUBLIC_APP_URL not set in production - using fallback origin");
}
```

Run a search to confirm no other hardcoded URLs exist:
```bash
grep -r "http://localhost" src/ --include="*.ts" --include="*.tsx" | grep -v node_modules
grep -r "https://.*\.com" src/ --include="*.ts" --include="*.tsx" | grep -v node_modules | grep -v "// "
```

If any hardcoded URLs are found (other than comments/examples), replace with NEXT_PUBLIC_APP_URL.
  </action>
  <verify>
1. server/index.ts logs warning if NEXT_PUBLIC_APP_URL missing in production
2. No hardcoded production URLs in src/ (comments excluded)
3. All dynamic URL construction uses NEXT_PUBLIC_APP_URL
  </verify>
  <done>All URL constructions use NEXT_PUBLIC_APP_URL with fallback warning</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run TypeScript compilation:
```bash
npx tsc --noEmit
```

2. Run existing tests:
```bash
npm test
```

3. Code inspection:
- notification.ts: @mention lookup joins members table with organizationId filter
- message-input.tsx: Character counter always visible, red when over, rate limit message inline
- server/index.ts: Warning logged if NEXT_PUBLIC_APP_URL missing in production

4. UI behavior per CONTEXT.md:
- Allow typing beyond limit but disable send button with warning
- Always-visible counter ("142/10,000" format)
- Red counter only when over limit (not red border)
- Rate limit: simple message, disable input, no countdown
</verification>

<success_criteria>
- [ ] @mention only resolves users within the same organization
- [ ] Character counter always visible showing current/max
- [ ] Counter turns red when over 10,000 characters
- [ ] Send button disabled when over limit
- [ ] Rate limit message displays inline below input
- [ ] Input disabled while rate limited
- [ ] NEXT_PUBLIC_APP_URL warning in production if missing
- [ ] TypeScript compiles without errors
- [ ] Existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-security-fixes/14-03-SUMMARY.md`
</output>
