---
phase: 19-mobile-layout
plan: 03
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - src/hooks/use-pull-refresh.ts
  - src/hooks/index.ts
  - src/components/layout/pull-to-refresh.tsx
  - src/components/layout/index.ts
  - src/components/message/message-input.tsx
autonomous: true

must_haves:
  truths:
    - "Pull down gesture at top of content triggers refresh callback"
    - "Visual indicator shows pull progress and refresh state"
    - "Message input has safe-area padding for keyboard"
    - "Message input uses bg-background not hardcoded bg-white"
  artifacts:
    - path: "src/hooks/use-pull-refresh.ts"
      provides: "Touch gesture handling for pull-to-refresh"
      exports: ["usePullRefresh"]
    - path: "src/components/layout/pull-to-refresh.tsx"
      provides: "Pull-to-refresh wrapper component"
      exports: ["PullToRefresh"]
    - path: "src/components/message/message-input.tsx"
      provides: "Keyboard-safe message input"
      contains: "safe-area-inset-bottom"
  key_links:
    - from: "src/components/layout/pull-to-refresh.tsx"
      to: "src/hooks/use-pull-refresh.ts"
      via: "usePullRefresh hook"
      pattern: "usePullRefresh"
---

<objective>
Implement pull-to-refresh functionality and fix message input for mobile keyboard.

Purpose: Enable native-like pull-to-refresh gesture on content areas and ensure message input works correctly when virtual keyboard is open.

Output: usePullRefresh hook, PullToRefresh wrapper component, and updated message-input with safe-area padding.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-mobile-layout/19-RESEARCH.md
@.planning/phases/19-mobile-layout/19-01-SUMMARY.md

Reference files:
@src/components/message/message-input.tsx
@src/hooks/use-send-message.ts (pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePullRefresh hook</name>
  <files>src/hooks/use-pull-refresh.ts, src/hooks/index.ts</files>
  <action>
    Create src/hooks/use-pull-refresh.ts:

    ```typescript
    "use client";

    import { useRef, useCallback, useEffect, useState } from "react";

    interface UsePullRefreshOptions {
      onRefresh: () => Promise<void>;
      threshold?: number;
      resistance?: number;
    }

    interface UsePullRefreshReturn {
      containerRef: React.RefObject<HTMLDivElement | null>;
      pullDistance: number;
      isRefreshing: boolean;
    }

    export function usePullRefresh({
      onRefresh,
      threshold = 80,
      resistance = 2.5,
    }: UsePullRefreshOptions): UsePullRefreshReturn {
      const containerRef = useRef<HTMLDivElement>(null);
      const [isPulling, setIsPulling] = useState(false);
      const [pullDistance, setPullDistance] = useState(0);
      const [isRefreshing, setIsRefreshing] = useState(false);
      const startY = useRef(0);

      const handleTouchStart = useCallback((e: TouchEvent) => {
        const container = containerRef.current;
        // Only trigger if at the top of the scrollable container
        if (!container || container.scrollTop > 0) return;
        startY.current = e.touches[0].clientY;
        setIsPulling(true);
      }, []);

      const handleTouchMove = useCallback(
        (e: TouchEvent) => {
          if (!isPulling || isRefreshing) return;

          const currentY = e.touches[0].clientY;
          const diff = (currentY - startY.current) / resistance;

          if (diff > 0) {
            setPullDistance(Math.min(diff, threshold * 1.5));
            // Prevent browser's native pull-to-refresh
            e.preventDefault();
          }
        },
        [isPulling, isRefreshing, resistance, threshold]
      );

      const handleTouchEnd = useCallback(async () => {
        if (!isPulling) return;
        setIsPulling(false);

        if (pullDistance >= threshold && !isRefreshing) {
          setIsRefreshing(true);
          try {
            await onRefresh();
          } finally {
            setIsRefreshing(false);
          }
        }
        setPullDistance(0);
      }, [isPulling, pullDistance, threshold, isRefreshing, onRefresh]);

      useEffect(() => {
        const container = containerRef.current;
        if (!container) return;

        container.addEventListener("touchstart", handleTouchStart, { passive: true });
        container.addEventListener("touchmove", handleTouchMove, { passive: false });
        container.addEventListener("touchend", handleTouchEnd);

        return () => {
          container.removeEventListener("touchstart", handleTouchStart);
          container.removeEventListener("touchmove", handleTouchMove);
          container.removeEventListener("touchend", handleTouchEnd);
        };
      }, [handleTouchStart, handleTouchMove, handleTouchEnd]);

      return { containerRef, pullDistance, isRefreshing };
    }
    ```

    Create or update src/hooks/index.ts barrel:
    ```typescript
    export { useSendMessage } from "./use-send-message";
    export { usePullRefresh } from "./use-pull-refresh";
    ```

    Key design decisions:
    - Only activates when scrollTop is 0 (at top of content)
    - Resistance factor (2.5) makes pull feel native, not 1:1
    - Threshold (80px) is industry standard
    - Max pull capped at threshold * 1.5 (120px)
    - e.preventDefault() on touchmove to override browser refresh
  </action>
  <verify>
    - Import { usePullRefresh } from "@/hooks" works
    - Hook returns containerRef, pullDistance, isRefreshing
    - No TypeScript errors
  </verify>
  <done>
    usePullRefresh hook created with touch gesture handling and exported from barrel.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PullToRefresh component</name>
  <files>src/components/layout/pull-to-refresh.tsx, src/components/layout/index.ts</files>
  <action>
    Create src/components/layout/pull-to-refresh.tsx:

    ```typescript
    "use client";

    import { ReactNode } from "react";
    import { usePullRefresh } from "@/hooks";
    import { Loader2 } from "lucide-react";
    import { cn } from "@/lib/utils";

    interface PullToRefreshProps {
      children: ReactNode;
      onRefresh: () => Promise<void>;
      className?: string;
    }

    export function PullToRefresh({
      children,
      onRefresh,
      className,
    }: PullToRefreshProps) {
      const { containerRef, pullDistance, isRefreshing } = usePullRefresh({
        onRefresh,
      });

      return (
        <div
          ref={containerRef}
          className={cn("relative h-full overflow-auto overscroll-y-contain", className)}
        >
          {/* Pull indicator */}
          <div
            className="pointer-events-none absolute left-1/2 z-10 -translate-x-1/2 transition-opacity"
            style={{
              top: Math.min(pullDistance - 40, 20),
              opacity: Math.min(pullDistance / 60, 1),
            }}
          >
            <div className="rounded-full bg-background p-2 shadow-md">
              <Loader2
                className={cn(
                  "h-5 w-5 text-muted-foreground",
                  isRefreshing && "animate-spin"
                )}
              />
            </div>
          </div>

          {/* Content with pull offset during gesture */}
          <div
            style={{
              transform: `translateY(${isRefreshing ? 40 : pullDistance}px)`,
            }}
            className={cn(
              "transition-transform duration-200",
              isPulling && "duration-0" // Instant during pull gesture
            )}
          >
            {children}
          </div>
        </div>
      );
    }
    ```

    Wait, the hook doesn't expose isPulling. Let me fix that - either expose it from the hook or check pullDistance > 0 && !isRefreshing as proxy.

    Actually, simpler approach - just use a quick transition for the snap-back:

    ```typescript
    "use client";

    import { ReactNode } from "react";
    import { usePullRefresh } from "@/hooks";
    import { Loader2 } from "lucide-react";
    import { cn } from "@/lib/utils";

    interface PullToRefreshProps {
      children: ReactNode;
      onRefresh: () => Promise<void>;
      className?: string;
    }

    export function PullToRefresh({
      children,
      onRefresh,
      className,
    }: PullToRefreshProps) {
      const { containerRef, pullDistance, isRefreshing } = usePullRefresh({
        onRefresh,
      });

      const showIndicator = pullDistance > 0 || isRefreshing;

      return (
        <div
          ref={containerRef}
          className={cn("relative h-full overflow-auto overscroll-y-contain", className)}
        >
          {/* Pull indicator */}
          {showIndicator && (
            <div
              className="pointer-events-none absolute left-1/2 z-10 -translate-x-1/2"
              style={{
                top: Math.max(pullDistance - 40, isRefreshing ? 12 : -40),
                opacity: isRefreshing ? 1 : Math.min(pullDistance / 60, 1),
              }}
            >
              <div className="rounded-full bg-background p-2 shadow-md border">
                <Loader2
                  className={cn(
                    "h-5 w-5 text-muted-foreground",
                    isRefreshing && "animate-spin"
                  )}
                />
              </div>
            </div>
          )}

          {/* Content - pulled down during gesture, held during refresh */}
          <div
            style={{
              transform: `translateY(${isRefreshing ? 48 : pullDistance}px)`,
              transition: pullDistance === 0 && !isRefreshing ? "transform 200ms" : "none",
            }}
          >
            {children}
          </div>
        </div>
      );
    }
    ```

    Update src/components/layout/index.ts:
    ```typescript
    export { MobileTabBar } from "./mobile-tab-bar";
    export { PullToRefresh } from "./pull-to-refresh";
    ```

    Note: This component is available for wrapping content areas. Integration into
    specific views (like MessageList) would require:
    1. Wrapping the scrollable content with PullToRefresh
    2. Passing a refresh callback that reloads data

    For this plan, we're creating the reusable component. View-specific integration
    can be done incrementally or in a follow-up if needed.
  </action>
  <verify>
    - Component renders children correctly
    - Pull indicator appears when pulling down from top
    - Spinner animates during refresh
    - Content snaps back after pull release
    - Overflow is contained (no browser bounce)
  </verify>
  <done>
    PullToRefresh component created with visual indicator and smooth animations.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update MessageInput for mobile keyboard</name>
  <files>src/components/message/message-input.tsx</files>
  <action>
    Update src/components/message/message-input.tsx:

    1. Change the form background from bg-white to bg-background (theme-aware)

    2. Add safe-area padding to the form for iOS home indicator:
       Change: `className="border-t bg-white p-4"`
       To: `className="border-t bg-background p-4 pb-[max(1rem,env(safe-area-inset-bottom))]"`

       This ensures:
       - At minimum, 1rem (16px) bottom padding
       - On devices with home indicator, extra padding for safe area
       - Works correctly whether in standalone PWA or browser

    3. Verify the send button has proper touch target (already has h-11 w-11 which is 44px)

    4. Verify the textarea has min-h-[44px] (already has min-h-[44px])

    The existing code already has good touch target sizing. Main fixes are:
    - bg-white -> bg-background (theme consistency)
    - Add safe-area bottom padding
  </action>
  <verify>
    - Message input form uses bg-background (not hardcoded white)
    - On iOS with home indicator, input doesn't overlap the indicator
    - Send button is at least 44x44 pixels
    - Input is usable with virtual keyboard open
    - Dark mode (if enabled) shows correct background
  </verify>
  <done>
    MessageInput uses theme background and respects safe-area-inset-bottom.
    Touch targets meet 44px minimum size requirement.
  </done>
</task>

</tasks>

<verification>
1. Pull-to-refresh:
   - Pull down gesture at top shows spinner indicator
   - Continue pulling shows increasing opacity
   - Release past threshold triggers onRefresh callback
   - Release before threshold cancels with snap-back animation
   - During refresh, spinner animates and content stays offset

2. Message input:
   - Background matches app theme (not hardcoded white)
   - On iPhone with home indicator, input area doesn't overlap
   - Send button is easily tappable (44px minimum)
   - Input field is easily tappable

3. Touch targets (MOBI-03):
   - Send button: 44x44px minimum
   - Textarea: 44px minimum height
   - Tab bar items: 44x44px minimum (from Plan 02)

4. Build passes:
   - `npm run build` completes without errors
   - No TypeScript errors in new files
</verification>

<success_criteria>
- MOBI-04: Pull-to-refresh component ready for integration
- MOBI-05: Message input works correctly with virtual keyboard
- MOBI-03: Touch targets verified at 44px minimum
- Theme-aware styling (bg-background instead of hardcoded colors)
- Safe-area insets respected on input areas
</success_criteria>

<output>
After completion, create `.planning/phases/19-mobile-layout/19-03-SUMMARY.md`
</output>
