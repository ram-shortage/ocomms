---
phase: 33-workspace-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/workspace-join-request.ts
  - src/db/schema/index.ts
  - src/lib/hooks/use-workspace-unread.ts
  - src/server/socket/handlers/workspace-unread.ts
  - src/lib/socket-events.ts
autonomous: true

must_haves:
  truths:
    - "Workspace unread counts can be fetched for multiple workspaces in a single query"
    - "Join requests can be stored and queried from database"
    - "Socket events emit workspace-level unread updates"
  artifacts:
    - path: "src/db/schema/workspace-join-request.ts"
      provides: "Join request model for workspace discovery flow"
      contains: "workspaceJoinRequests"
    - path: "src/lib/hooks/use-workspace-unread.ts"
      provides: "Client hook for workspace unread aggregation"
      exports: ["useWorkspaceUnreadCounts"]
    - path: "src/server/socket/handlers/workspace-unread.ts"
      provides: "Socket handlers for workspace unread events"
      exports: ["setupWorkspaceUnreadHandlers", "handleWorkspaceUnreadEvents"]
  key_links:
    - from: "src/lib/hooks/use-workspace-unread.ts"
      to: "socket workspace:fetchUnreads"
      via: "socket.emit"
      pattern: "socket\\.emit.*workspace:fetchUnreads"
    - from: "src/server/socket/handlers/workspace-unread.ts"
      to: "db.select"
      via: "SQL aggregation query"
      pattern: "COALESCE.*SUM"
---

<objective>
Create foundation for workspace management: join request schema and workspace-level unread count aggregation.

Purpose: Enable the workspace switcher to display unread counts per workspace, and provide database schema for the join request flow. These are prerequisites for both the switcher UI (Plan 02) and the browse/join flow (Plan 03).

Output: Database schema for join requests, client hook for workspace unreads, and socket handlers for real-time updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-workspace-management/33-CONTEXT.md
@.planning/phases/33-workspace-management/33-RESEARCH.md

@src/db/schema/auth.ts
@src/db/schema/index.ts
@src/lib/hooks/use-unread.ts
@src/server/socket/handlers/unread.ts
@src/lib/socket-events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create join request schema and workspace unread aggregation</name>
  <files>
    src/db/schema/workspace-join-request.ts
    src/db/schema/index.ts
  </files>
  <action>
Create new schema file `workspace-join-request.ts` with:

1. `workspaceJoinRequests` table:
   - `id`: text primary key with nanoid default
   - `userId`: text, references user.id, not null
   - `organizationId`: text, references organization.id, not null
   - `message`: text (optional message from requester)
   - `status`: text, not null, default "pending" (values: pending, approved, rejected)
   - `rejectionReason`: text (optional, sent to requester if rejected)
   - `createdAt`: timestamp, not null, default now
   - `reviewedAt`: timestamp (when admin took action)
   - `reviewedBy`: text, references user.id (admin who reviewed)
   - Add unique constraint on (userId, organizationId) to prevent duplicate pending requests

2. Add relations for workspaceJoinRequests:
   - user: one(user)
   - organization: one(organization)
   - reviewer: one(user) for reviewedBy

3. Export from index.ts

Pattern reference: Follow existing schema patterns from `guest.ts` and `auth.ts`.

Do NOT run migrations - that will be done separately after all schema changes are complete.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
Join request schema exists with all fields, relations, and unique constraint. Exported from schema index.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create workspace unread hook and socket handlers</name>
  <files>
    src/lib/hooks/use-workspace-unread.ts
    src/server/socket/handlers/workspace-unread.ts
    src/lib/socket-events.ts
  </files>
  <action>
1. Update `socket-events.ts` to add new events:
   - ClientToServer: `workspace:fetchUnreads` with payload `{ workspaceIds: string[] }` and callback `(response: { counts: Record<string, number> }) => void`
   - ServerToClient: `workspace:unreadUpdate` with payload `{ workspaceId: string; unreadCount: number }`

2. Create `use-workspace-unread.ts` hook:
   - `useWorkspaceUnreadCounts(workspaceIds: string[])` returns `{ counts: Record<string, number>, isLoading: boolean }`
   - On mount, emit `workspace:fetchUnreads` with workspaceIds
   - Subscribe to `workspace:unreadUpdate` for real-time updates
   - Only update counts for workspaceIds in the provided array
   - Follow pattern from existing `use-unread.ts`

3. Create `workspace-unread.ts` socket handler:
   - `setupWorkspaceUnreadHandlers(io, redis)` returns a WorkspaceUnreadManager
   - `getWorkspaceUnreadCount(userId, workspaceId)`: Aggregate unread count for a workspace using SQL:
     ```sql
     SELECT COALESCE(SUM(unreads), 0) FROM (
       -- Channel unreads for this workspace
       SELECT (max_seq - COALESCE(last_read, 0)) as unreads
       FROM channels c
       JOIN channel_members cm ON cm.channel_id = c.id AND cm.user_id = ?
       LEFT JOIN channel_read_states crs ON crs.channel_id = c.id AND crs.user_id = ?
       CROSS JOIN LATERAL (SELECT COALESCE(MAX(sequence), 0) as max_seq FROM messages WHERE channel_id = c.id AND deleted_at IS NULL)
       WHERE c.organization_id = ?

       UNION ALL

       -- Conversation unreads for this workspace
       SELECT (max_seq - COALESCE(last_read, 0)) as unreads
       FROM conversations conv
       JOIN conversation_participants cp ON cp.conversation_id = conv.id AND cp.user_id = ?
       LEFT JOIN channel_read_states crs ON crs.conversation_id = conv.id AND crs.user_id = ?
       CROSS JOIN LATERAL (SELECT COALESCE(MAX(sequence), 0) as max_seq FROM messages WHERE conversation_id = conv.id AND deleted_at IS NULL)
       WHERE conv.organization_id = ?
     )
     ```
   - Use Drizzle's sql template for the query
   - Cache results in Redis with 30-second TTL: `workspace-unread:{userId}:{workspaceId}`
   - `handleWorkspaceUnreadEvents(socket, io, manager)`: Handle `workspace:fetchUnreads` event
   - Verify user is member of each requested workspace before returning counts

4. Register the handler in the socket index file (will be done in Plan 02 when integrating).

Note: The aggregation query should be efficient. Consider using a single query with GROUP BY workspaceId to fetch all workspace unreads at once rather than looping.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
- Socket events defined for workspace unread fetch and updates
- Client hook fetches and subscribes to workspace unread counts
- Server handler aggregates channel + conversation unreads per workspace
  </done>
</task>

<task type="auto">
  <name>Task 3: Run database migration</name>
  <files>
    src/db/migrations/*.sql
  </files>
  <action>
Run Drizzle migration to create the workspace_join_requests table:

```bash
npx drizzle-kit generate
npx drizzle-kit migrate
```

Verify the migration creates:
- workspace_join_requests table with all columns
- Unique constraint on (user_id, organization_id)
- Foreign key references to users and organizations tables
  </action>
  <verify>
`npx drizzle-kit migrate` completes successfully.
Database has workspace_join_requests table: `psql -c "\\d workspace_join_requests"` shows expected columns.
  </verify>
  <done>
Migration generated and applied. workspace_join_requests table exists in database with proper constraints.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Database has workspace_join_requests table with unique constraint
3. Socket events are properly typed in socket-events.ts
4. Hook follows same patterns as use-unread.ts
5. Server handler uses efficient SQL aggregation
</verification>

<success_criteria>
- [ ] workspaceJoinRequests schema exists with all fields and relations
- [ ] Migration applied successfully
- [ ] useWorkspaceUnreadCounts hook implemented
- [ ] workspace:fetchUnreads socket event defined and handled
- [ ] workspace:unreadUpdate event defined for real-time updates
- [ ] SQL aggregation query efficiently calculates workspace-level unreads
</success_criteria>

<output>
After completion, create `.planning/phases/33-workspace-management/33-01-SUMMARY.md`
</output>
