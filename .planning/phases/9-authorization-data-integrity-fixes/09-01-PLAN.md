---
phase: 09-authorization-data-integrity-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/socket/index.ts
  - src/server/socket/rooms.ts
autonomous: true

must_haves:
  truths:
    - "Socket room:join validates channel/DM membership before joining room"
    - "Socket workspace:join validates organization membership before joining"
    - "Unauthorized room/workspace join attempts are rejected with error"
  artifacts:
    - path: "src/server/socket/index.ts"
      provides: "Authorization checks on room:join and workspace:join handlers"
      contains: "channelMembers"
    - path: "src/server/socket/rooms.ts"
      provides: "Helper functions for membership validation"
      exports: ["validateChannelMembership", "validateConversationParticipation", "validateWorkspaceMembership"]
  key_links:
    - from: "src/server/socket/index.ts"
      to: "src/server/socket/rooms.ts"
      via: "imports validation helpers"
      pattern: "validate.*Membership"
---

<objective>
Add authorization checks to Socket.IO room and workspace join handlers.

Purpose: Currently, room:join and workspace:join accept any roomId/workspaceId without verifying the user is a member. An attacker could subscribe to channels/DMs/workspaces they don't belong to and receive all real-time events.

Output: Socket handlers that validate membership before allowing room joins, with appropriate error responses for unauthorized attempts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/server/socket/index.ts
@src/server/socket/rooms.ts
@src/server/socket/handlers/message.ts (reference for membership validation pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add membership validation helpers to rooms.ts</name>
  <files>src/server/socket/rooms.ts</files>
  <action>
Add three async validation helper functions to rooms.ts:

1. `validateChannelMembership(userId: string, channelId: string): Promise<boolean>`
   - Query channelMembers table for matching userId + channelId
   - Return true if membership exists, false otherwise

2. `validateConversationParticipation(userId: string, conversationId: string): Promise<boolean>`
   - Query conversationParticipants table for matching userId + conversationId
   - Return true if participation exists, false otherwise

3. `validateWorkspaceMembership(userId: string, workspaceId: string): Promise<boolean>`
   - Query members table for matching userId + organizationId (workspaceId)
   - Return true if membership exists, false otherwise

Import `members` from `@/db/schema` for workspace validation.
Use `and` from `drizzle-orm` for compound where clauses.
Follow the existing query pattern from channelMembers query in joinUserRooms.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
Three validation helper functions exported from rooms.ts that query the database and return boolean membership status.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add authorization to room:join and workspace:join handlers</name>
  <files>src/server/socket/index.ts</files>
  <action>
Update the room:join handler (line ~100) to validate membership before joining:

1. Import the new validation helpers from ./rooms
2. For room:join:
   - If roomType === "channel": call validateChannelMembership(userId, roomId)
   - If roomType === "dm": call validateConversationParticipation(userId, roomId)
   - If validation returns false:
     - Emit socket.emit("error", { message: "Not authorized to join this room" })
     - Return early WITHOUT calling socket.join()
   - Only call socket.join(roomName) if validation passes

3. For workspace:join (line ~109):
   - Call validateWorkspaceMembership(userId, workspaceId)
   - If validation returns false:
     - Emit socket.emit("error", { message: "Not a member of this workspace" })
     - Return early WITHOUT joining workspace room or starting presence
   - Only proceed with socket.join() and presence if validation passes

4. For presence:fetch (line ~127):
   - Add validateWorkspaceMembership check before returning presence data
   - If not a member, return empty map {}

Keep existing functionality (socket data assignment, presence heartbeat) when authorization succeeds.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Manual test: Start app, connect socket, attempt to join a channel user is NOT a member of - should receive error event.
  </verify>
  <done>
room:join rejects non-members, workspace:join rejects non-org-members, presence:fetch only returns data for workspace members.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Unit test scenario (manual or automated):
   - User A is member of Channel X but not Channel Y
   - User A connects socket and tries room:join for Channel Y
   - Expected: error event received, user NOT in Channel Y room
   - User A tries room:join for Channel X
   - Expected: success, user IS in Channel X room
</verification>

<success_criteria>
- Socket.IO room:join validates channel/DM membership before allowing join
- Socket.IO workspace:join validates organization membership before allowing join
- Unauthorized attempts receive error events
- Authorized attempts work exactly as before
- No breaking changes to existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/9-authorization-data-integrity-fixes/09-01-SUMMARY.md`
</output>
