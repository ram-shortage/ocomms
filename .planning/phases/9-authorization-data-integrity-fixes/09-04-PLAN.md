---
phase: 09-authorization-data-integrity-fixes
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server/socket/handlers/unread.ts
autonomous: true

must_haves:
  truths:
    - "unread:fetch validates user is member of each requested channel/conversation"
    - "unread:markRead validates user is member of the channel/conversation"
    - "unread:markMessageUnread validates user is member of the message's channel/conversation"
    - "Unauthorized unread operations are rejected"
  artifacts:
    - path: "src/server/socket/handlers/unread.ts"
      provides: "Authorization checks on unread event handlers"
      contains: "validate"
  key_links:
    - from: "src/server/socket/handlers/unread.ts"
      to: "@/db/schema"
      via: "uses channelMembers/conversationParticipants for validation"
      pattern: "channelMembers|conversationParticipants"
---

<objective>
Add channel/DM membership validation to unread event handlers.

Purpose: Currently, unread:fetch, unread:markRead, and unread:markMessageUnread accept any channel/conversation IDs without verifying user membership. An attacker could discover channel activity patterns or manipulate read states for channels they don't belong to.

Output: Unread handlers that validate membership before returning counts or modifying read state.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/server/socket/handlers/unread.ts
@src/server/socket/handlers/message.ts (reference for membership validation pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validation helpers for unread operations</name>
  <files>src/server/socket/handlers/unread.ts</files>
  <action>
Add helper functions for membership validation near top of file (after existing imports/constants):

```typescript
async function validateChannelAccess(userId: string, channelId: string): Promise<boolean> {
  const membership = await db
    .select()
    .from(channelMembers)
    .where(and(eq(channelMembers.channelId, channelId), eq(channelMembers.userId, userId)))
    .limit(1);
  return membership.length > 0;
}

async function validateConversationAccess(userId: string, conversationId: string): Promise<boolean> {
  const participation = await db
    .select()
    .from(conversationParticipants)
    .where(and(eq(conversationParticipants.conversationId, conversationId), eq(conversationParticipants.userId, userId)))
    .limit(1);
  return participation.length > 0;
}
```

Note: `channelMembers` and `conversationParticipants` are already imported in this file.
Add `and` to the drizzle-orm import (already has eq, isNull, sql).
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
Two validation helper functions exist for checking channel and conversation membership.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add authorization to unread event handlers</name>
  <files>src/server/socket/handlers/unread.ts</files>
  <action>
Update the handleUnreadEvents function (line ~389) to validate membership:

1. **unread:fetch handler** (line ~397):
   - For each channelId in data.channelIds, only include in result if validateChannelAccess returns true
   - For each conversationId in data.conversationIds, only include in result if validateConversationAccess returns true
   - Skip unauthorized channels/conversations silently (don't error, just omit from results)

   Updated handler:
   ```typescript
   socket.on("unread:fetch", async (data, callback) => {
     try {
       const channels: Record<string, number> = {};
       const conversations: Record<string, number> = {};

       if (data.channelIds) {
         for (const channelId of data.channelIds) {
           if (await validateChannelAccess(userId, channelId)) {
             channels[channelId] = await unreadManager.getUnreadCount(userId, channelId);
           }
         }
       }

       if (data.conversationIds) {
         for (const conversationId of data.conversationIds) {
           if (await validateConversationAccess(userId, conversationId)) {
             conversations[conversationId] = await unreadManager.getConversationUnreadCount(userId, conversationId);
           }
         }
       }

       callback({ channels, conversations });
     } catch (error) {
       console.error("[Unread] Error fetching counts:", error);
       callback({ channels: {}, conversations: {} });
     }
   });
   ```

2. **unread:markRead handler** (line ~422):
   - Validate membership before calling markChannelAsRead/markConversationAsRead
   - If not authorized, return { success: false }

   ```typescript
   socket.on("unread:markRead", async (data, callback) => {
     try {
       if (data.channelId) {
         if (!await validateChannelAccess(userId, data.channelId)) {
           callback({ success: false });
           return;
         }
         await unreadManager.markChannelAsRead(userId, data.channelId);
       } else if (data.conversationId) {
         if (!await validateConversationAccess(userId, data.conversationId)) {
           callback({ success: false });
           return;
         }
         await unreadManager.markConversationAsRead(userId, data.conversationId);
       }
       callback({ success: true });
     } catch (error) {
       console.error("[Unread] Error marking as read:", error);
       callback({ success: false });
     }
   });
   ```

3. **unread:markMessageUnread handler** (line ~437):
   - The markMessageAsUnread method already looks up the message - we need to validate before calling it
   - First look up message to get channelId/conversationId, then validate

   ```typescript
   socket.on("unread:markMessageUnread", async (data, callback) => {
     try {
       // Look up message to validate access
       const message = await db.query.messages.findFirst({
         where: eq(messages.id, data.messageId),
         columns: { channelId: true, conversationId: true },
       });

       if (!message) {
         callback({ success: false });
         return;
       }

       if (message.channelId) {
         if (!await validateChannelAccess(userId, message.channelId)) {
           callback({ success: false });
           return;
         }
       } else if (message.conversationId) {
         if (!await validateConversationAccess(userId, message.conversationId)) {
           callback({ success: false });
           return;
         }
       }

       await unreadManager.markMessageAsUnread(userId, data.messageId);
       callback({ success: true });
     } catch (error) {
       console.error("[Unread] Error marking as unread:", error);
       callback({ success: false });
     }
   });
   ```

Import `messages` from `@/db/schema` for the message lookup (likely already imported via channelReadState).
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Manual test: User not in channel tries unread:fetch with that channel's ID - should not receive count for that channel.
  </verify>
  <done>
All unread handlers validate channel/DM membership before performing operations.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Test scenario:
   - User A is member of Channel X, not Channel Y
   - User A calls unread:fetch with [channelX.id, channelY.id]
   - Result should only contain count for Channel X
   - User A calls unread:markRead for Channel Y - should return success: false
</verification>

<success_criteria>
- unread:fetch only returns counts for channels/conversations user is member of
- unread:markRead validates membership before modifying state
- unread:markMessageUnread validates membership before modifying state
- Unauthorized requests are handled gracefully (no errors, just rejected)
- Authorized requests work exactly as before
</success_criteria>

<output>
After completion, create `.planning/phases/9-authorization-data-integrity-fixes/09-04-SUMMARY.md`
</output>
