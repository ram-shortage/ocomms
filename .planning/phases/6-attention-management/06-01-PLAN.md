---
phase: 06-attention-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/channel-read-state.ts
  - src/db/schema/index.ts
  - src/server/socket/handlers/unread.ts
  - src/server/socket/index.ts
  - src/server/socket/handlers/message.ts
  - src/lib/socket-events.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Unread count can be computed from lastReadSequence vs max message sequence"
    - "Mark-as-read updates lastReadSequence to current max"
    - "Mark-as-unread sets markedUnreadAtSequence on a specific message"
    - "New messages trigger unread updates to channel members"
  artifacts:
    - path: "src/db/schema/channel-read-state.ts"
      provides: "Per-user-per-channel read state tracking"
      contains: "channelReadState"
    - path: "src/server/socket/handlers/unread.ts"
      provides: "Unread socket event handlers"
      exports: ["setupUnreadHandlers", "handleUnreadEvents"]
    - path: "src/lib/socket-events.ts"
      provides: "Unread event type definitions"
      contains: "unread:update"
  key_links:
    - from: "src/server/socket/handlers/unread.ts"
      to: "src/db/schema/channel-read-state.ts"
      via: "drizzle query"
      pattern: "channelReadState"
    - from: "src/server/socket/handlers/message.ts"
      to: "src/server/socket/handlers/unread.ts"
      via: "notifyUnreadIncrement call"
      pattern: "notifyUnreadIncrement"
    - from: "src/server/socket/index.ts"
      to: "src/server/socket/handlers/unread.ts"
      via: "handler registration"
      pattern: "handleUnreadEvents"
---

<objective>
Read state schema and backend handlers for unread count tracking

Purpose: Enable tracking of read position per user per channel/conversation, computing unread counts, and real-time unread updates when new messages arrive.

Output: Database schema for read state, socket handlers for unread operations, integration with message handler for automatic unread notifications.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/6-attention-management/06-RESEARCH.md

@src/db/schema/message.ts
@src/db/schema/index.ts
@src/server/socket/handlers/message.ts
@src/server/socket/index.ts
@src/server/socket/rooms.ts
@src/lib/socket-events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Channel read state schema</name>
  <files>src/db/schema/channel-read-state.ts, src/db/schema/index.ts</files>
  <action>
Create channel read state schema following the pattern from 06-RESEARCH.md:

1. Create `src/db/schema/channel-read-state.ts`:
   - Table `channel_read_state` with fields:
     - `id` (uuid, primaryKey, defaultRandom)
     - `userId` (uuid, notNull, references users.id with cascade delete)
     - `channelId` (uuid, optional, references channels.id with cascade delete)
     - `conversationId` (uuid, optional, references conversations.id with cascade delete)
     - `lastReadSequence` (integer, notNull, default 0)
     - `markedUnreadAtSequence` (integer, optional - set when user marks a message as unread)
     - `updatedAt` (timestamp, notNull, defaultNow)
   - Indexes:
     - Unique index on (userId, channelId) where channelId IS NOT NULL
     - Unique index on (userId, conversationId) where conversationId IS NOT NULL
     - Index on userId for fetching all user's read states
   - Relations to users, channels, conversations

2. Export from `src/db/schema/index.ts`

Use sql template from drizzle-orm for the WHERE clause in partial indexes.
  </action>
  <verify>TypeScript compilation succeeds: `npx tsc --noEmit`</verify>
  <done>channelReadState table schema exists with proper indexes and relations</done>
</task>

<task type="auto">
  <name>Task 2: Unread socket handlers</name>
  <files>src/server/socket/handlers/unread.ts, src/lib/socket-events.ts</files>
  <action>
Create unread socket handlers following the pattern from 06-RESEARCH.md:

1. Update `src/lib/socket-events.ts` to add unread event types:
   - ServerToClientEvents:
     - `"unread:update"`: `(data: { channelId?: string; conversationId?: string; unreadCount: number }) => void`
   - ClientToServerEvents:
     - `"unread:markRead"`: `(data: { channelId?: string; conversationId?: string }, callback: (response: { success: boolean }) => void) => void`
     - `"unread:markMessageUnread"`: `(data: { messageId: string }, callback: (response: { success: boolean }) => void) => void`
     - `"unread:fetch"`: `(data: { channelIds?: string[]; conversationIds?: string[] }, callback: (response: { channels: Record<string, number>; conversations: Record<string, number> }) => void) => void`

2. Create `src/server/socket/handlers/unread.ts`:
   - `setupUnreadHandlers(io, redis)` returns an object with methods:
     - `getUnreadCount(userId, channelId)` - computes unread from DB, caches in Redis (60s TTL)
     - `getConversationUnreadCount(userId, conversationId)` - same for DMs
     - `markChannelAsRead(userId, channelId)` - upserts read state, clears markedUnreadAtSequence, invalidates cache, emits update
     - `markConversationAsRead(userId, conversationId)` - same for DMs
     - `markMessageAsUnread(userId, messageId)` - sets markedUnreadAtSequence, invalidates cache, emits update
     - `notifyUnreadIncrement(channelId, senderId, newSequence)` - invalidates cache for all members except sender, emits updates
   - `handleUnreadEvents(socket, io, unreadManager)` - registers socket event handlers:
     - `"unread:fetch"` - batch fetch unread counts
     - `"unread:markRead"` - mark channel/conversation as read
     - `"unread:markMessageUnread"` - mark specific message as unread

Redis key patterns:
- `unread:{userId}:channel:{channelId}` for channel unread counts
- `unread:{userId}:conv:{conversationId}` for conversation unread counts

For unread computation:
- Get max sequence from messages table
- Get read state from channelReadState
- If markedUnreadAtSequence is set, effectiveReadSeq = MIN(lastReadSequence, markedUnreadAtSequence - 1)
- Unread = max(0, maxSequence - effectiveReadSeq)

Handle Redis being optional (graceful fallback to DB-only).
  </action>
  <verify>TypeScript compilation succeeds: `npx tsc --noEmit`</verify>
  <done>Unread socket handlers exist with fetch, markRead, markMessageUnread, and notifyUnreadIncrement</done>
</task>

<task type="auto">
  <name>Task 3: Register handlers and integrate with message handler</name>
  <files>src/server/socket/index.ts, src/server/socket/handlers/message.ts</files>
  <action>
1. Update `src/server/socket/index.ts`:
   - Import `setupUnreadHandlers` and `handleUnreadEvents` from `./handlers/unread`
   - In `setupSocketHandlers`, after presence manager setup:
     - Call `const unreadManager = setupUnreadHandlers(io, redis)` (pass redis which may be null)
   - In the connection handler, call `handleUnreadEvents(socket, io, unreadManager)`
   - Export `getUnreadManager()` function (similar to getPresenceManager) for use by message handler

2. Update `src/server/socket/handlers/message.ts`:
   - Import `getUnreadManager` from `../index`
   - After broadcasting `message:new` and after notification creation:
     - Get unread manager via `getUnreadManager()`
     - If manager exists and this is a channel message, call:
       `unreadManager.notifyUnreadIncrement(targetId, userId, sequence)`
     - Do the same for DM conversations using the conversationId variant

This ensures when a new message is sent, all channel/conversation members (except sender) get real-time unread count updates.
  </action>
  <verify>TypeScript compilation succeeds: `npx tsc --noEmit`</verify>
  <done>Unread handlers registered, message handler triggers unread updates on new messages</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Schema exports are correct: grep for `channelReadState` in index.ts
3. Socket events properly typed: grep for `unread:` in socket-events.ts
4. Handler registration: grep for `handleUnreadEvents` in socket/index.ts
5. Message integration: grep for `notifyUnreadIncrement` in message.ts
</verification>

<success_criteria>
- channelReadState schema with proper indexes and relations
- Socket events for unread:fetch, unread:markRead, unread:markMessageUnread, unread:update
- Unread handlers compute counts from sequence numbers
- Redis caching with 60s TTL (graceful fallback if no Redis)
- New messages trigger unread updates to channel members
</success_criteria>

<output>
After completion, create `.planning/phases/6-attention-management/06-01-SUMMARY.md`
</output>
