# Architecture Research: PWA & Mobile Integration

**Project:** OComms v0.3.0 Mobile & Polish
**Researched:** 2026-01-18
**Confidence:** HIGH (verified with official MDN docs, Socket.IO docs, and multiple 2025-2026 sources)

---

## Executive Summary

PWA integration with OComms' existing Next.js 15 + Socket.IO architecture is well-supported. The key insight: **the service worker and app operate as parallel systems with clear boundaries**. The service worker handles caching, background sync, and push - but never replaces Socket.IO for real-time messaging. Socket.IO remains the source of truth when online; IndexedDB serves as offline cache and queue storage.

This document extends the general architecture (see `ARCHITECTURE.md`) with PWA-specific patterns for offline support, push notifications, and mobile layout.

---

## Integration Points

### How PWA Components Map to Existing Architecture

| PWA Component | Integrates With | Purpose |
|---------------|-----------------|---------|
| Web App Manifest | Next.js App Router (`app/manifest.ts`) | Install prompt, theming |
| Service Worker | Separate from Next.js (in `public/`) | Caching, push, background sync |
| IndexedDB | React components via hooks | Message cache, offline queue |
| Push API | Server (`src/server/`) + Service Worker | Notification delivery |
| Background Sync | Service Worker + existing message API | Offline send queue |

### Key Integration Decision: Service Worker Placement

**Recommendation:** Place service worker in `public/sw.js`, NOT generated by Next.js.

**Rationale:**
1. Next.js 15 App Router has no native service worker support
2. Libraries like `next-pwa` and `serwist` add complexity without value for our use case
3. Manual service worker gives full control over caching and sync behavior
4. Registration happens in a client component, respecting App Router patterns

### File Structure

```
public/
  sw.js              # Service worker (caching, push, background sync)

src/
  app/
    manifest.ts      # Dynamic manifest (preferred - can include version)
  components/
    pwa/
      ServiceWorkerRegistration.tsx  # Registers SW, handles updates
      InstallPrompt.tsx              # PWA install prompt UI
      OfflineIndicator.tsx           # Shows offline status
  lib/
    pwa/
      indexeddb.ts   # Dexie.js database schema
      offline-queue.ts  # Queue management for offline sends
      push-subscription.ts  # Push subscription management
```

### Socket.IO Integration

**Critical insight:** Socket.IO already handles disconnection gracefully with built-in buffering.

From existing `src/lib/socket-client.ts`:
```typescript
socket = io({
  withCredentials: true,
  autoConnect: false,
  reconnection: true,
  reconnectionAttempts: 10,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 5000,
});
```

**PWA enhancement:** Add offline queue that persists to IndexedDB for sends that happen while Socket.IO is disconnected for extended periods (when reconnection attempts are exhausted).

---

## Data Flow

### Online Message Flow (No Change from Current)

```
User types message
       |
       v
React Component (optimistic UI update)
       |
       v
socket.emit("message:send", data, callback)
       |
       v
Socket.IO Server validates & persists to PostgreSQL
       |
       v
io.to(room).emit("message:new", message)
       |
       v
All connected clients receive & render
```

### Offline Message Flow (New)

```
User types message (offline detected)
       |
       v
React Component (optimistic UI update with "pending" state)
       |
       v
Save to IndexedDB offline queue
       |
       v
Register Background Sync ("send-messages")
       |
       v
[Later: connectivity restored]
       |
       v
Service Worker receives "sync" event
       |
       v
Read pending messages from IndexedDB
       |
       v
POST to API endpoint (not Socket.IO - see rationale below)
       |
       v
API validates, persists, broadcasts via Socket.IO
       |
       v
On success: Remove from IndexedDB queue, notify app
On failure: Retry or surface error to UI
```

### Why POST to API, Not Socket.IO, for Background Sync

**Rationale:**
1. Service workers cannot use Socket.IO directly (no WebSocket in SW context)
2. Background Sync operates when app may be closed - no Socket.IO connection exists
3. HTTP POST to REST endpoint is reliable and debuggable
4. Server broadcasts to Socket.IO rooms after API-based persistence

**Implementation:** Add `POST /api/messages` endpoint that mirrors `message:send` socket handler behavior.

### Cache Population Flow

```
[App loads while online]
       |
       v
Socket.IO connects, joins rooms
       |
       v
Fetch recent messages via API (GET /api/channels/[id]/messages)
       |
       v
Store in IndexedDB (channel-keyed, with sequence numbers)
       |
       v
[Incoming Socket.IO messages]
       |
       v
Append to IndexedDB cache (preserves sequence order)
       |
       v
[App loads while offline]
       |
       v
Load from IndexedDB, render cached messages
       |
       v
[Goes online]
       |
       v
Socket.IO reconnects, fetch messages since last sequence
       |
       v
Merge new messages into IndexedDB
```

### Cache Invalidation Flow

```
[Socket.IO connection restored]
       |
       v
Compare IndexedDB lastSequence with server
       |
       v
[Gap detected: server has sequences IndexedDB doesn't]
       |
       v
Fetch missing messages via API
       |
       v
Merge into IndexedDB
       |
       v
[No gap: caches are in sync]
       |
       v
Continue receiving live updates
```

**Key:** Use `sequence` field (already in message schema) as sync cursor, not timestamps.

---

## Component Boundaries

### Service Worker Responsibilities

| Does | Does NOT |
|------|----------|
| Cache static assets (shell) | Run Socket.IO connections |
| Cache API responses (messages) | Make authorization decisions |
| Handle push events | Access React state |
| Process background sync | Modify IndexedDB schema |
| Serve offline fallback | Handle real-time message delivery |

**Service Worker Code Scope:**
```javascript
// sw.js handles:
// 1. Install: Cache shell assets
// 2. Fetch: Cache-first for shell, network-first for API
// 3. Push: Show notification, handle click
// 4. Sync: Process offline queue via HTTP POST
```

### React App Responsibilities

| Does | Does NOT |
|------|----------|
| Register service worker | Implement caching logic |
| Manage IndexedDB reads/writes | Process push events |
| Render UI (online and offline states) | Handle background sync |
| Connect Socket.IO | Serve cached responses |
| Subscribe to push notifications | Send push messages |
| Queue offline messages to IndexedDB | Process the queue directly |

### Server Responsibilities

| Does | Does NOT |
|------|----------|
| Persist messages to PostgreSQL | Cache in IndexedDB |
| Broadcast via Socket.IO | Know about service workers |
| Send push notifications via web-push | Handle offline detection |
| Provide sync cursor (sequence-based) | Track client cache state |
| Store push subscriptions | Generate service worker |

### Data Store Boundaries

| Store | Contains | Lifetime | Sync |
|-------|----------|----------|------|
| PostgreSQL | All messages, all users | Permanent | Source of truth |
| IndexedDB | Recent messages (7 days), offline queue, push subscription | Persistent | Client-only |
| Redis | Presence, pub-sub | Ephemeral | Server-side |
| Socket.IO buffer | Pending emits during reconnect | Session | Automatic |

---

## Build Order

### Phase Dependencies

```
                    [Manifest + Install Prompt]
                              |
                              v
[Service Worker Shell] ---> [Push Notifications]
        |
        v
   [IndexedDB Schema]
        |
        +---> [Message Caching] ---> [Cache Invalidation]
        |
        +---> [Offline Queue] ---> [Background Sync]

[Mobile Layout] (independent, can parallel)
```

### Recommended Implementation Order

**Phase 1: PWA Foundation** (No dependencies)
1. Web app manifest (`app/manifest.ts`)
2. Basic service worker (shell caching only)
3. Service worker registration component
4. Install prompt UI

**Phase 2: IndexedDB Setup** (Depends on Phase 1)
1. Dexie.js schema definition
2. React hooks for IndexedDB access (`useLiveQuery`)
3. Message storage operations

**Phase 3: Offline Message Cache** (Depends on Phase 2)
1. Cache population on channel load
2. Read from cache when offline
3. Cache invalidation on reconnect (sequence-based)
4. 7-day TTL with cleanup

**Phase 4: Offline Send Queue** (Depends on Phase 2)
1. Queue messages when Socket.IO disconnected
2. `POST /api/messages` endpoint
3. Background Sync registration
4. Service worker sync event handler
5. Queue cleanup on success

**Phase 5: Push Notifications** (Depends on Phase 1)
1. VAPID key generation and storage
2. Push subscription endpoint
3. Subscription management UI
4. Server-side `web-push` integration
5. Service worker push event handler
6. Notification click handling

**Phase 6: Mobile Layout** (Independent)
1. Bottom tab bar component
2. Responsive breakpoint handling
3. Mobile-optimized channel/DM views

### Why This Order

1. **Manifest first:** Zero dependencies, immediate PWA benefits (installability)
2. **Service worker second:** Required for all offline features
3. **IndexedDB before caching:** Schema must exist before storing messages
4. **Message cache before queue:** Users expect to read messages offline more than send
5. **Push last (of offline features):** Most complex, requires server changes
6. **Mobile layout parallel:** No technical dependencies on PWA features

---

## Caching Strategy

### What to Cache

| Resource | Strategy | Reason |
|----------|----------|--------|
| Shell (HTML, JS, CSS) | Cache-first | App loads instantly offline |
| Static assets (icons, fonts) | Cache-first | Never change |
| Message data | Network-first, IndexedDB fallback | Freshness matters |
| User profiles/avatars | Stale-while-revalidate | Update in background |
| API auth endpoints | Network-only | Cannot cache auth |

### IndexedDB Schema (Dexie.js)

```typescript
// lib/pwa/indexeddb.ts
import Dexie, { type Table } from 'dexie';

interface CachedMessage {
  id: string;
  channelId?: string;
  conversationId?: string;
  content: string;
  authorId: string;
  authorName: string;
  authorEmail: string;
  sequence: number;
  parentId?: string;
  replyCount: number;
  createdAt: Date;
  cachedAt: Date;
}

interface OfflineMessage {
  id: string; // Client-generated UUID
  targetId: string;
  targetType: 'channel' | 'dm';
  content: string;
  createdAt: Date;
  retryCount: number;
}

interface SyncCursor {
  id: string; // channelId or conversationId
  type: 'channel' | 'conversation';
  lastSequence: number;
  updatedAt: Date;
}

interface PushSubscriptionRecord {
  id: string;
  endpoint: string;
  keys: { p256dh: string; auth: string };
  createdAt: Date;
}

class OCommsDB extends Dexie {
  messages!: Table<CachedMessage>;
  offlineQueue!: Table<OfflineMessage>;
  syncCursors!: Table<SyncCursor>;
  pushSubscription!: Table<PushSubscriptionRecord>;

  constructor() {
    super('ocomms');
    this.version(1).stores({
      messages: 'id, [channelId+sequence], [conversationId+sequence], cachedAt',
      offlineQueue: 'id, createdAt',
      syncCursors: 'id',
      pushSubscription: 'id',
    });
  }
}

export const db = new OCommsDB();
```

### Cache Invalidation Triggers

| Trigger | Action |
|---------|--------|
| Socket.IO reconnect | Compare cursors, fetch gaps |
| 7-day TTL expired | Delete messages older than 7 days |
| User logout | Clear all IndexedDB data |
| Manual refresh (pull-to-refresh on mobile) | Refetch and merge |
| Push notification received | Optionally prefetch mentioned message |

### Sequence-Based Sync

**Why sequences, not timestamps:**
1. Already exist in message schema (`sequence: integer`)
2. Guaranteed unique per channel/conversation
3. No timezone issues
4. Simple gap detection: `lastCachedSequence + 1 !== serverNextSequence`

**New sync API endpoint:**
```
GET /api/channels/[channelId]/messages?since_sequence=42&limit=100
```

Returns messages with `sequence > since_sequence`, ordered ascending.

---

## Push Notification Architecture

### Subscription Flow

```
User enables notifications in app settings
       |
       v
Request notification permission (browser)
       |
       v
Call pushManager.subscribe() with VAPID public key
       |
       v
POST subscription to /api/push/subscribe
       |
       v
Server stores: { userId, subscription: { endpoint, keys } }
       |
       v
Subscription stored in both PostgreSQL and IndexedDB (for revalidation)
```

### Notification Delivery Flow

```
[Mention detected in message handler]
       |
       v
Server looks up target user's push subscriptions
       |
       v
Server calls webpush.sendNotification()
       |
       v
Push service queues notification
       |
       v
[User's device online, service worker running]
       |
       v
Service worker receives "push" event
       |
       v
self.registration.showNotification(title, options)
       |
       v
[User clicks notification]
       |
       v
Service worker receives "notificationclick" event
       |
       v
clients.openWindow('/workspace/[id]/channel/[slug]')
```

### VAPID Key Management

```bash
# Generate once, store in environment
npx web-push generate-vapid-keys

# .env
VAPID_PUBLIC_KEY=BEl62...
VAPID_PRIVATE_KEY=UGGDq...
VAPID_SUBJECT=mailto:admin@ocomms.example.com
```

### Push Subscription Database Schema (new)

```typescript
// db/schema/push-subscription.ts
export const pushSubscriptions = pgTable("push_subscriptions", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id")
    .notNull()
    .references(() => users.id, { onDelete: "cascade" }),
  endpoint: text("endpoint").notNull(),
  p256dh: text("p256dh").notNull(),
  auth: text("auth").notNull(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
}, (table) => [
  index("push_subscriptions_user_idx").on(table.userId),
  uniqueIndex("push_subscriptions_endpoint_idx").on(table.endpoint),
]);
```

### Notification Types to Support

| Event | Notification | Deep Link |
|-------|-------------|-----------|
| @mention | "Alice mentioned you in #general" | Channel with message highlighted |
| DM | "Bob sent you a message" | DM conversation |
| @channel/@here | "Announcement in #announcements" | Channel |
| Thread reply | "Alice replied to your thread" | Thread view |

---

## Mobile Layout Integration

### Responsive Breakpoints

```typescript
// Tailwind breakpoints:
// sm: 640px, md: 768px, lg: 1024px

// Mobile-first approach:
// < 768px: Mobile layout (bottom tabs)
// >= 768px: Desktop layout (sidebar)
```

### Bottom Tab Bar Component

```tsx
// components/mobile/BottomTabBar.tsx
// Renders only on mobile (md:hidden)
// Fixed position at bottom
// Tabs: Home, DMs, Mentions, Settings
```

### Layout Structure

```
Desktop (md+):
+------------------+------------------------+
|    Sidebar       |      Main Content      |
|   (channels)     |    (messages view)     |
+------------------+------------------------+

Mobile (<md):
+----------------------------------+
|           Main Content           |
|        (messages view)           |
+----------------------------------+
|  [Home] [DMs] [Mentions] [More]  |  <- BottomTabBar
+----------------------------------+
```

### Mobile View Hierarchy

```
/ (workspace selection)
  /[workspaceId]
    /channels (tab: Home - list of channels)
    /dms (tab: DMs - list of conversations)
    /mentions (tab: Mentions - notification inbox)
    /settings (tab: More - profile, notifications, logout)
    /channel/[slug] (pushed view - messages)
    /dm/[id] (pushed view - messages)
```

### Navigation Pattern

- Bottom tabs for top-level navigation
- Push/pop for drilling into channels/DMs
- Swipe gestures optional (defer to later)

---

## Service Worker Communication

### App to Service Worker

**Method:** `navigator.serviceWorker.controller.postMessage()`

**Use cases:**
1. Trigger immediate sync (user hits "send" while offline, wants retry)
2. Clear caches on logout
3. Update push subscription

```typescript
// lib/pwa/sw-communication.ts
export function triggerBackgroundSync() {
  navigator.serviceWorker.ready.then((registration) => {
    registration.sync.register('send-messages');
  });
}

export function notifyServiceWorker(message: { type: string; payload?: unknown }) {
  navigator.serviceWorker.controller?.postMessage(message);
}
```

### Service Worker to App

**Method:** `BroadcastChannel` API (simpler than MessageChannel)

**Use cases:**
1. Notify app of sync completion
2. Pass push notification data for in-app display
3. Report cache updates

```javascript
// sw.js
const channel = new BroadcastChannel('ocomms-sw');
channel.postMessage({ type: 'sync-complete', count: 3 });

// React component
const channel = new BroadcastChannel('ocomms-sw');
channel.onmessage = (event) => {
  if (event.data.type === 'sync-complete') {
    toast.success(`Sent ${event.data.count} queued messages`);
  }
};
```

---

## Authentication Integration

### Service Worker Auth Context

**Challenge:** Service worker cannot access cookies directly for auth decisions.

**Solution:** Service worker trusts app for auth; auth validation happens server-side.

1. Offline queue stores userId (from current session) with each message
2. Background sync POST includes session cookie (cookies sent with fetch from SW)
3. Server validates session as normal
4. If session expired, sync fails, SW reports to app, app prompts re-login

### Push Subscription Auth

**Flow:**
1. App creates push subscription (requires active session)
2. POST to `/api/push/subscribe` with session cookie
3. Server associates subscription with authenticated user
4. Subscription persists across sessions (until user revokes or logs out)

**Logout cleanup:**
```typescript
// On logout:
// 1. Call POST /api/push/unsubscribe
// 2. Clear IndexedDB
// 3. Unregister service worker (optional - or just clear caches)
```

---

## Error Handling & Edge Cases

### Offline Queue Failures

| Failure | Response |
|---------|----------|
| Network error | Retry via Background Sync (browser managed) |
| Auth error (401/403) | Remove from queue, surface to UI, prompt login |
| Server error (500) | Retry with exponential backoff, max 3 attempts |
| Message too old (> 24h) | Remove from queue, notify user |

### Cache Corruption

| Issue | Detection | Recovery |
|-------|-----------|----------|
| Stale data | Sequence gaps on reconnect | Fetch missing, merge |
| IndexedDB error | Dexie error handler | Clear DB, refetch on next load |
| Service worker update | `updatefound` event | Prompt user to refresh |

### Push Subscription Expiry

Push subscriptions can expire. Handle by:
1. Store subscription in IndexedDB
2. On app load, validate with server
3. If server doesn't have subscription, re-subscribe

---

## Technology Recommendations

### Libraries to Add

| Library | Purpose | Rationale |
|---------|---------|-----------|
| `dexie` + `dexie-react-hooks` | IndexedDB with React integration | Best DX, `useLiveQuery` auto-updates UI |
| `web-push` | Server-side push notifications | Standard library, VAPID support |
| `idb` (alternative) | Lightweight IndexedDB wrapper | If Dexie feels heavy (but Dexie recommended) |

### No Additional Libraries Needed For

| Feature | Built-in Solution |
|---------|-------------------|
| Service Worker | Native Service Worker API |
| Push Subscription | Native Push API |
| Background Sync | Native Background Sync API |
| Manifest | Next.js `app/manifest.ts` |
| Offline Detection | `navigator.onLine` + `online`/`offline` events |

---

## Sources

### Official Documentation (HIGH confidence)
- [MDN: Offline and background operation](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Guides/Offline_and_background_operation)
- [Socket.IO: Offline behavior](https://socket.io/docs/v3/client-offline-behavior/)
- [web.dev: Two-way communication with service workers](https://web.dev/articles/two-way-communication-guide)
- [web-push Node.js library](https://github.com/web-push-libs/web-push/blob/master/README.md)
- [Dexie.js React hooks](https://dexie.org/docs/libs/dexie-react-hooks)

### Patterns & Best Practices (MEDIUM confidence)
- [LogRocket: Offline-first frontend apps in 2025](https://blog.logrocket.com/offline-first-frontend-apps-2025-indexeddb-sqlite/)
- [DEV Community: PWA Setup Guide for Next.js 15](https://dev.to/rakibcloud/progressive-web-app-pwa-setup-guide-for-nextjs-15-complete-step-by-step-walkthrough-2b85)
- [Medium: PWA in Next.js App Router 2026](https://medium.com/@amirjld/how-to-implement-pwa-progressive-web-app-in-next-js-app-router-2026-f25a6797d5e6)
- [Felix Gerschau: How to communicate with Service Workers](https://felixgerschau.com/how-to-communicate-with-service-workers/)

### IndexedDB Cache Invalidation (MEDIUM confidence)
- [GitHub Gist: IndexedDB Cache Invalidation with WebSockets](https://gist.github.com/seanvm/948160cb64d78790a5e5e1dc8135d828)
- [LogRocket: Cache invalidation strategies using IndexedDB](https://blog.logrocket.com/cache-invalidation-strategies-using-indexeddb-in-angular-2/)

---

## Roadmap Implications

### Phase Structure Recommendation

Based on technical dependencies:

1. **PWA Foundation** - Manifest, basic SW, install prompt (independent, start first)
2. **IndexedDB Schema** - Dexie setup, React hooks (foundation for all offline)
3. **Message Caching** - Cache on load, read offline, invalidate on reconnect
4. **Offline Send Queue** - Queue, API endpoint, Background Sync
5. **Push Notifications** - VAPID, subscriptions, server integration
6. **Mobile Layout** - Bottom tabs, responsive views (can parallel with 3-5)

### Research Flags

| Phase | Flag | Reason |
|-------|------|--------|
| Offline Send Queue | NEEDS_RESEARCH | Background Sync browser support and limitations vary |
| Push Notifications | NEEDS_RESEARCH | Safari/iOS push subscription quirks, VAPID rotation |
| Mobile Layout | LOW_RISK | Standard responsive patterns, no surprises expected |

### Complexity Assessment

| Component | Complexity | Notes |
|-----------|------------|-------|
| Manifest + Install | Low | Boilerplate, well-documented |
| Service Worker (caching) | Medium | Cache strategies need tuning |
| IndexedDB setup | Low | Dexie abstracts complexity |
| Message caching | Medium | Sequence-based sync logic |
| Offline queue | High | Background Sync + error handling + edge cases |
| Push notifications | High | Server changes + VAPID + Safari quirks |
| Mobile layout | Medium | Responsive but need UX decisions |
